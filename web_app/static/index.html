<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutoGLM Web Server</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        /* Theme Variables */
        :root {
            /* Light Mode (Default) */
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #f5f5f5;
            --bg-card: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #64748b;
            --text-muted: #94a3b8;
            --border-color: #e2e8f0;
            --shadow-sm: rgba(0, 0, 0, 0.05);
            --shadow-md: rgba(0, 0, 0, 0.1);
            --shadow-lg: rgba(0, 0, 0, 0.15);
            --accent-primary: #3b82f6;
            --accent-hover: #2563eb;
            --success: #10b981;
            --warning: #f59e0b;
            --error: #ef4444;
        }

        [data-theme="dark"] {
            /* Dark Mode */
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-tertiary: #334155;
            --bg-card: #1e293b;
            --text-primary: #f1f5f9;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --border-color: #475569;
            --shadow-sm: rgba(0, 0, 0, 0.3);
            --shadow-md: rgba(0, 0, 0, 0.5);
            --shadow-lg: rgba(0, 0, 0, 0.7);
            --accent-primary: #60a5fa;
            --accent-hover: #3b82f6;
            --success: #34d399;
            --warning: #fbbf24;
            --error: #f87171;
        }

        /* Smooth theme transitions */
        *,
        *::before,
        *::after {
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease;
        }

        [v-cloak] {
            display: none;
        }

        /* Chat Page Styles */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 48px);
            max-height: calc(100vh - 48px);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .chat-message {
            display: flex;
            gap: 10px;
            max-width: 90%;
        }

        .chat-message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .chat-message.assistant {
            align-self: flex-start;
        }

        .chat-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .chat-message.user .chat-avatar {
            background: #3b82f6;
        }

        .chat-message.assistant .chat-avatar {
            background: #10b981;
        }

        .chat-bubble {
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.5;
            word-break: break-word;
            width: 480px;
            min-width: 200px;
            max-width: 480px;
            overflow: hidden;
        }

        .chat-message.user .chat-bubble {
            background: #3b82f6;
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.assistant .chat-bubble {
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border-bottom-left-radius: 4px;
        }

        .chat-bubble.running {
            background: #fef3c7;
            border: 1px solid #f59e0b;
        }

        .chat-bubble.error {
            background: #fee2e2;
            border: 1px solid #ef4444;
        }

        .chat-bubble.success {
            background: #d1fae5;
            border: 1px solid #10b981;
        }

        /* Compact task result */
        .task-result {
            font-size: 12px;
            margin-top: 6px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 6px;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            word-break: break-all;
        }

        .task-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .task-log-item {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            color: var(--text-secondary);
            padding: 2px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            word-break: break-all;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }

        .task-log-item:last-child {
            border-bottom: none;
        }

        .subtask-log-section {
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px dashed rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .subtask-log-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .subtask-log-header {
            font-size: 11px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            word-break: break-all;
            overflow-wrap: break-word;
        }

        .task-log-more {
            font-size: 10px;
            color: #9ca3af;
            font-style: italic;
        }

        .chat-meta {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 4px;
            text-align: right;
        }

        /* TodoList Ê†∑Âºè (Â§çÊùÇ‰ªªÂä°Ê®°Âºè) */
        .todo-list-card {
            margin-top: 10px;
            padding: 10px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .todo-list-header {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 8px;
            color: var(--text-primary);
        }

        .todo-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .todo-item:last-child {
            margin-bottom: 0;
        }

        .todo-item.pending {
            background: var(--bg-card);
            color: var(--text-secondary);
        }

        .todo-item.running {
            background: #fef3c7;
            color: #92400e;
        }

        .todo-item.completed {
            background: #d1fae5;
            color: #065f46;
        }

        .todo-item.failed {
            background: #fee2e2;
            color: #991b1b;
        }

        .todo-status {
            flex-shrink: 0;
            width: 16px;
            text-align: center;
            font-size: 14px;
        }

        .todo-content {
            flex: 1;
            word-break: normal;
            overflow-wrap: normal;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            min-width: 0;
            color: inherit;
        }

        /* TodoList Confirmation Styles */
        .todo-confirmation {
            margin-top: 12px;
            border-top: 2px dashed #e5e7eb;
            padding-top: 12px;
        }

        .confirmation-banner {
            background: linear-gradient(135deg, #fff7ed 0%, #fed7aa 100%);
            border-left: 4px solid #f59e0b;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .confirmation-banner strong {
            color: #92400e;
            font-size: 15px;
            display: block;
            margin-bottom: 4px;
        }

        .confirmation-banner p {
            margin: 0;
            font-size: 13px;
            color: #78350f;
            line-height: 1.5;
        }

        .confirmation-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn-confirm {
            background: #10b981;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-confirm:hover {
            background: #059669;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .btn-cancel {
            background: #ef4444;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.2s;
        }

        .btn-cancel:hover {
            background: #dc2626;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
        }

        .todo-input {
            flex: 1;
            min-width: 300px;
            padding: 4px 10px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 13px;
            background: var(--bg-card);
            font-family: inherit;
            resize: none;
            overflow-x: hidden;
            overflow-y: auto;
            min-height: 28px;
            max-height: 120px;
            line-height: 1.4;
            white-space: pre-wrap;
        }

        .todo-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .todo-item.editable {
            background: var(--bg-card);
            border: 1px dashed #cbd5e1;
        }

        .todo-item.editable:hover {
            border-color: var(--text-muted);
            background: var(--bg-tertiary);
        }

        .todo-item-controls {
            display: flex;
            gap: 3px;
            margin-left: 6px;
            flex-shrink: 0;
        }

        .todo-control-btn {
            padding: 2px 4px;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            background: var(--bg-card);
            cursor: pointer;
            font-size: 11px;
            color: #6b7280;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 20px;
            height: 20px;
        }

        .todo-control-btn:hover {
            background: var(--bg-tertiary);
            border-color: #d1d5db;
        }

        .todo-control-btn.delete:hover {
            background: #fee2e2;
            border-color: #fca5a5;
            color: #dc2626;
        }

        .todo-control-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* TodoList Animation Styles */
        .todo-list-move,
        .todo-list-enter-active,
        .todo-list-leave-active {
            transition: all 0.5s cubic-bezier(0.55, 0, 0.1, 1);
        }

        .todo-list-enter-from {
            opacity: 0;
            transform: translateY(-30px);
        }

        .todo-list-leave-to {
            opacity: 0;
            transform: translateX(-30px);
        }

        .todo-list-leave-active {
            position: absolute;
            width: 100%;
        }

        .todo-item {
            transition: all 0.3s cubic-bezier(0.55, 0, 0.1, 1);
        }

        .chat-input-container {
            padding: 12px 16px;
            border-top: 1px solid #e5e5e5;
            background: var(--bg-card);
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid #e5e5e5;
            border-radius: 20px;
            font-size: 14px;
            resize: none;
            max-height: 100px;
            line-height: 1.4;
        }

        .chat-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .chat-send-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #3b82f6;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0;
        }

        .chat-send-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }

        .chat-send-btn:hover:not(:disabled) {
            background: #2563eb;
        }

        .chat-stop-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
            animation: pulse-red 1.5s infinite;
        }

        .chat-stop-btn:hover {
            background: #dc2626;
        }

        @keyframes pulse-red {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }

            50% {
                box-shadow: 0 0 0 8px rgba(239, 68, 68, 0);
            }
        }

        .chat-device-selector {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .chat-device-selector select {
            padding: 4px 8px;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            font-size: 12px;
            max-width: 200px;
        }

        .mini-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f59e0b;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 6px;
        }

        /* Chat header with email toggle */
        .chat-header {
            padding: 8px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .chat-header-right {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .email-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toggle-switch {
            position: relative;
            width: 36px;
            height: 20px;
            background: #d1d5db;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle-switch.active {
            background: #3b82f6;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: var(--bg-card);
            border-radius: 50%;
            transition: left 0.2s;
        }

        .toggle-switch.active::after {
            left: 18px;
        }

        /* Clickable task result */
        .task-result {
            font-size: 12px;
            margin-top: 6px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 6px;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            word-break: break-all;
            cursor: pointer;
            transition: background 0.2s;
        }

        .task-result:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        .task-result-hint {
            font-size: 10px;
            color: var(--text-muted);
            text-align: center;
            margin-top: 4px;
        }

        /* Task Detail Modal */
        .task-detail-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .task-detail-content {
            background: var(--bg-card);
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .task-detail-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .task-detail-header h3 {
            margin: 0;
            font-size: 16px;
        }

        .task-detail-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: var(--text-muted);
        }

        .task-detail-close:hover {
            color: var(--text-primary);
        }

        .task-detail-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .task-detail-section {
            margin-bottom: 20px;
        }

        .task-detail-section h4 {
            font-size: 14px;
            margin: 0 0 10px 0;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .task-detail-logs {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 16px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            max-height: 500px;
            overflow-y: auto;
            line-height: 1.6;
            color: var(--text-primary);
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .task-detail-screenshot {
            text-align: center;
        }

        .task-detail-screenshot img {
            max-width: 280px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        .task-detail-screenshot-placeholder {
            padding: 40px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            color: var(--text-muted);
        }

        .task-detail-stats {
            display: flex;
            gap: 20px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .task-detail-stat {
            text-align: center;
        }

        .task-detail-stat-value {
            font-size: 24px;
            font-weight: 600;
        }

        .task-detail-stat-label {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Phone Preview Window Styles */
        .phone-preview-window {
            position: fixed;
            background: var(--bg-card);
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            overflow: hidden;
            min-width: 180px;
            min-height: 200px;
            max-width: 350px;
            /* ÈôêÂà∂ÊúÄÂ§ßÂÆΩÂ∫¶ */
            max-height: 70vh;
            /* ÈôêÂà∂ÊúÄÂ§ßÈ´òÂ∫¶‰∏∫ËßÜÂè£ÁöÑ70% */
            transform-origin: center;
        }

        .phone-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #18181b;
            color: white;
            cursor: move;
            user-select: none;
        }

        .phone-preview-title {
            font-size: 13px;
            font-weight: 500;
        }

        .phone-preview-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .phone-preview-select {
            background: #27272a;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            max-width: 100px;
            cursor: pointer;
        }

        .phone-preview-btn {
            background: #27272a;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .phone-preview-btn:hover {
            background: #3f3f46;
        }

        .phone-preview-body {
            width: 300px;
            height: 540px;
            background: #f4f4f5;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .phone-preview-image {
            max-width: 450px;
            max-height: 60vh;
            width: auto;
            height: auto;
            object-fit: contain;
            display: block;
            margin: 0 auto;
        }

        .phone-preview-placeholder {
            color: var(--text-muted);
            font-size: 12px;
            text-align: center;
            padding: 20px;
        }

        .phone-preview-toggle {
            position: fixed;
            bottom: 120px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #18181b;
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .phone-preview-toggle:hover {
            background: #27272a;
            transform: scale(1.1);
        }

        /* Chat Sessions Sidebar */
        .chat-sessions-sidebar {
            width: 220px;
            background: var(--bg-tertiary);
            border-right: 1px solid #e5e5e5;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .chat-sessions-header {
            padding: 12px;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-sessions-header h3 {
            font-size: 13px;
            margin: 0;
            color: var(--text-primary);
        }

        .chat-new-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .chat-new-btn:hover {
            background: #2563eb;
        }

        .chat-sessions-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .chat-session-item {
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .chat-session-item:hover {
            background: var(--bg-tertiary);
        }

        .chat-session-item.active {
            background: var(--accent-primary);
        }

        .chat-session-item.active .chat-session-title,
        .chat-session-item.active .chat-session-time {
            color: white;
        }

        .chat-session-info {
            flex: 1;
            min-width: 0;
        }

        .chat-session-title {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-primary);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-session-time {
            font-size: 11px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .chat-session-delete {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .chat-session-item:hover .chat-session-delete {
            opacity: 1;
        }

        .chat-session-delete:hover {
            background: #fee2e2;
            color: #ef4444;
        }

        .chat-main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .chat-with-sidebar {
            display: flex;
            height: calc(100vh - 48px);
        }
    </style>
</head>

<body>
    <div id="app" v-cloak>
        <div class="app-container">
            <!-- Sidebar -->
            <aside class="sidebar">
                <div class="sidebar-header">
                    <h1>È±ºÂ°òÁÆ°ÁêÜÂô®</h1>
                    <div class="subtitle">AI ÊâãÊú∫Ëá™Âä®Âåñ‰∏ìÂÆ∂</div>
                </div>

                <ul class="nav-menu">
                    <li class="nav-item" :class="{ active: currentPage === 'chat' }" @click="currentPage = 'chat'">
                        <span>üí¨</span>
                        <span>ÂØπËØù</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'devices' }"
                        @click="currentPage = 'devices'">
                        <span>üì±</span>
                        <span>ËÆæÂ§á</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'tasks' }" @click="currentPage = 'tasks'">
                        <span>‚ñ∂Ô∏è</span>
                        <span>‰ªªÂä°ÊâßË°å</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'scheduler' }"
                        @click="currentPage = 'scheduler'">
                        <span>‚è∞</span>
                        <span>ÂÆöÊó∂‰ªªÂä°</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'models' }" @click="currentPage = 'models'">
                        <span>ü§ñ</span>
                        <span>Ê®°ÂûãÈÖçÁΩÆ</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'files' }" @click="currentPage = 'files'">
                        <span>üìÅ</span>
                        <span>Êñá‰ª∂ÁÆ°ÁêÜ</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'rules' }" @click="currentPage = 'rules'">
                        <span>üìã</span>
                        <span>ËßÑÂàôÈÖçÁΩÆ</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'settings' }"
                        @click="currentPage = 'settings'">
                        <span>‚öôÔ∏è</span>
                        <span>ËÆæÁΩÆ</span>
                    </li>
                </ul>

                <!-- Connection Status -->
                <div style="position: absolute; bottom: 20px; left: 20px; right: 20px;">
                    <div class="connection-status" :class="wsConnected ? 'connected' : 'disconnected'">
                        <span class="status-dot"></span>
                        <span>{{ wsConnected ? 'Â∑≤ËøûÊé•' : 'Êú™ËøûÊé•' }}</span>
                    </div>
                </div>
            </aside>

            <!-- Main Content -->
            <main class="main-content">
                <!-- Chat Page (Default) -->
                <div v-if="currentPage === 'chat'" class="fade-in chat-with-sidebar">
                    <!-- Sessions Sidebar -->
                    <div class="chat-sessions-sidebar">
                        <div class="chat-sessions-header">
                            <h3>üí¨ ‰ºöËØùÂéÜÂè≤</h3>
                            <button class="chat-new-btn" @click="createNewSession">
                                <span>+</span> Êñ∞Âª∫
                            </button>
                        </div>
                        <div class="chat-sessions-list">
                            <div v-if="chatSessions.length === 0"
                                style="text-align: center; color: var(--text-muted); padding: 20px; font-size: 12px;">
                                ÊöÇÊó†‰ºöËØùËÆ∞ÂΩï
                            </div>
                            <div v-for="session in chatSessions" :key="session.id" class="chat-session-item"
                                :class="{ active: currentSessionId === session.id }" @click="switchSession(session.id)">
                                <div class="chat-session-info">
                                    <div class="chat-session-title">{{ session.title || 'Êñ∞‰ºöËØù' }}</div>
                                    <div class="chat-session-time">{{ formatSessionTime(session.updatedAt) }}</div>
                                </div>
                                <button class="chat-session-delete" @click.stop="deleteSession(session.id)"
                                    title="Âà†Èô§‰ºöËØù">
                                    üóëÔ∏è
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Main Chat Area -->
                    <div class="chat-main-area">
                        <!-- Chat Header with Device Selector and Email Toggle -->
                        <div class="chat-header">
                            <div class="chat-header-left">
                                <span>üì± ËÆæÂ§á:</span>
                                <select v-model="chatDeviceId" @change="onChatDeviceChange">
                                    <option value="">ÈÄâÊã©ËÆæÂ§á</option>
                                    <option v-for="d in devices" :key="d.id" :value="d.id">
                                        {{ d.name || d.id.substring(0, 20) }}
                                    </option>
                                </select>
                                <span v-if="chatDeviceId" style="color: #10b981;">‚úì Â∑≤ËøûÊé•</span>
                                <span v-else style="color: #f59e0b;">ËØ∑ÂÖàÈÄâÊã©ËÆæÂ§á</span>
                            </div>
                            <div class="chat-header-right">
                                <div class="email-toggle" v-if="complexTaskMode" style="margin-right: 12px;">
                                    <span>‚è±Ô∏è Ë∂ÖÊó∂</span>
                                    <select v-model="subtaskTimeoutSeconds"
                                        style="padding: 4px 8px; border-radius: 6px; border: 1px solid var(--border-color); font-size: 12px; background: var(--bg-card); color: var(--text-primary);">
                                        <option :value="60">1ÂàÜÈíü</option>
                                        <option :value="120">2ÂàÜÈíü</option>
                                        <option :value="180">3ÂàÜÈíü</option>
                                        <option :value="300">5ÂàÜÈíü</option>
                                        <option :value="600">10ÂàÜÈíü</option>
                                    </select>
                                </div>
                                <div class="email-toggle">
                                    <span>üß© Â§çÊùÇ‰ªªÂä°</span>
                                    <div class="toggle-switch" :class="{ active: complexTaskMode }"
                                        @click="complexTaskMode = !complexTaskMode"></div>
                                </div>
                                <div class="email-toggle">
                                    <span>üìß Ëá™Âä®ÂèëÈÄÅÈÇÆ‰ª∂</span>
                                    <div class="toggle-switch" :class="{ active: chatAutoEmail }"
                                        @click="chatAutoEmail = !chatAutoEmail"></div>
                                </div>
                                <div class="email-toggle">
                                    <span>üêõ Ë∞ÉËØïÊ®°Âºè</span>
                                    <div class="toggle-switch" :class="{ active: debugMode }"
                                        @click="debugMode = !debugMode"></div>
                                </div>
                                <div class="email-toggle">
                                    <span>üåô ÊöóÈªëÊ®°Âºè</span>
                                    <div class="toggle-switch" :class="{ active: darkMode }" @click="toggleDarkMode">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Messages Area -->
                        <div class="chat-messages" ref="chatMessagesRef">
                            <div v-if="chatMessages.length === 0"
                                style="text-align: center; color: var(--text-muted); padding: 40px;">
                                <div style="font-size: 48px; margin-bottom: 16px;">ü§ñ</div>
                                <div>‰Ω†Â•ΩÔºÅËØ∑ËæìÂÖ•‰ªªÂä°Êåá‰ª§ÔºåÊàë‰ºöÂ∏Æ‰Ω†Âú®ÊâãÊú∫‰∏äÊâßË°å„ÄÇ</div>
                                <div style="font-size: 12px; margin-top: 8px; color: var(--text-muted);">
                                    ‰æãÂ¶ÇÔºöÊâìÂºÄÂæÆ‰ø°ÔºåÂèëÈÄÅÊ∂àÊÅØÁªôÊüê‰∫∫...</div>
                            </div>
                            <div v-for="(msg, idx) in chatMessages" :key="idx" class="chat-message" :class="msg.role">
                                <div class="chat-avatar">{{ msg.role === 'user' ? 'üë§' : 'ü§ñ' }}</div>
                                <div class="chat-bubble" :class="msg.status || ''">
                                    <div v-if="msg.role === 'user'">{{ msg.content }}</div>
                                    <div v-else>
                                        <div v-if="msg.status === 'running'">
                                            <span class="mini-spinner"></span>Ê≠£Âú®ÊâßË°å‰ªªÂä°...
                                        </div>
                                        <div v-else>{{ msg.content }}</div>
                                        <!-- TodoList ÊòæÁ§∫ (Â§çÊùÇ‰ªªÂä°Ê®°Âºè) -->
                                        <div v-if="msg.todoList && msg.todoList.length > 0" class="todo-list-card">
                                            <div class="todo-list-header">üìã ‰ªªÂä°Ê∏ÖÂçï</div>
                                            <TransitionGroup name="todo-list" tag="div">
                                                <div v-for="(item, ti) in msg.todoList" :key="`todo-${idx}-${ti}`"
                                                    class="todo-item"
                                                    :class="[item.status, { editable: msg.status === 'pending_confirmation' }]">
                                                    <div class="todo-item-header">
                                                        <span class="todo-status">
                                                            <span v-if="item.status === 'completed'">‚úÖ</span>
                                                            <span v-else-if="item.status === 'running'"
                                                                class="mini-spinner"></span>
                                                            <span v-else-if="item.status === 'failed'">‚ùå</span>
                                                            <span v-else-if="item.status === 'skipped'">‚è≠Ô∏è</span>
                                                            <span v-else>‚¨ú</span>
                                                        </span>
                                                        <!-- Editable input when awaiting confirmation -->
                                                        <textarea v-if="msg.status === 'pending_confirmation'"
                                                            v-model="item.content" class="todo-input"
                                                            @blur="saveCurrentSession"
                                                            @input="autoResizeTextarea($event)" placeholder="ÁºñËæëÂ≠ê‰ªªÂä°ÂÜÖÂÆπ..."
                                                            rows="1"></textarea>
                                                        <!-- Control buttons (only when editing) -->
                                                        <div v-if="msg.status === 'pending_confirmation'"
                                                            class="todo-item-controls">
                                                            <button @click="moveTodoUp(msg, ti)" :disabled="ti === 0"
                                                                class="todo-control-btn" title="‰∏äÁßª">
                                                                ‚ñ≤
                                                            </button>
                                                            <button @click="moveTodoDown(msg, ti)"
                                                                :disabled="ti === msg.todoList.length - 1"
                                                                class="todo-control-btn" title="‰∏ãÁßª">
                                                                ‚ñº
                                                            </button>
                                                            <button @click="deleteTodo(msg, ti)"
                                                                :disabled="msg.todoList.length <= 1"
                                                                class="todo-control-btn delete" title="Âà†Èô§">
                                                                üóëÔ∏è
                                                            </button>
                                                        </div>
                                                        <!-- Normal display -->
                                                        <span v-else class="todo-content">{{ item.content }}</span>
                                                        <span
                                                            v-if="chatRunning && item.status === 'running' && subtaskCountdown > 0"
                                                            style="margin-left: auto; padding: 2px 8px; border-radius: 4px; 
                                                               background: rgba(59, 130, 246, 0.1); color: #3b82f6; 
                                                               font-size: 11px; font-family: monospace;">
                                                            ‚è±Ô∏è {{ Math.floor(subtaskCountdown / 60) }}:{{
                                                            String(subtaskCountdown % 60).padStart(2, '0') }}
                                                        </span>
                                                        <button v-if="chatRunning && item.status === 'running'"
                                                            @click.stop="skipSubtask(msg)" title="Ë∑≥ËøáÊ≠§Ê≠•È™§"
                                                            style="margin-left: 8px; padding: 2px 8px; border-radius: 4px; 
                                                               background: rgba(251, 191, 36, 0.1); color: #d97706; border: 1px solid rgba(251, 191, 36, 0.3);
                                                               cursor: pointer; font-size: 11px; display: flex; align-items: center; gap: 4px; transition: all 0.2s;"
                                                            @mouseenter="$event.target.style.background='rgba(251, 191, 36, 0.2)'"
                                                            @mouseleave="$event.target.style.background='rgba(251, 191, 36, 0.1)'">
                                                            ‚è≠Ô∏è Ë∑≥Ëøá
                                                        </button>
                                                    </div>
                                                </div>
                                            </TransitionGroup>


                                            <!-- Confirmation UI (only show when pending confirmation) -->
                                            <div v-if="msg.status === 'pending_confirmation'" class="todo-confirmation">
                                                <div class="confirmation-banner">
                                                    <strong>‚è∏Ô∏è ‰ªªÂä°Â∑≤ÊãÜËß£ÔºåËØ∑Á°ÆËÆ§Ê∏ÖÂçï</strong>
                                                    <p>ÊÇ®ÂèØ‰ª•ÁÇπÂáª‰∏äÊñπ‰ªªÊÑèÂ≠ê‰ªªÂä°ËøõË°åÁºñËæë„ÄÇÁ°ÆËÆ§Êó†ËØØÂêéÁÇπÂáªÁªßÁª≠ÊâßË°å„ÄÇ</p>
                                                </div>
                                                <div class="confirmation-actions">
                                                    <button @click="cancelTodoList(msg)" class="btn-cancel">
                                                        ‚ùå ÂèñÊ∂à‰ªªÂä°
                                                    </button>
                                                    <button @click="confirmTodoList(msg)" class="btn-confirm">
                                                        ‚úÖ Á°ÆËÆ§Âπ∂ÂºÄÂßãÊâßË°å
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                        <!-- Compact Task Result (Clickable) - ÈõÜ‰∏≠ÊòæÁ§∫ÊâÄÊúâÂ≠ê‰ªªÂä°Êó•Âøó -->
                                        <div v-if="(msg.logs && msg.logs.length > 0) || (msg.todoList && msg.todoList.some(t => t.logs && t.logs.length > 0))"
                                            class="task-result" @click="openTaskDetail(msg)">
                                            <div class="task-result-header">
                                                <span>ÊâßË°åÊó•Âøó</span>
                                                <span v-if="msg.status === 'success'" style="color: #10b981;">‚úì
                                                    ÂÆåÊàê</span>
                                                <span v-else-if="msg.status === 'error'" style="color: #ef4444;">‚úó
                                                    Â§±Ë¥•</span>
                                            </div>
                                            <!-- ÊåâÂ≠ê‰ªªÂä°ÂàÜÁªÑÊòæÁ§∫Êó•Âøó -->
                                            <template
                                                v-if="msg.todoList && msg.todoList.some(t => t.logs && t.logs.length > 0)">
                                                <template v-for="(item, ti) in msg.todoList" :key="'todo-log-'+ti">
                                                    <div v-if="item.logs && item.logs.length > 0"
                                                        class="subtask-log-section">
                                                        <div class="subtask-log-header">
                                                            <span v-if="item.status === 'completed'">‚úÖ</span>
                                                            <span v-else-if="item.status === 'running'"
                                                                class="mini-spinner"></span>
                                                            <span v-else-if="item.status === 'failed'">‚ùå</span>
                                                            <span v-else>‚¨ú</span>
                                                            {{ item.content }}
                                                        </div>
                                                        <div v-for="(log, li) in item.logs.slice(-3)" :key="li"
                                                            class="task-log-item">{{ log }}</div>
                                                        <div v-if="item.logs.length > 3" class="task-log-more">... ÂÖ± {{
                                                            item.logs.length }} Êù°</div>
                                                    </div>
                                                </template>
                                            </template>
                                            <!-- ÊôÆÈÄöÊó•ÂøóÔºàÈùûÂ≠ê‰ªªÂä°Ê®°ÂºèÔºâ -->
                                            <template v-else-if="msg.logs && msg.logs.length > 0">
                                                <div v-for="(log, i) in msg.logs.slice(-3)" :key="i"
                                                    class="task-log-item">
                                                    {{ log }}
                                                </div>
                                            </template>
                                            <div class="task-result-hint">ÁÇπÂáªÊü•ÁúãËØ¶ÊÉÖÂíåÊà™Âõæ ‚Üí</div>
                                        </div>
                                    </div>
                                    <!-- Êó∂Èó¥Êà≥ÂíåtokenÊòæÁ§∫ -->
                                    <div class="chat-meta" v-if="msg.timestamp">
                                        <button v-if="msg.role === 'user' && !chatRunning" class="retry-icon-btn"
                                            @click.stop="retryMessage(msg.content)" title="ÈáçÊñ∞ÂèëÈÄÅ" style="background: none; border: none; cursor: pointer; font-size: 12px; margin-right: 6px; 
                                                   opacity: 0.6; transition: opacity 0.2s; padding: 0;"
                                            @mouseenter="$event.target.style.opacity='1'"
                                            @mouseleave="$event.target.style.opacity='0.6'">
                                            üîÑ
                                        </button>
                                        <span>{{ formatMsgTime(msg.timestamp) }}</span>
                                        <span v-if="msg.tokens" style="margin-left: 8px;">{{ msg.tokens }} tokens</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Input Area -->
                        <div class="chat-input-container">
                            <textarea v-model="chatInput" class="chat-input" placeholder="ËæìÂÖ•‰ªªÂä°Êåá‰ª§..." rows="1"
                                @keydown.enter.exact.prevent="sendChatMessage" @input="adjustChatInputHeight"
                                :disabled="chatRunning"></textarea>
                            <button v-if="chatRunning" class="chat-stop-btn" @click="stopChatTask" title="ÂÅúÊ≠¢‰ªªÂä°">
                                ‚èπ
                            </button>
                            <button v-else class="chat-send-btn" @click="sendChatMessage"
                                :disabled="!chatInput.trim() || !chatDeviceId">
                                ‚û§
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Devices Page -->
                <div v-if="currentPage === 'devices'" class="fade-in">
                    <!-- Wireless Pairing Card -->
                    <div class="card" style="margin-bottom: 16px;">
                        <div class="card-header">
                            <h2 class="card-title">üì∂ Êó†Á∫øËøûÊé•</h2>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <!-- Wireless Pairing -->
                            <div style="padding: 12px; background: var(--bg-tertiary); border-radius: 8px;">
                                <h4 style="margin-bottom: 12px; font-size: 14px;">Êó†Á∫øÈÖçÂØπ (È¶ñÊ¨°ËøûÊé•)</h4>
                                <div class="form-group" style="margin-bottom: 8px;">
                                    <input type="text" v-model="pairAddress" class="form-input"
                                        placeholder="ÈÖçÂØπÂú∞ÂùÄ (Â¶Ç: 192.168.1.100:37000)">
                                </div>
                                <div class="form-group" style="margin-bottom: 8px;">
                                    <input type="text" v-model="pairCode" class="form-input" placeholder="6‰ΩçÈÖçÂØπÁ†Å"
                                        maxlength="6">
                                </div>
                                <button class="btn btn-primary" @click="wirelessPair" :disabled="pairingLoading">
                                    {{ pairingLoading ? 'ÈÖçÂØπ‰∏≠...' : 'üîó ÈÖçÂØπ' }}
                                </button>
                            </div>
                            <!-- TCP Connect -->
                            <div style="padding: 12px; background: var(--bg-tertiary); border-radius: 8px;">
                                <h4 style="margin-bottom: 12px; font-size: 14px;">TCP ËøûÊé• (Â∑≤ÈÖçÂØπËÆæÂ§á)</h4>
                                <div class="form-group" style="margin-bottom: 8px;">
                                    <input type="text" v-model="connectAddress" class="form-input"
                                        placeholder="ËøûÊé•Âú∞ÂùÄ (Â¶Ç: 192.168.1.100:5555)">
                                </div>
                                <button class="btn btn-success" @click="tcpConnect" :disabled="connectingLoading">
                                    {{ connectingLoading ? 'ËøûÊé•‰∏≠...' : 'üì± ËøûÊé•' }}
                                </button>
                            </div>
                        </div>
                        <!-- Connection Logs -->
                        <div v-if="deviceLogs.length > 0" style="margin-top: 12px;">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">ËøûÊé•Êó•Âøó:</div>
                            <div
                                style="background: #18181b; color: var(--text-muted); padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 11px; max-height: 100px; overflow-y: auto;">
                                <div v-for="(log, i) in deviceLogs" :key="i">{{ log }}</div>
                            </div>
                        </div>
                    </div>

                    <!-- Devices List Card -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Â∑≤ËøûÊé•ËÆæÂ§á</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-primary" @click="refreshDevices" :disabled="loading">
                                    <span v-if="loading" class="loading-spinner"></span>
                                    <span v-else>üîÑ</span>
                                    Âà∑Êñ∞
                                </button>
                            </div>
                        </div>

                        <!-- APK Install Section -->
                        <div v-if="devices.length > 0"
                            style="margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border-color);">
                            <h4 style="margin-bottom: 12px; font-size: 14px;">üì¶ APK ÂÆâË£Ö</h4>
                            <div style="display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap;">
                                <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 200px;">
                                    <label class="form-label" style="font-size: 12px;">ÈÄâÊã©ËÆæÂ§á</label>
                                    <select v-model="apkTargetDevice" class="form-select">
                                        <option value="">ËØ∑ÈÄâÊã©ËÆæÂ§á</option>
                                        <option v-for="d in devices" :key="d.id" :value="d.id">
                                            {{ d.name || d.id.substring(0, 20) }}
                                        </option>
                                    </select>
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" style="font-size: 12px;">APK Êñá‰ª∂</label>
                                    <input type="file" ref="apkFileInput" accept=".apk" @change="onApkFileSelect"
                                        style="font-size: 12px;">
                                </div>
                                <button class="btn btn-success" @click="installApk"
                                    :disabled="apkInstalling || !apkTargetDevice || !apkFile">
                                    {{ apkInstalling ? 'ÂÆâË£Ö‰∏≠...' : 'üì≤ ÂÆâË£Ö' }}
                                </button>
                            </div>
                            <div v-if="apkFile" style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);">
                                Â∑≤ÈÄâÊã©: {{ apkFile.name }} ({{ (apkFile.size / 1024 / 1024).toFixed(2) }} MB)
                            </div>
                            <!-- APK Install Logs -->
                            <div v-if="apkLogs.length > 0" style="margin-top: 12px;">
                                <div
                                    style="background: #18181b; color: var(--text-muted); padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 11px; max-height: 100px; overflow-y: auto;">
                                    <div v-for="(log, i) in apkLogs" :key="i">{{ log }}</div>
                                </div>
                            </div>
                        </div>

                        <div v-if="loading && devices.length === 0" class="empty-state" style="padding: 40px;">
                            <div class="loading-spinner" style="width: 40px; height: 40px;"></div>
                            <p style="margin-top: 16px;">Âä†ËΩΩËÆæÂ§á‰∏≠...</p>
                        </div>

                        <div v-else-if="devices.length === 0" class="empty-state">
                            <div style="font-size: 3rem; margin-bottom: 16px;">üì±</div>
                            <h3>Êú™ÂèëÁé∞ËÆæÂ§á</h3>
                            <p>ÈÄöËøáUSBËøûÊé•ËÆæÂ§áÊàñ‰ΩøÁî®‰∏äÊñπÊó†Á∫øÈÖçÂØπÔºåÁÑ∂ÂêéÁÇπÂáªÂà∑Êñ∞</p>
                        </div>

                        <div v-else class="device-grid">
                            <div v-for="device in devices" :key="device.id" class="device-card"
                                :class="{ selected: selectedDevices.includes(device.id) }"
                                @click="toggleDeviceSelection(device.id)">
                                <div class="device-header">
                                    <div class="device-icon">üì±</div>
                                    <div>
                                        <div class="device-name">{{ device.name || device.id }}</div>
                                        <div class="device-id">{{ device.id.substring(0, 30) }}...</div>
                                    </div>
                                </div>
                                <div>
                                    <span class="device-status" :class="'status-' + device.status">
                                        {{ device.status }}
                                    </span>
                                    <span v-if="device.model"
                                        style="margin-left: 8px; font-size: 0.75rem; color: var(--text-secondary);">
                                        {{ device.model }}
                                    </span>
                                </div>
                                <div
                                    style="margin-top: 12px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                                    <button class="btn btn-sm btn-secondary" @click.stop="unlockDevice(device.id)">
                                        üîì Ëß£ÈîÅ
                                    </button>
                                    <button v-if="device.id.includes(':')" class="btn btn-sm btn-danger"
                                        @click.stop="disconnectDevice(device.id)" title="Êñ≠ÂºÄÊó†Á∫øËøûÊé•">
                                        ‚ùå Êñ≠ÂºÄ
                                    </button>
                                    <div style="position: relative; display: flex; align-items: center;">
                                        <input :type="showPinFor === device.id ? 'text' : 'password'" class="form-input"
                                            style="width: 100px; height: 28px; font-size: 12px; padding: 4px 28px 4px 8px;"
                                            :placeholder="devicePins[device.id] ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : 'PIN'" @click.stop
                                            :value="pinInputValues[device.id] || ''"
                                            @input="updateDevicePin(device.id, $event.target.value)"
                                            @blur="saveDevicePin(device.id, $event.target.value)">
                                        <button v-if="devicePins[device.id] || pinInputValues[device.id]"
                                            style="position: absolute; right: 4px; background: none; border: none; cursor: pointer; font-size: 14px; padding: 2px;"
                                            @click.stop="toggleShowPin(device.id)"
                                            :title="showPinFor === device.id ? 'ÈöêËóèPIN' : 'ÊòæÁ§∫PIN'">
                                            {{ showPinFor === device.id ? 'üôà' : 'üëÅÔ∏è' }}
                                        </button>
                                    </div>
                                    <span v-if="devicePins[device.id]" style="color: #22c55e; font-size: 12px;">‚úì</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tasks Page -->
                <div v-if="currentPage === 'tasks'" class="fade-in">
                    <!-- Select Devices -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ÈÄâÊã©ËÆæÂ§á ({{ selectedDevices.length }}/{{ devices.length }})</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-secondary btn-sm" @click="selectAllDevices">
                                    {{ selectedDevices.length === devices.length ? 'ÂèñÊ∂àÂÖ®ÈÄâ' : 'ÂÖ®ÈÄâ' }}
                                </button>
                                <button class="btn btn-secondary btn-sm" @click="refreshDevices" :disabled="loading">
                                    üîÑ Âà∑Êñ∞
                                </button>
                            </div>
                        </div>
                        <div v-if="devices.length === 0" class="empty-state" style="padding: 20px;">
                            <p>ÊöÇÊó†Â∑≤ËøûÊé•ËÆæÂ§áÔºåËØ∑ÂÖàËøûÊé•ËÆæÂ§á</p>
                        </div>
                        <div v-else style="display: flex; flex-wrap: wrap; gap: 12px; padding: 8px 0;">
                            <label v-for="device in devices" :key="device.id" class="device-select-item"
                                :class="{ selected: selectedDevices.includes(device.id) }" style="display: flex; align-items: center; gap: 8px; padding: 10px 14px; 
                                       background: var(--bg-secondary); border-radius: 8px; cursor: pointer;
                                       border: 2px solid transparent; transition: all 0.2s;"
                                :style="{ borderColor: selectedDevices.includes(device.id) ? 'var(--primary)' : 'transparent' }">
                                <input type="checkbox" :value="device.id" v-model="selectedDevices"
                                    style="width: 18px; height: 18px; cursor: pointer;">
                                <div>
                                    <div style="font-weight: 500;">{{ device.name || device.id.substring(0, 20) }}</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">
                                        {{ device.status === 'connected' ? 'üü¢ Âú®Á∫ø' : 'üî¥ Á¶ªÁ∫ø' }}
                                    </div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Task Input -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">‰ªªÂä°</h2>
                        </div>
                        <div class="form-group">
                            <textarea v-model="taskContent" class="form-textarea"
                                placeholder="Enter task instructions... (e.g., Open WeChat and send a message to...)"
                                rows="4" :disabled="taskRunning"></textarea>
                        </div>
                        <div style="display: flex; gap: 12px;">
                            <button class="btn btn-primary" @click="runTask"
                                :disabled="taskRunning || selectedDevices.length === 0">
                                ‚ñ∂Ô∏è ÊâßË°å‰ªªÂä°
                            </button>
                            <button class="btn btn-danger" @click="stopTask" :disabled="!taskRunning">
                                ‚èπÔ∏è ÂÅúÊ≠¢
                            </button>
                        </div>

                        <!-- Progress -->
                        <div v-if="taskRunning" style="margin-top: 16px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span>Progress</span>
                                <span>{{ taskProgress }}%</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" :style="{ width: taskProgress + '%' }"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Logs -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ÊâßË°åÊó•Âøó</h2>
                            <button class="btn btn-secondary btn-sm" @click="taskLogs = []">
                                Ê∏ÖÁ©∫
                            </button>
                        </div>
                        <div class="log-output" ref="logContainer">
                            <div v-if="taskLogs.length === 0" style="color: var(--text-secondary);">
                                Logs will appear here...
                            </div>
                            <div v-for="(log, index) in taskLogs" :key="index">
                                <span style="color: #888;">[{{ log.time }}]</span> {{ log.message }}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Scheduler Page -->
                <div v-if="currentPage === 'scheduler'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ÂÆöÊó∂‰ªªÂä°ÂàóË°®</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-primary" @click="showCreateScheduledTask">
                                    ‚ûï Êñ∞Âª∫‰ªªÂä°
                                </button>
                                <button class="btn btn-secondary" @click="loadScheduledTasks">
                                    üîÑ Âà∑Êñ∞
                                </button>
                            </div>
                        </div>

                        <div v-if="scheduledTasks.length === 0 && !showSchedulerForm" class="empty-state">
                            <div style="font-size: 3rem; margin-bottom: 16px;">‚è∞</div>
                            <h3>ÊöÇÊó†ÂÆöÊó∂‰ªªÂä°</h3>
                            <p>ÁÇπÂáª"Êñ∞Âª∫‰ªªÂä°"ÂàõÂª∫ÂÆöÊó∂‰ªªÂä°</p>
                        </div>

                        <div v-else-if="!showSchedulerForm" class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Schedule</th>
                                        <th>Next Run</th>
                                        <th>Status</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="task in scheduledTasks" :key="task.id">
                                        <td>
                                            <strong>{{ task.name }}</strong>
                                            <div style="font-size: 0.75rem; color: var(--text-secondary);">
                                                {{ task.task_content.substring(0, 50) }}...
                                            </div>
                                        </td>
                                        <td>{{ formatScheduleType(task) }}</td>
                                        <td>{{ task.next_run ? new Date(task.next_run).toLocaleString() : '-' }}</td>
                                        <td>
                                            <span class="badge"
                                                :class="task.enabled ? 'badge-success' : 'badge-warning'">
                                                {{ task.enabled ? 'Enabled' : 'Disabled' }}
                                            </span>
                                        </td>
                                        <td>
                                            <button class="btn btn-sm btn-secondary" @click="editScheduledTask(task)">
                                                ‚úèÔ∏è Edit
                                            </button>
                                            <button class="btn btn-sm btn-secondary"
                                                @click="toggleScheduledTask(task.id, !task.enabled)"
                                                style="margin-left: 4px;">
                                                {{ task.enabled ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è' }}
                                            </button>
                                            <button class="btn btn-sm btn-primary" @click="runScheduledTaskNow(task.id)"
                                                style="margin-left: 4px;">
                                                ‚ö° Run
                                            </button>
                                            <button class="btn btn-sm btn-danger" @click="deleteScheduledTask(task.id)"
                                                style="margin-left: 4px;">
                                                üóëÔ∏è
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Scheduler Form -->
                        <div v-if="showSchedulerForm" style="padding: 16px;">
                            <h3 style="margin-bottom: 16px;">{{ schedulerFormMode === 'create' ? 'ÂàõÂª∫ÂÆöÊó∂‰ªªÂä°' :
                                'ÁºñËæë‰ªªÂä°' }}</h3>

                            <div class="form-group">
                                <label class="form-label">‰ªªÂä°ÂêçÁß∞</label>
                                <input type="text" v-model="schedulerForm.name" class="form-input" placeholder="ÊàëÁöÑÂÆöÊó∂‰ªªÂä°">
                            </div>

                            <div class="form-group">
                                <label class="form-label">‰ªªÂä°ÂÜÖÂÆπ</label>
                                <textarea v-model="schedulerForm.task_content" class="form-textarea" rows="3"
                                    placeholder="ËæìÂÖ•‰ªªÂä°Êåá‰ª§..."></textarea>
                            </div>

                            <div class="form-group">
                                <label class="form-label">‰ªªÂä°Á±ªÂûã</label>
                                <select v-model="schedulerForm.schedule_type" class="form-select">
                                    <option value="once">ÂçïÊ¨°</option>
                                    <option value="interval">Èó¥Èöî</option>
                                    <option value="daily">ÊØèÂ§©</option>
                                    <option value="weekly">ÊØèÂë®</option>
                                    <option value="monthly">ÊØèÊúà</option>
                                </select>
                            </div>

                            <!-- Once -->
                            <div v-if="schedulerForm.schedule_type === 'once'" class="form-group">
                                <label class="form-label">ÊâßË°åÊó∂Èó¥</label>
                                <input type="datetime-local" v-model="schedulerForm.run_at" class="form-input">
                            </div>

                            <!-- Interval -->
                            <div v-if="schedulerForm.schedule_type === 'interval'" class="form-group">
                                <label class="form-label">Èó¥ÈöîÊó∂Èó¥ÔºàÂàÜÈíüÔºâ</label>
                                <input type="number" v-model.number="schedulerForm.interval_minutes" class="form-input"
                                    min="1">
                            </div>

                            <!-- Daily -->
                            <div v-if="schedulerForm.schedule_type === 'daily'" class="form-group">
                                <label class="form-label">ÊØèÂ§©Êó∂Èó¥</label>
                                <input type="time" v-model="schedulerForm.daily_time" class="form-input">
                            </div>

                            <!-- Weekly -->
                            <div v-if="schedulerForm.schedule_type === 'weekly'">
                                <div class="form-group">
                                    <label class="form-label">ÊØèÂë®Âì™Âá†Â§©</label>
                                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                        <label v-for="(day, index) in ['Êó•', '‰∏Ä', '‰∫å', '‰∏â', 'Âõõ', '‰∫î', 'ÂÖ≠']" :key="index"
                                            style="display: flex; align-items: center; gap: 4px;">
                                            <input type="checkbox" :value="index" v-model="schedulerForm.weekly_days">
                                            {{ day }}
                                        </label>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Êó∂Èó¥</label>
                                    <input type="time" v-model="schedulerForm.weekly_time" class="form-input">
                                </div>
                            </div>

                            <!-- Monthly -->
                            <div v-if="schedulerForm.schedule_type === 'monthly'">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                                    <div class="form-group">
                                        <label class="form-label">ÊØèÊúàÁ¨¨Âá†Â§©</label>
                                        <input type="number" v-model.number="schedulerForm.monthly_day"
                                            class="form-input" min="1" max="31">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Êó∂Èó¥</label>
                                        <input type="time" v-model="schedulerForm.monthly_time" class="form-input">
                                    </div>
                                </div>
                            </div>

                            <!-- Target Devices -->
                            <div class="form-group">
                                <label class="form-label">ÁõÆÊ†áËÆæÂ§áÔºàÁïôÁ©∫Ë°®Á§∫ÊâÄÊúâËÆæÂ§áÔºâ</label>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <label v-for="device in devices" :key="device.id"
                                        style="display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: var(--bg-tertiary); border-radius: 4px;">
                                        <input type="checkbox" :value="device.id" v-model="schedulerForm.devices">
                                        {{ device.name || device.id.substring(0, 15) }}
                                    </label>
                                </div>
                            </div>

                            <div class="form-group">
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" v-model="schedulerForm.enabled">
                                    Á´ãÂç≥ÂêØÁî®‰ªªÂä°
                                </label>
                            </div>

                            <div style="display: flex; gap: 12px; margin-top: 16px;">
                                <button class="btn btn-primary" @click="saveScheduledTask" :disabled="loading">
                                    {{ schedulerFormMode === 'create' ? '‚úÖ ÂàõÂª∫' : 'üíæ ‰øùÂ≠ò' }}
                                </button>
                                <button class="btn btn-secondary" @click="cancelSchedulerForm">
                                    ÂèñÊ∂à
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Scheduler Logs Card -->
                    <div class="card" style="margin-top: 16px;">
                        <div class="card-header">
                            <h2 class="card-title">üìã ÊâßË°åÊó•Âøó</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-secondary btn-sm" @click="clearAllSchedulerLogs">
                                    üóëÔ∏è Ê∏ÖÁ©∫ÊâÄÊúâ
                                </button>
                                <button class="btn btn-secondary btn-sm" @click="loadSchedulerLogs">
                                    üîÑ Âà∑Êñ∞Êó•Âøó
                                </button>
                            </div>
                        </div>

                        <div v-if="schedulerLogs.length === 0" class="empty-state" style="padding: 30px;">
                            <div style="font-size: 2rem; margin-bottom: 12px;">üìù</div>
                            <p>ÊöÇÊó†ÊâßË°åÊó•Âøó</p>
                        </div>

                        <div v-else class="table-container" style="max-height: 300px; overflow-y: auto;">
                            <table>
                                <thead>
                                    <tr>
                                        <th style="width: 60px;">Áä∂ÊÄÅ</th>
                                        <th>‰ªªÂä°ÂêçÁß∞</th>
                                        <th>ÊâßË°åÊó∂Èó¥</th>
                                        <th>ÁªìÊûú</th>
                                        <th style="width: 80px;">ËØ¶ÊÉÖ</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="(log, i) in schedulerLogs" :key="i">
                                        <td style="text-align: center;">
                                            <span v-if="log.success" style="color: #22c55e;">‚úÖ</span>
                                            <span v-else style="color: #ef4444;">‚ùå</span>
                                        </td>
                                        <td>{{ log.task_name }}</td>
                                        <td style="font-size: 12px;">{{ formatLogTime(log.timestamp) }}</td>
                                        <td>{{ log.message }}</td>
                                        <td>
                                            <button v-if="log.details" class="btn btn-sm btn-secondary"
                                                @click="showLogDetails(log)">
                                                üëÅÔ∏è
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Log Details Modal -->
                    <div v-if="showLogDetailModal" class="modal-overlay" @click.self="showLogDetailModal = false">
                        <div class="modal-content" style="max-width: 700px;">
                            <div class="modal-header">
                                <h3>üìã ÊâßË°åÊó•ÂøóËØ¶ÊÉÖ</h3>
                                <button class="btn btn-sm" @click="showLogDetailModal = false">‚úï</button>
                            </div>
                            <div class="modal-body">
                                <div style="margin-bottom: 12px;">
                                    <strong>‰ªªÂä°:</strong> {{ logDetailData.task_name }}<br>
                                    <strong>Êó∂Èó¥:</strong> {{ formatLogTime(logDetailData.timestamp) }}<br>
                                    <strong>Áä∂ÊÄÅ:</strong>
                                    <span :style="{ color: logDetailData.success ? '#22c55e' : '#ef4444' }">
                                        {{ logDetailData.success ? 'ÊàêÂäü' : 'Â§±Ë¥•' }}
                                    </span>
                                </div>
                                <div
                                    style="background: #18181b; color: var(--text-muted); padding: 12px; border-radius: 8px; font-family: monospace; font-size: 11px; max-height: 400px; overflow-y: auto; white-space: pre-wrap;">
                                    {{ logDetailData.details || 'Êó†ËØ¶ÁªÜÊó•Âøó' }}</div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" @click="showLogDetailModal = false">ÂÖ≥Èó≠</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Models Page -->
                <div v-if="currentPage === 'models'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Ê®°ÂûãÊúçÂä°ÁÆ°ÁêÜ</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-success" @click="openModelForm('create')">
                                    ‚ûï Êñ∞Â¢ûÊ®°Âûã
                                </button>
                                <button class="btn btn-primary" @click="loadModels">
                                    üîÑ Âà∑Êñ∞
                                </button>
                            </div>
                        </div>

                        <div v-if="activeModel"
                            style="margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--accent-primary);">
                            <strong>ÂΩìÂâçÊøÄÊ¥ª:</strong> {{ activeModel.name }} ({{ activeModel.model_name }})
                        </div>

                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>ÂêçÁß∞</th>
                                        <th>ÂçèËÆÆ</th>
                                        <th>Ê®°Âûã</th>
                                        <th>Base URL</th>
                                        <th>Áä∂ÊÄÅ</th>
                                        <th>Êìç‰Ωú</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="service in modelServices" :key="service.id">
                                        <td>
                                            <strong>{{ service.name }}</strong>
                                            <div style="font-size: 0.75rem; color: var(--text-secondary);">
                                                {{ service.description }}
                                            </div>
                                        </td>
                                        <td>
                                            <span class="badge" :style="{
                                                background: service.protocol === 'openai' ? '#10a37f' :
                                                           service.protocol === 'anthropic' ? '#d97706' :
                                                           service.protocol === 'gemini' ? '#4285f4' : '#666',
                                                color: 'white'
                                            }">
                                                {{ service.protocol === 'openai' ? 'OpenAI' :
                                                service.protocol === 'anthropic' ? 'Anthropic' :
                                                service.protocol === 'gemini' ? 'Gemini' : 'Unknown' }}
                                            </span>
                                        </td>
                                        <td>{{ service.model_name }}</td>
                                        <td
                                            style="font-size: 0.75rem; max-width: 200px; overflow: hidden; text-overflow: ellipsis;">
                                            {{ service.base_url }}</td>
                                        <td>
                                            <span class="badge"
                                                :class="service.is_active ? 'badge-success' : 'badge-info'">
                                                {{ service.is_active ? 'Â∑≤ÊøÄÊ¥ª' : 'Êú™ÊøÄÊ¥ª' }}
                                            </span>
                                        </td>
                                        <td>
                                            <button class="btn btn-sm btn-primary" @click="activateModel(service.id)"
                                                :disabled="service.is_active" title="ÊøÄÊ¥ªÊ≠§Ê®°Âûã">
                                                ÊøÄÊ¥ª
                                            </button>
                                            <button class="btn btn-sm btn-secondary" @click="testModel(service.id)"
                                                :disabled="loading" style="margin-left: 4px;" title="ÊµãËØïËøûÊé•">
                                                ÊµãËØï
                                            </button>
                                            <button class="btn btn-sm btn-secondary"
                                                @click="openModelForm('edit', service)" style="margin-left: 4px;"
                                                title="ÁºñËæë">
                                                ‚úèÔ∏è
                                            </button>
                                            <button class="btn btn-sm btn-danger"
                                                @click="deleteModel(service.id, service.name)"
                                                :disabled="service.is_active" style="margin-left: 4px;" title="Âà†Èô§">
                                                üóëÔ∏è
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- È¢ÑËÆæÊ®°Êùø - ÊåâÂçèËÆÆÂàÜÁ±ª -->
                        <div style="margin-top: 20px;">
                            <h3 style="font-size: 1rem; margin-bottom: 12px;">üöÄ Âø´ÈÄüÊ∑ªÂä†È¢ÑËÆæÊ®°Êùø</h3>

                            <!-- OpenAI ÂçèËÆÆ -->
                            <div v-if="getPresetsByCategory('OpenAI ÂçèËÆÆ').length > 0" style="margin-bottom: 16px;">
                                <div
                                    style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                    <span
                                        style="background: #10a37f; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem;">OpenAI</span>
                                    <span>ÂÖºÂÆπÂçèËÆÆ (/v1/chat/completions)</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <button v-for="preset in getPresetsByCategory('OpenAI ÂçèËÆÆ')" :key="preset.id"
                                        class="btn btn-sm btn-secondary" @click="addFromPreset(preset)"
                                        :title="preset.description">
                                        {{ preset.name }}
                                    </button>
                                </div>
                            </div>

                            <!-- Anthropic ÂçèËÆÆ -->
                            <div v-if="getPresetsByCategory('Anthropic ÂçèËÆÆ').length > 0" style="margin-bottom: 16px;">
                                <div
                                    style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                    <span
                                        style="background: #d97706; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem;">Anthropic</span>
                                    <span>ÂçèËÆÆ (/v1/messages)</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <button v-for="preset in getPresetsByCategory('Anthropic ÂçèËÆÆ')" :key="preset.id"
                                        class="btn btn-sm btn-secondary" @click="addFromPreset(preset)"
                                        :title="preset.description" style="border-color: #d97706;">
                                        {{ preset.name }}
                                    </button>
                                </div>
                            </div>

                            <!-- Gemini ÂçèËÆÆ -->
                            <div v-if="getPresetsByCategory('Gemini ÂçèËÆÆ').length > 0" style="margin-bottom: 16px;">
                                <div
                                    style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                    <span
                                        style="background: #4285f4; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem;">Gemini</span>
                                    <span>ÂçèËÆÆ (Google AI)</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <button v-for="preset in getPresetsByCategory('Gemini ÂçèËÆÆ')" :key="preset.id"
                                        class="btn btn-sm btn-secondary" @click="addFromPreset(preset)"
                                        :title="preset.description" style="border-color: #4285f4;">
                                        {{ preset.name }}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Ê®°ÂûãÁºñËæëÂºπÁ™ó -->
                    <div v-if="showModelForm" class="modal-overlay" @click.self="showModelForm = false">
                        <div class="modal-content" style="max-width: 500px;">
                            <div class="modal-header">
                                <h3>{{ modelFormMode === 'create' ? 'Êñ∞Â¢ûÊ®°ÂûãÊúçÂä°' : 'ÁºñËæëÊ®°ÂûãÊúçÂä°' }}</h3>
                                <button class="btn btn-sm" @click="showModelForm = false">‚úï</button>
                            </div>
                            <div class="modal-body">
                                <div class="form-group">
                                    <label class="form-label">ÊúçÂä°ÂêçÁß∞ *</label>
                                    <input type="text" v-model="modelForm.name" class="form-input"
                                        placeholder="‰æãÂ¶Ç: OpenAI GPT-4">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">ÂçèËÆÆÁ±ªÂûã *</label>
                                    <select v-model="modelForm.protocol" class="form-select">
                                        <option value="openai">OpenAI ÂçèËÆÆ (/v1/chat/completions)</option>
                                        <option value="anthropic">Anthropic ÂçèËÆÆ (/v1/messages)</option>
                                        <option value="gemini">Gemini ÂçèËÆÆ (Google AI)</option>
                                    </select>
                                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px;">
                                        <span v-if="modelForm.protocol === 'openai'">ÈÄÇÁî®‰∫éÂ§ßÂ§öÊï∞ÂÖºÂÆπOpenAI APIÁöÑÊúçÂä°</span>
                                        <span v-else-if="modelForm.protocol === 'anthropic'">ÈÄÇÁî®‰∫éAnthropic Claude
                                            API</span>
                                        <span v-else-if="modelForm.protocol === 'gemini'">ÈÄÇÁî®‰∫éGoogle Gemini API</span>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Base URL *</label>
                                    <input type="text" v-model="modelForm.base_url" class="form-input"
                                        :placeholder="modelForm.protocol === 'openai' ? 'https://api.openai.com/v1' : modelForm.protocol === 'anthropic' ? 'https://api.anthropic.com/v1/messages' : 'https://generativelanguage.googleapis.com/v1beta'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Ê®°ÂûãÂêçÁß∞ *</label>
                                    <input type="text" v-model="modelForm.model_name" class="form-input"
                                        :placeholder="modelForm.protocol === 'openai' ? 'gpt-4o' : modelForm.protocol === 'anthropic' ? 'claude-sonnet-4-20250514' : 'gemini-2.0-flash'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">API Key</label>
                                    <input type="password" v-model="modelForm.api_key" class="form-input"
                                        placeholder="sk-...">
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                    <div class="form-group">
                                        <label class="form-label">Max Tokens</label>
                                        <input type="number" v-model="modelForm.max_tokens" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Temperature</label>
                                        <input type="number" step="0.1" v-model="modelForm.temperature"
                                            class="form-input">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">ÊèèËø∞</label>
                                    <input type="text" v-model="modelForm.description" class="form-input"
                                        placeholder="ÂèØÈÄâÊèèËø∞">
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" @click="showModelForm = false">ÂèñÊ∂à</button>
                                <button class="btn btn-primary" @click="testModelConfig" :disabled="loading">
                                    {{ loading ? 'ÊµãËØï‰∏≠...' : 'ÊµãËØïËøûÊé•' }}
                                </button>
                                <button class="btn btn-success" @click="saveModel" :disabled="loading">
                                    {{ modelFormMode === 'create' ? 'ÂàõÂª∫' : '‰øùÂ≠ò' }}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Files Page -->
                <div v-if="currentPage === 'files'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üìÅ Êñá‰ª∂ÁÆ°ÁêÜ</h2>
                        </div>

                        <!-- Device and Path Selection -->
                        <div
                            style="display: flex; gap: 12px; margin-bottom: 16px; align-items: flex-end; flex-wrap: wrap;">
                            <div class="form-group" style="margin-bottom: 0; min-width: 200px;">
                                <label class="form-label">ÈÄâÊã©ËÆæÂ§á</label>
                                <select v-model="fileDevice" class="form-select" @change="loadFiles">
                                    <option value="">ËØ∑ÈÄâÊã©ËÆæÂ§á</option>
                                    <option v-for="d in devices" :key="d.id" :value="d.id">
                                        {{ d.name || d.id.substring(0, 20) }}
                                    </option>
                                </select>
                            </div>
                            <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 250px;">
                                <label class="form-label">ÂΩìÂâçË∑ØÂæÑ</label>
                                <div style="display: flex; gap: 8px;">
                                    <input type="text" v-model="filePath" class="form-input" placeholder="/sdcard"
                                        @keyup.enter="loadFiles">
                                    <button class="btn btn-primary" @click="loadFiles"
                                        :disabled="!fileDevice || fileLoading">
                                        {{ fileLoading ? '*' : 'GO' }}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Quick Navigation -->
                        <div style="margin-bottom: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard')">üì± SDÂç°</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/DCIM')">üì∑ Áõ∏ÂÜå</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/Download')">üì•
                                ‰∏ãËΩΩ</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/Pictures')">üñºÔ∏è
                                ÂõæÁâá</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/Documents')">üìÑ
                                ÊñáÊ°£</button>
                            <button class="btn btn-sm btn-secondary" @click="goUp" :disabled="filePath === '/'">‚¨ÜÔ∏è
                                ‰∏äÁ∫ß</button>
                        </div>

                        <!-- Upload Section -->
                        <div
                            style="margin-bottom: 16px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; border: 1px solid var(--border-color);">
                            <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                                <span style="font-size: 14px;">üì§ ‰∏ä‰º†Êñá‰ª∂Âà∞ÂΩìÂâçÁõÆÂΩï:</span>
                                <input type="file" ref="uploadFileInput" @change="onUploadFileSelect"
                                    style="font-size: 12px;">
                                <button class="btn btn-sm btn-success" @click="uploadFile"
                                    :disabled="!uploadSelectedFile || !fileDevice || fileUploading">
                                    {{ fileUploading ? '‰∏ä‰º†‰∏≠...' : '‰∏ä‰º†' }}
                                </button>
                            </div>
                        </div>

                        <!-- File List -->
                        <div v-if="!fileDevice" class="empty-state" style="padding: 40px;">
                            <div style="font-size: 3rem;">üìÅ</div>
                            <p>ËØ∑ÂÖàÈÄâÊã©ËÆæÂ§á</p>
                        </div>

                        <div v-else-if="fileLoading" class="empty-state" style="padding: 40px;">
                            <div class="loading-spinner" style="width: 40px; height: 40px;"></div>
                            <p style="margin-top: 16px;">Âä†ËΩΩ‰∏≠...</p>
                        </div>

                        <div v-else-if="fileList.length === 0" class="empty-state" style="padding: 40px;">
                            <div style="font-size: 3rem;">üìÇ</div>
                            <p>ÁõÆÂΩï‰∏∫Á©∫</p>
                        </div>

                        <div v-else class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th style="width: 40px;"></th>
                                        <th>ÂêçÁß∞</th>
                                        <th style="width: 100px;">Â§ßÂ∞è</th>
                                        <th style="width: 120px;">Êìç‰Ωú</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="file in fileList" :key="file.name"
                                        :style="{ cursor: file.is_dir ? 'pointer' : 'default' }"
                                        @dblclick="file.is_dir && navigateTo(filePath + '/' + file.name)">
                                        <td style="text-align: center;">
                                            <span v-if="file.is_dir">üìÅ</span>
                                            <span v-else-if="file.is_link">üîó</span>
                                            <span v-else-if="isImageFile(file.name)">üñºÔ∏è</span>
                                            <span v-else-if="isVideoFile(file.name)">üé¨</span>
                                            <span v-else-if="isAudioFile(file.name)">üéµ</span>
                                            <span v-else>üìÑ</span>
                                        </td>
                                        <td>
                                            <span @click="file.is_dir && navigateTo(filePath + '/' + file.name)"
                                                :style="{ color: file.is_dir ? '#3b82f6' : 'inherit', cursor: file.is_dir ? 'pointer' : 'default' }">
                                                {{ file.name }}
                                            </span>
                                        </td>
                                        <td style="font-size: 12px; color: var(--text-secondary);">
                                            {{ file.is_dir ? '-' : formatFileSize(file.size) }}
                                        </td>
                                        <td>
                                            <button v-if="!file.is_dir" class="btn btn-sm btn-secondary"
                                                @click="downloadFile(file.name)" title="‰∏ãËΩΩ">
                                                ‚¨áÔ∏è
                                            </button>
                                            <button class="btn btn-sm btn-danger"
                                                @click="deleteFileConfirm(file.name, file.is_dir)"
                                                style="margin-left: 4px;" title="Âà†Èô§">
                                                üóëÔ∏è
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Settings Page -->
                <div v-if="currentPage === 'settings'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ÈÇÆ‰ª∂ËÆæÁΩÆ</h2>
                        </div>

                        <div class="form-group">
                            <label class="form-label">SMTP ÊúçÂä°Âô®</label>
                            <input type="text" v-model="emailConfig.smtp_server" class="form-input"
                                placeholder="smtp.example.com">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <div class="form-group">
                                <label class="form-label">Á´ØÂè£</label>
                                <input type="number" v-model="emailConfig.smtp_port" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Âä†ÂØÜ</label>
                                <select v-model="emailConfig.use_ssl" class="form-select">
                                    <option :value="true">SSL</option>
                                    <option :value="false">None/TLS</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">ÂèëÈÄÅÈÇÆÁÆ±</label>
                            <input type="email" v-model="emailConfig.sender_email" class="form-input"
                                placeholder="your@email.com">
                        </div>

                        <div class="form-group">
                            <label class="form-label">ÂØÜÁ†Å / ÊéàÊùÉÁ†Å</label>
                            <input type="password" v-model="emailConfig.sender_password" class="form-input"
                                placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Êî∂‰ª∂‰∫∫ÔºàÈÄóÂè∑ÂàÜÈöîÔºâ</label>
                            <input type="text" v-model="emailConfig.recipient_emails" class="form-input"
                                placeholder="user1@email.com, user2@email.com">
                        </div>

                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" v-model="emailConfig.enabled">
                                ÂêØÁî®Ëá™Âä®ÈÇÆ‰ª∂Êä•Âëä
                            </label>
                        </div>

                        <div style="display: flex; gap: 12px;">
                            <button class="btn btn-primary" @click="saveEmailConfig">
                                ‰øùÂ≠òËÆæÁΩÆ
                            </button>
                            <button class="btn btn-secondary" @click="testEmail" :disabled="loading">
                                ÂèëÈÄÅÊµãËØïÈÇÆ‰ª∂
                            </button>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üì∏ Êà™ÂõæÂéãÁº©ËÆæÁΩÆ</h2>
                        </div>

                        <div class="form-group">
                            <label class="form-label">ÊúÄÂ§ßÂõæÁâáÂ∞∫ÂØ∏</label>
                            <div style="display: flex; align-items: center; gap: 16px;">
                                <input type="range" v-model.number="screenshotConfig.max_dimension" min="480" max="3840"
                                    step="120" style="flex: 1;">
                                <span style="min-width: 100px; font-weight: 500;">{{ screenshotConfig.max_dimension
                                    }}px</span>
                            </div>
                            <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                                Êà™Âõæ‰ºöË¢´ÊåâÊØî‰æãÁº©ÊîæÂà∞Ê≠§Â∞∫ÂØ∏„ÄÇÈªòËÆ§Ôºö1920px
                            </p>
                        </div>

                        <div class="form-group">
                            <label class="form-label">JPEG ÂéãÁº©Ë¥®Èáè</label>
                            <div style="display: flex; align-items: center; gap: 16px;">
                                <input type="range" v-model.number="screenshotConfig.jpeg_quality" min="10" max="100"
                                    step="5" style="flex: 1;">
                                <span style="min-width: 100px; font-weight: 500;">{{ screenshotConfig.jpeg_quality
                                    }}%</span>
                            </div>
                            <p style="font-size: 12px; color: var(--text-secondary); margin-top: 4px;">
                                Ë¥®ÈáèË∂äÈ´òÂõæÁâáË∂äÊ∏ÖÊô∞‰ΩÜÊñá‰ª∂Ë∂äÂ§ß„ÄÇÈªòËÆ§Ôºö70%
                            </p>
                        </div>

                        <div style="display: flex; gap: 12px; margin-top: 24px;">
                            <button class="btn btn-primary" @click="saveScreenshotConfig">
                                ‰øùÂ≠òËÆæÁΩÆ
                            </button>
                            <button class="btn btn-secondary" @click="resetScreenshotConfig">
                                ÊÅ¢Â§çÈªòËÆ§
                            </button>
                        </div>

                        <div
                            style="margin-top: 16px; padding: 12px; background: #f0f9ff; border-radius: 8px; border: 1px solid #bfdbfe;">
                            <p style="font-size: 12px; color: #1e40af; margin: 0;">
                                ‚ÑπÔ∏è ÊèêÁ§∫Ôºö‰øÆÊîπÂéãÁº©ÊØî‰æã<strong>‰∏ç‰ºöÂΩ±ÂìçÁÇπÂáª‰ΩçÁΩÆÂáÜÁ°ÆÊÄß</strong>„ÄÇÂùêÊ†áËΩ¨Êç¢‰ΩøÁî®ËÆæÂ§áÁúüÂÆûÂàÜËæ®Áéá„ÄÇ
                            </p>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ÂÖ≥‰∫é</h2>
                        </div>
                        <p><strong>AutoGLM Web Server</strong> v0.1.0</p>
                        <p style="margin-top: 8px; color: var(--text-secondary);">
                            AI-powered phone automation tool. Web interface for Open-AutoGLM-GUI.
                        </p>
                        <p style="margin-top: 8px;">
                            <a href="/docs" target="_blank">API Documentation</a>
                        </p>
                    </div>
                </div>

                <!-- Rules Page -->
                <div v-if="currentPage === 'rules'" class="fade-in">
                    <!-- App Mappings Card -->
                    <div class="card">
                        <div class="card-header"
                            style="display: flex; justify-content: space-between; align-items: center;">
                            <h2 class="card-title">üì± Â∫îÁî®Êò†Â∞Ñ</h2>
                            <button class="btn btn-sm btn-primary" @click="showAddAppModal = true">+ Ê∑ªÂä†</button>
                        </div>
                        <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                            ÈÖçÁΩÆÂ∫îÁî®ÂêçÁß∞Âà∞ÂåÖÂêçÁöÑÊò†Â∞ÑÔºåÁî®‰∫é Launch Âä®‰Ωú
                        </p>
                        <div v-if="appMappings.length === 0" class="empty-state" style="padding: 20px;">
                            <p>ÊöÇÊó†Â∫îÁî®Êò†Â∞ÑÈÖçÁΩÆ</p>
                        </div>
                        <div v-else style="max-height: 300px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="border-bottom: 1px solid var(--border);">
                                        <th style="text-align: left; padding: 8px; font-weight: 500;">
                                            Â∫îÁî®ÂêçÁß∞</th>
                                        <th style="text-align: left; padding: 8px; font-weight: 500;">ÂåÖÂêç
                                        </th>
                                        <th style="text-align: right; padding: 8px; font-weight: 500; width: 100px;">
                                            Êìç‰Ωú
                                        </th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="app in appMappings" :key="app.app_name"
                                        style="border-bottom: 1px solid var(--border);">
                                        <td style="padding: 8px;">
                                            {{ app.app_name }}
                                            <span v-if="app.is_custom"
                                                style="font-size: 12px; color: var(--primary); margin-left: 4px;">Ëá™ÂÆö‰πâ</span>
                                        </td>
                                        <td
                                            style="padding: 8px; color: var(--text-secondary); font-family: monospace; font-size: 13px;">
                                            {{ app.package_name }}
                                        </td>
                                        <td style="padding: 8px; text-align: right;">
                                            <template v-if="app.is_custom">
                                                <button class="btn btn-sm btn-secondary" @click="editAppMapping(app)"
                                                    style="margin-right: 4px;">ÁºñËæë</button>
                                                <button class="btn btn-sm btn-danger"
                                                    @click="deleteAppMapping(app.app_name)">Âà†Èô§</button>
                                            </template>
                                            <span v-else
                                                style="color: var(--text-secondary); font-size: 12px;">ÂÜÖÁΩÆ</span>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Timing Config Card -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">‚è±Ô∏è Êó∂Èó¥Âª∂ËøüÈÖçÁΩÆ</h2>
                        </div>
                        <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                            ÈÖçÁΩÆÂêÑÁßçÊìç‰ΩúÁöÑÂª∂ËøüÊó∂Èó¥ÔºàÂçï‰ΩçÔºöÁßíÔºâ
                        </p>
                        <div v-if="timingConfig">
                            <!-- Action Timing -->
                            <div style="margin-bottom: 16px;">
                                <h4 style="margin-bottom: 8px; font-size: 14px; color: var(--text-secondary);">
                                    Âä®‰ΩúÂª∂Ëøü</h4>
                                <div
                                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px;">
                                    <div v-for="(value, key) in timingConfig.action" :key="'action-'+key"
                                        class="form-group" style="margin-bottom: 0;">
                                        <label class="form-label" style="font-size: 12px;">{{
                                            formatTimingKey(key)
                                            }}</label>
                                        <input type="number" step="0.1" min="0" :value="value"
                                            @change="updateTiming('action', key, $event.target.value)"
                                            class="form-input" style="font-size: 13px;">
                                    </div>
                                </div>
                            </div>
                            <!-- Device Timing -->
                            <div style="margin-bottom: 16px;">
                                <h4 style="margin-bottom: 8px; font-size: 14px; color: var(--text-secondary);">
                                    ËÆæÂ§áÂª∂Ëøü</h4>
                                <div
                                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px;">
                                    <div v-for="(value, key) in timingConfig.device" :key="'device-'+key"
                                        class="form-group" style="margin-bottom: 0;">
                                        <label class="form-label" style="font-size: 12px;">{{
                                            formatTimingKey(key)
                                            }}</label>
                                        <input type="number" step="0.1" min="0" :value="value"
                                            @change="updateTiming('device', key, $event.target.value)"
                                            class="form-input" style="font-size: 13px;">
                                    </div>
                                </div>
                            </div>
                            <!-- Connection Timing -->
                            <div>
                                <h4 style="margin-bottom: 8px; font-size: 14px; color: var(--text-secondary);">
                                    ËøûÊé•Âª∂Ëøü</h4>
                                <div
                                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px;">
                                    <div v-for="(value, key) in timingConfig.connection" :key="'conn-'+key"
                                        class="form-group" style="margin-bottom: 0;">
                                        <label class="form-label" style="font-size: 12px;">{{
                                            formatTimingKey(key)
                                            }}</label>
                                        <input type="number" step="0.1" min="0" :value="value"
                                            @change="updateTiming('connection', key, $event.target.value)"
                                            class="form-input" style="font-size: 13px;">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Action Rules Card -->
                    <div class="card">
                        <div class="card-header"
                            style="display: flex; justify-content: space-between; align-items: center;">
                            <h2 class="card-title">üéØ Âä®‰ΩúËßÑÂàô</h2>
                            <button class="btn btn-sm btn-secondary" @click="resetActionRules">ÈáçÁΩÆ‰∏∫ÈªòËÆ§</button>
                        </div>
                        <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                            ÈÖçÁΩÆÂêÑÁßçÂä®‰ΩúÁöÑÊâßË°åËßÑÂàôÂíåÊù°‰ª∂
                        </p>
                        <div v-if="actionRules.length === 0" class="empty-state" style="padding: 20px;">
                            <p>Âä†ËΩΩ‰∏≠...</p>
                        </div>
                        <div v-else>
                            <div v-for="action in actionRules" :key="action.name" class="action-rule-item"
                                style="border: 1px solid var(--border); border-radius: 8px; margin-bottom: 12px; overflow: hidden;">
                                <div @click="toggleActionExpand(action.name)"
                                    style="padding: 12px 16px; background: var(--bg-secondary); cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <strong>{{ action.name }}</strong>
                                        <span v-if="action.is_custom"
                                            style="font-size: 12px; color: var(--primary); margin-left: 8px;">Ëá™ÂÆö‰πâ</span>
                                        <p style="font-size: 13px; color: var(--text-secondary); margin: 4px 0 0 0;">
                                            {{ action.description }}</p>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 12px; color: var(--text-secondary);">{{
                                            action.rules ? action.rules.length : 0 }} Êù°ËßÑÂàô</span>
                                        <span style="transition: transform 0.2s;"
                                            :style="{ transform: expandedActions[action.name] ? 'rotate(90deg)' : '' }">‚ñ∂</span>
                                    </div>
                                </div>
                                <div v-if="expandedActions[action.name]"
                                    style="padding: 16px; border-top: 1px solid var(--border);">
                                    <div
                                        style="margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center;">
                                        <span style="font-size: 13px; color: var(--text-secondary);">ËßÑÂàôÂàóË°®</span>
                                        <button class="btn btn-sm btn-primary" @click="showAddRuleModal(action.name)">+
                                            Ê∑ªÂä†ËßÑÂàô</button>
                                    </div>
                                    <div v-if="!action.rules || action.rules.length === 0"
                                        style="padding: 20px; text-align: center; color: var(--text-secondary);">
                                        ÊöÇÊó†ËßÑÂàô
                                    </div>
                                    <div v-else>
                                        <div v-for="rule in action.rules" :key="rule.id"
                                            style="padding: 10px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 8px;">
                                            <div
                                                style="display: flex; justify-content: space-between; align-items: flex-start;">
                                                <div style="flex: 1;">
                                                    <div
                                                        style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                                        <label
                                                            style="display: flex; align-items: center; cursor: pointer;">
                                                            <input type="checkbox" :checked="rule.enabled"
                                                                @change="toggleRuleEnabled(action.name, rule.id)"
                                                                style="margin-right: 6px;">
                                                        </label>
                                                        <strong style="font-size: 13px;"
                                                            :style="{ opacity: rule.enabled ? 1 : 0.5 }">
                                                            {{ rule.condition }}
                                                        </strong>
                                                    </div>
                                                    <p style="font-size: 12px; color: var(--text-secondary); margin: 0;"
                                                        :style="{ opacity: rule.enabled ? 1 : 0.5 }">
                                                        ‚Üí {{ rule.action }}
                                                    </p>
                                                </div>
                                                <div style="display: flex; gap: 4px;">
                                                    <button class="btn btn-sm btn-secondary"
                                                        @click="editRuleItem(action.name, rule)">ÁºñËæë</button>
                                                    <button class="btn btn-sm btn-danger"
                                                        @click="deleteRuleItem(action.name, rule.id)">Âà†Èô§</button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- System Prompts Card -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üìù Á≥ªÁªüÊèêÁ§∫ËØç</h2>
                        </div>
                        <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                            Ëá™ÂÆö‰πâ AI Ê®°ÂûãÁöÑÁ≥ªÁªüÊèêÁ§∫ËØç
                        </p>
                        <div v-if="systemPrompts">
                            <div v-for="(prompt, key) in systemPrompts" :key="key" style="margin-bottom: 16px;">
                                <div
                                    style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <label class="form-label" style="margin-bottom: 0;">
                                        {{ prompt.name }}
                                        <span v-if="prompt.is_customized"
                                            style="font-size: 12px; color: var(--primary); margin-left: 4px;">(Â∑≤Ëá™ÂÆö‰πâ)</span>
                                    </label>
                                    <button v-if="prompt.is_customized" class="btn btn-sm btn-secondary"
                                        @click="resetPrompt(key)">
                                        ÈáçÁΩÆ
                                    </button>
                                </div>
                                <textarea v-model="prompt.content" class="form-input"
                                    style="min-height: 150px; font-family: monospace; font-size: 13px;"
                                    @blur="savePrompt(key, prompt.content)"></textarea>
                            </div>
                        </div>
                    </div>
                </div>

            </main>
        </div>

        <!-- Task Detail Modal -->
        <div v-cloak v-if="showTaskDetail" class="task-detail-modal" @click.self="showTaskDetail = false">
            <div class="task-detail-content">
                <div class="task-detail-header">
                    <h3>üìã ‰ªªÂä°ÊâßË°åËØ¶ÊÉÖ</h3>
                    <button class="task-detail-close" @click="showTaskDetail = false">‚úï</button>
                </div>
                <div class="task-detail-body">
                    <!-- Stats -->
                    <div class="task-detail-section">
                        <div class="task-detail-stats">
                            <div class="task-detail-stat">
                                <div class="task-detail-stat-value"
                                    :style="{ color: taskDetailData.status === 'success' ? '#10b981' : '#ef4444' }">
                                    {{ taskDetailData.status === 'success' ? '‚úì' : '‚úó' }}
                                </div>
                                <div class="task-detail-stat-label">{{ taskDetailData.status === 'success' ? 'ÊâßË°åÊàêÂäü' :
                                    'ÊâßË°åÂ§±Ë¥•' }}</div>
                            </div>
                            <div class="task-detail-stat">
                                <div class="task-detail-stat-value">{{ taskDetailData.logs ? taskDetailData.logs.length
                                    : 0 }}</div>
                                <div class="task-detail-stat-label">Êó•ÂøóÊù°Êï∞</div>
                            </div>
                            <div class="task-detail-stat">
                                <div class="task-detail-stat-value">{{ (taskDetailData.screenshots &&
                                    taskDetailData.screenshots.length > 0) ? '‚úì' : '‚Äî' }}</div>
                                <div class="task-detail-stat-label">Êà™Âõæ</div>
                            </div>
                        </div>
                    </div>

                    <!-- Screenshot -->
                    <div class="task-detail-section">
                        <h4>üì∏ ÊâßË°åÊà™Âõæ</h4>
                        <div class="task-detail-screenshot">
                            <template v-if="taskDetailData.screenshots && taskDetailData.screenshots.length > 0">
                                <img v-for="s in taskDetailData.screenshots" :key="s.id" :src="s.image_url"
                                    alt="Screenshot"
                                    style="max-width: 200px; margin-bottom: 8px; cursor: pointer; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"
                                    @click="window.open(s.image_url, '_blank')">
                            </template>
                            <div v-else class="task-detail-screenshot-placeholder">
                                ÊöÇÊó†Êà™Âõæ
                            </div>
                        </div>
                    </div>

                    <!-- Full Logs -->
                    <div class="task-detail-section">
                        <h4>üìù ÂÆåÊï¥ÊâßË°åÊó•Âøó</h4>
                        <div class="task-detail-logs">
                            <div v-if="taskDetailData.logs && taskDetailData.logs.length > 0">
                                {{ taskDetailData.logs.join('\n') }}
                            </div>
                            <div v-else>ÊöÇÊó†Êó•Âøó</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Toast Notifications -->
        <div class="toast-container">
            <div v-for="toast in toasts" :key="toast.id" class="toast" :class="toast.type">
                {{ toast.message }}
            </div>
        </div>

        <!-- Floating Phone Preview Window -->
        <div v-if="showPhonePreview" class="phone-preview-window" :style="phonePreviewStyle"
            @mousedown="startDragPreview">
            <div class="phone-preview-header">
                <span class="phone-preview-title">üì± Live Preview</span>
                <div class="phone-preview-controls">
                    <select v-model="previewDeviceId" @change="refreshPreview" class="phone-preview-select"
                        @mousedown.stop>
                        <option value="">Select Device</option>
                        <option v-for="d in devices" :key="d.id" :value="d.id">
                            {{ d.name || d.id.substring(0, 15) }}
                        </option>
                    </select>
                    <button class="phone-preview-btn" @click.stop="refreshPreview" title="Refresh">üîÑ</button>
                    <button class="phone-preview-btn" @click.stop="showPhonePreview = false" title="Close">‚úï</button>
                </div>
            </div>
            <div class="phone-preview-body">
                <div v-if="!previewDeviceId" class="phone-preview-placeholder">
                    Select a device to preview
                </div>
                <img v-else-if="previewImage" :src="'data:image/png;base64,' + previewImage" class="phone-preview-image"
                    @error="previewImage = null">
                <div v-else class="phone-preview-placeholder">
                    Loading...
                </div>
            </div>
        </div>

        <!-- App Mapping Modal -->
        <div v-if="showAddAppModal" class="task-detail-modal" @click.self="showAddAppModal = false">
            <div class="task-detail-content" style="max-width: 500px;">
                <div class="task-detail-header">
                    <h3>{{ editingApp ? 'ÁºñËæëÂ∫îÁî®Êò†Â∞Ñ' : 'Ê∑ªÂä†Â∫îÁî®Êò†Â∞Ñ' }}</h3>
                    <button class="task-detail-close" @click="showAddAppModal = false">‚úï</button>
                </div>
                <div class="task-detail-body" style="padding: 20px;">
                    <div class="form-group">
                        <label class="form-label">Â∫îÁî®ÂêçÁß∞</label>
                        <input type="text" v-model="appForm.app_name" class="form-input" placeholder="Â¶ÇÔºöÂæÆ‰ø°"
                            :disabled="editingApp && !editingApp.is_custom">
                    </div>
                    <div class="form-group">
                        <label class="form-label">ÂåÖÂêç</label>
                        <input type="text" v-model="appForm.package_name" class="form-input"
                            placeholder="Â¶ÇÔºöcom.tencent.mm">
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
                        <button class="btn btn-secondary" @click="showAddAppModal = false">ÂèñÊ∂à</button>
                        <button class="btn btn-primary" @click="saveAppMapping">‰øùÂ≠ò</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Rule Item Modal -->
        <div v-if="showRuleModal" class="task-detail-modal" @click.self="showRuleModal = false">
            <div class="task-detail-content" style="max-width: 500px;">
                <div class="task-detail-header">
                    <h3>{{ editingRule ? 'ÁºñËæëËßÑÂàô' : 'Ê∑ªÂä†ËßÑÂàô' }} - {{ editingRuleAction }}</h3>
                    <button class="task-detail-close" @click="showRuleModal = false">‚úï</button>
                </div>
                <div class="task-detail-body" style="padding: 20px;">
                    <div class="form-group">
                        <label class="form-label">Êù°‰ª∂</label>
                        <input type="text" v-model="ruleForm.condition" class="form-input" placeholder="Â¶ÇÔºöÂ∫îÁî®Êú™ÂÆâË£Ö">
                    </div>
                    <div class="form-group">
                        <label class="form-label">Âä®‰Ωú</label>
                        <input type="text" v-model="ruleForm.action" class="form-input" placeholder="Â¶ÇÔºöËøîÂõûÈîôËØØÊèêÁ§∫">
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div class="form-group">
                            <label class="form-label">‰ºòÂÖàÁ∫ß</label>
                            <input type="number" v-model.number="ruleForm.priority" class="form-input" min="0">
                        </div>
                        <div class="form-group">
                            <label class="form-label">Áä∂ÊÄÅ</label>
                            <select v-model="ruleForm.enabled" class="form-select">
                                <option :value="true">ÂêØÁî®</option>
                                <option :value="false">Á¶ÅÁî®</option>
                            </select>
                        </div>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
                        <button class="btn btn-secondary" @click="showRuleModal = false">ÂèñÊ∂à</button>
                        <button class="btn btn-primary" @click="saveRuleItem">‰øùÂ≠ò</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tap Preview Modal (Debug Mode) -->
        <div v-if="showTapPreview" class="task-detail-modal" @click.self="cancelTapPreview">
            <div class="task-detail-content" style="max-width: 420px;">
                <div class="task-detail-header">
                    <h3>üêõ ÁÇπÂáªÈ¢ÑËßà (Debug Mode)</h3>
                    <button class="task-detail-close" @click="cancelTapPreview">‚úï</button>
                </div>
                <div class="task-detail-body" style="padding: 16px;">
                    <div
                        style="position: relative; background: var(--bg-tertiary); border-radius: 8px; overflow: hidden; cursor: crosshair;">
                        <img v-if="tapPreviewData.screenshot"
                            :src="'data:image/png;base64,' + tapPreviewData.screenshot"
                            style="width: 100%; display: block;" @click="handleTapPreviewClick">
                        <!-- Crosshair overlay -->
                        <div v-if="tapPreviewData.screenshot"
                            style="position: absolute; top: 0; left: 0; right: 0; bottom: 0; pointer-events: none;">
                            <svg style="width: 100%; height: 100%; position: absolute;">
                                <!-- Calculate crosshair position based on scale -->
                                <line :x1="(tapPreviewAdjustedX / tapPreviewData.width) * 100 + '%'" y1="0"
                                    :x2="(tapPreviewAdjustedX / tapPreviewData.width) * 100 + '%'" y2="100%"
                                    stroke="#ff0000" stroke-width="2" opacity="0.7" />
                                <line x1="0" :y1="(tapPreviewAdjustedY / tapPreviewData.height) * 100 + '%'" x2="100%"
                                    :y2="(tapPreviewAdjustedY / tapPreviewData.height) * 100 + '%'" stroke="#ff0000"
                                    stroke-width="2" opacity="0.7" />
                                <circle :cx="(tapPreviewAdjustedX / tapPreviewData.width) * 100 + '%'"
                                    :cy="(tapPreviewAdjustedY / tapPreviewData.height) * 100 + '%'" r="20" fill="none"
                                    stroke="#ff0000" stroke-width="2" opacity="0.7" />
                            </svg>
                        </div>
                    </div>
                    <div style="margin-top: 12px; font-size: 12px; color: var(--text-secondary); text-align: center;">
                        ÁõÆÊ†á‰ΩçÁΩÆ: ({{ tapPreviewAdjustedX }}, {{ tapPreviewAdjustedY }})
                        <br>
                        <span style="font-size: 11px; color: var(--text-muted);">ÁÇπÂáªÂõæÁâáÂèØË∞ÉÊï¥ÁÇπÂáª‰ΩçÁΩÆ</span>
                    </div>
                    <div style="display: flex; gap: 12px; margin-top: 16px;">
                        <button class="btn btn-secondary" style="flex: 1;" @click="cancelTapPreview">ÂèñÊ∂à</button>
                        <button class="btn btn-primary" style="flex: 1;" @click="confirmTapPreview">Á°ÆËÆ§ÁÇπÂáª</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Phone Preview Toggle Button -->
        <button v-if="!showPhonePreview && devices.length > 0" class="phone-preview-toggle" @click="openPhonePreview"
            title="Show Phone Preview">
            üì±
        </button>
    </div>

    <!-- Vue.js 3 CDN with fallback -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script>
        // Wait for Vue to load, with fallback
        function initApp() {
            if (typeof Vue === 'undefined') {
                document.getElementById('app').innerHTML = '<div style="padding: 40px; text-align: center;"><h2>Loading failed</h2><p>Unable to load Vue.js. Please check your internet connection.</p><button onclick="location.reload()">Retry</button></div>';
                return;
            }

            const { createApp, ref, onMounted, onUnmounted, watch } = Vue;

            const app = createApp({
                setup() {
                    // State
                    const currentPage = ref('chat');  // Default to chat page
                    const devices = ref([]);
                    const selectedDevices = ref([]);
                    const taskContent = ref('');
                    const taskRunning = ref(false);
                    const taskProgress = ref(0);
                    const taskLogs = ref([]);
                    const scheduledTasks = ref([]);
                    const modelServices = ref([]);
                    const activeModel = ref(null);
                    const modelPresets = ref([]);
                    const showModelForm = ref(false);
                    const modelFormMode = ref('create');
                    const modelForm = ref(getDefaultModelForm());

                    function getDefaultModelForm() {
                        return {
                            id: '',
                            name: '',
                            base_url: '',
                            api_key: '',
                            model_name: '',
                            max_tokens: 3000,
                            temperature: 0.0,
                            top_p: 0.85,
                            frequency_penalty: 0.2,
                            description: '',
                            is_active: false,
                            protocol: 'openai',
                            category: '',
                        };
                    }
                    const emailConfig = ref({});
                    const screenshotConfig = ref({
                        max_dimension: 1920,
                        jpeg_quality: 70
                    });
                    // Rules configuration state
                    const appMappings = ref([]);
                    const timingConfig = ref(null);
                    const systemPrompts = ref(null);
                    const showAddAppModal = ref(false);
                    const editingApp = ref(null);
                    const appForm = ref({ app_name: '', package_name: '' });
                    // Action rules state
                    const actionRules = ref([]);
                    const expandedActions = ref({});
                    const showRuleModal = ref(false);
                    const editingRuleAction = ref('');
                    const editingRule = ref(null);
                    const ruleForm = ref({ condition: '', action: '', priority: 0, enabled: true });
                    const wsConnected = ref(false);
                    const loading = ref(false);
                    const toasts = ref([]);
                    const devicePins = ref({});
                    const pinInputValues = ref({});  // Store input values for PIN fields
                    const showPinFor = ref('');  // Device ID for which PIN is visible
                    // Wireless pairing state
                    const pairAddress = ref('');
                    const pairCode = ref('');
                    const connectAddress = ref('');
                    const pairingLoading = ref(false);
                    const connectingLoading = ref(false);
                    const deviceLogs = ref([]);
                    // APK install state
                    const apkTargetDevice = ref('');
                    const apkFile = ref(null);
                    const apkInstalling = ref(false);
                    const apkLogs = ref([]);
                    const apkFileInput = ref(null);
                    // File manager state
                    const fileDevice = ref('');
                    const filePath = ref('/sdcard');
                    const fileList = ref([]);
                    const fileLoading = ref(false);
                    const uploadSelectedFile = ref(null);
                    const fileUploading = ref(false);
                    const uploadFileInput = ref(null);
                    const logContainer = ref(null);
                    const showSchedulerForm = ref(false);
                    const schedulerFormMode = ref('create');
                    const schedulerForm = ref(getDefaultSchedulerForm());
                    // Scheduler logs state
                    const schedulerLogs = ref([]);
                    const showLogDetailModal = ref(false);
                    const logDetailData = ref({});

                    // Phone preview state
                    const showPhonePreview = ref(false);
                    const previewDeviceId = ref('');
                    const previewImage = ref(null);
                    const previewLoading = ref(false);
                    const previewPosition = ref({ x: 100, y: 100 });
                    let previewInterval = null;
                    let isDragging = false;
                    let dragOffset = { x: 0, y: 0 };

                    // Chat state
                    const chatMessages = ref([]);
                    const chatInput = ref('');
                    const chatDeviceId = ref('');
                    const chatRunning = ref(false);
                    const chatMessagesRef = ref(null);
                    const chatAutoEmail = ref(false);  // Default: no auto email in chat mode
                    const complexTaskMode = ref(false);  // Â§çÊùÇ‰ªªÂä°Ê®°ÂºèÔºöÂÖàÊãÜËß£ÊàêtodolistÂÜçÈÄê‰∏™ÊâßË°å
                    const debugMode = ref(false);  // Ë∞ÉËØïÊ®°ÂºèÔºöÁÇπÂáªÂâçÊòæÁ§∫È¢ÑËßà
                    const darkMode = ref(false);  // ÊöóÈªëÊ®°Âºè
                    const awaitingTodoListConfirmation = ref(false);  // ÊòØÂê¶Ê≠£Âú®Á≠âÂæÖÁî®Êà∑Á°ÆËÆ§todoList
                    const subtaskTimeoutSeconds = ref(180);  // Â≠ê‰ªªÂä°Ë∂ÖÊó∂Êó∂Èó¥ÔºàÁßíÔºâÔºåÈªòËÆ§3ÂàÜÈíü
                    const subtaskCountdown = ref(0);  // Â≠ê‰ªªÂä°Ââ©‰ΩôÁßíÊï∞ÔºàÁî®‰∫éÂÄíËÆ°Êó∂ÊòæÁ§∫Ôºâ
                    let subtaskCountdownTimer = null;  // ÂÄíËÆ°Êó∂ÂÆöÊó∂Âô®
                    let currentChatTaskId = null;
                    let chatScrollPosition = 0;  // ‰øùÂ≠ò Chat ÊªöÂä®‰ΩçÁΩÆ

                    // Tap preview modal state (debug mode)
                    const showTapPreview = ref(false);
                    const tapPreviewData = ref({ requestId: '', x: 0, y: 0, width: 0, height: 0, screenshot: '' });
                    const tapPreviewAdjustedX = ref(0);
                    const tapPreviewAdjustedY = ref(0);

                    // Dark Mode Functions
                    function applyTheme(theme) {
                        if (theme === 'dark') {
                            document.documentElement.setAttribute('data-theme', 'dark');
                        } else {
                            document.documentElement.removeAttribute('data-theme');
                        }
                    }

                    function toggleDarkMode() {
                        darkMode.value = !darkMode.value;
                        const theme = darkMode.value ? 'dark' : 'light';
                        applyTheme(theme);
                        localStorage.setItem('theme', theme);
                    }

                    // Chat sessions state
                    const chatSessions = ref([]);
                    const currentSessionId = ref('');
                    const SESSIONS_STORAGE_KEY = 'autoglm_chat_sessions';

                    // Task detail modal state
                    const showTaskDetail = ref(false);
                    const taskDetailData = ref({});

                    // Calculate safe position for preview window
                    function updatePreviewPosition() {
                        const windowWidth = 300;
                        const windowHeight = 580; // 540 + header
                        const margin = 20;
                        previewPosition.value = {
                            x: Math.max(margin, window.innerWidth - windowWidth - margin),
                            y: Math.max(margin, window.innerHeight - windowHeight - margin)
                        };
                    }

                    function getDefaultSchedulerForm() {
                        return {
                            id: '',
                            name: '',
                            task_content: '',
                            enabled: true,
                            schedule_type: 'daily',
                            run_at: '',
                            interval_minutes: 60,
                            daily_time: '09:00',
                            weekly_days: [1],
                            weekly_time: '09:00',
                            monthly_day: 1,
                            monthly_time: '09:00',
                            devices: [],
                        };
                    }

                    // WebSocket
                    let ws = null;
                    let reconnectTimer = null;

                    function showToast(message, type = 'success') {
                        const id = Date.now();
                        toasts.value.push({ id, message, type });
                        setTimeout(() => {
                            toasts.value = toasts.value.filter(t => t.id !== id);
                        }, 3000);
                    }

                    // API calls
                    async function apiCall(url, options = {}) {
                        try {
                            const response = await fetch(url, {
                                ...options,
                                headers: {
                                    'Content-Type': 'application/json',
                                    ...options.headers,
                                },
                            });
                            const data = await response.json();
                            if (!response.ok) {
                                throw new Error(data.detail || 'API Error');
                            }
                            return data;
                        } catch (error) {
                            showToast(error.message, 'error');
                            throw error;
                        }
                    }

                    // WebSocket connection
                    function connectWebSocket() {
                        try {
                            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                            const wsUrl = `${protocol}//${window.location.host}/ws`;
                            ws = new WebSocket(wsUrl);

                            ws.onopen = () => {
                                wsConnected.value = true;
                                console.log('WebSocket connected');
                            };

                            ws.onclose = () => {
                                wsConnected.value = false;
                                console.log('WebSocket disconnected');
                                reconnectTimer = setTimeout(connectWebSocket, 3000);
                            };

                            ws.onmessage = (event) => {
                                try {
                                    const data = JSON.parse(event.data);
                                    handleWebSocketMessage(data);
                                } catch (e) {
                                    console.error('WebSocket message error:', e);
                                }
                            };

                            ws.onerror = (error) => {
                                console.error('WebSocket error:', error);
                            };
                        } catch (e) {
                            console.error('WebSocket connection error:', e);
                        }
                    }

                    function handleWebSocketMessage(data) {
                        switch (data.type) {
                            case 'init':
                                if (data.task_status) {
                                    taskRunning.value = data.task_status.running;
                                    if (data.task_status.task) {
                                        taskProgress.value = data.task_status.task.progress || 0;
                                    }
                                }
                                break;
                            case 'task_log':
                                // 1. Run Task Page Logs (taskLogs) - Only for manual tasks
                                if (!data.task_type || data.task_type === 'manual') {
                                    taskLogs.value.push({
                                        time: new Date().toLocaleTimeString(),
                                        message: data.message,
                                    });
                                }

                                // 2. Scheduler Page: Don't add real-time logs here
                                // schedulerLogs is populated from API (summary per execution cycle)
                                // Real-time logs for scheduled tasks are not displayed in scheduler page

                                // 3. Chat Page Logs (chatMessages)
                                if (chatMessages.value.length > 0) {
                                    // ÊâæÂà∞ÂåπÈÖçtaskIdÁöÑÊ∂àÊÅØÔºåÊàñËÄÖÊúÄÂêé‰∏ÄÊù°runningÁä∂ÊÄÅÁöÑassistantÊ∂àÊÅØ
                                    // ÂØπ‰∫éÂ§çÊùÇ‰ªªÂä°Ôºå‰πüÊé•ÂèóÊúâtodoListÁöÑÊ∂àÊÅØ
                                    let targetMsg = null;
                                    for (let i = chatMessages.value.length - 1; i >= 0; i--) {
                                        const msg = chatMessages.value[i];
                                        if (msg.role === 'assistant') {
                                            // Â¶ÇÊûúÊ∂àÊÅØÊ≠£Âú®ËøêË°åÔºåÊàñËÄÖÊòØÊúâtodoListÁöÑÂ§çÊùÇ‰ªªÂä°ÔºàÊ≠£Âú®ÊâßË°å‰∏≠Ôºâ
                                            const isRunning = msg.status === 'running';
                                            const isComplexTaskRunning = msg.todoList && msg.todoList.length > 0 &&
                                                msg.todoList.some(t => t.status === 'running' || t.status === 'pending');

                                            if (isRunning || isComplexTaskRunning) {
                                                // Â¶ÇÊûúÊúâtaskIdÂàôÂøÖÈ°ªÂåπÈÖçÔºåÂê¶Âàô‰ΩøÁî®ÊúÄÂêé‰∏ÄÊù°
                                                if (data.task_id && msg.taskId && msg.taskId !== data.task_id) {
                                                    continue;  // taskId‰∏çÂåπÈÖçÔºåË∑≥Ëøá
                                                }
                                                targetMsg = msg;
                                                break;
                                            }
                                        }
                                    }

                                    if (targetMsg) {
                                        // ‰ΩøÁî®Êï∞ÁªÑÊâ©Â±ïËøêÁÆóÁ¨¶Âº∫Âà∂Ëß¶Âèë Vue Êõ¥Êñ∞ (Reactivity)
                                        const newLogs = targetMsg.logs ? [...targetMsg.logs, data.message] : [data.message];
                                        targetMsg.logs = newLogs;

                                        // Â§çÊùÇ‰ªªÂä°Ê®°ÂºèÔºöÂ∞ÜÊó•Âøó‰πüÊ∑ªÂä†Âà∞ÂΩìÂâçÊâßË°åÁöÑÂ≠ê‰ªªÂä°
                                        // ‰∏çÊ£ÄÊü•Â≠ê‰ªªÂä°Áä∂ÊÄÅÔºåÂõ†‰∏∫Êó•ÂøóÂèØËÉΩÂú®Áä∂ÊÄÅÂèòÊõ¥ÂêéÊâçÂà∞Ëææ
                                        if (targetMsg.todoList && targetMsg.currentTodoIndex !== undefined && targetMsg.currentTodoIndex >= 0) {
                                            const currentTodo = targetMsg.todoList[targetMsg.currentTodoIndex];
                                            if (currentTodo) {
                                                const subNewLogs = currentTodo.logs ? [...currentTodo.logs, data.message] : [data.message];
                                                currentTodo.logs = subNewLogs;
                                            }
                                        }

                                        scrollChatToBottom();
                                    }
                                }
                                break;
                            case 'task_progress':
                                taskProgress.value = data.progress;
                                break;
                            case 'task_finished':
                                taskRunning.value = false;
                                // Ê£ÄÊü•ÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØÊòØÂê¶ÊòØÂ§çÊùÇ‰ªªÂä°ÔºàÊúâ todoListÔºâ
                                const lastMsgForToast = chatMessages.value.length > 0 ? chatMessages.value[chatMessages.value.length - 1] : null;
                                const isComplexTask = lastMsgForToast && lastMsgForToast.todoList && lastMsgForToast.todoList.length > 0;

                                if (isComplexTask) {
                                    // Â§çÊùÇ‰ªªÂä°Â≠ê‰ªªÂä°ÂÆåÊàêÔºåÊòæÁ§∫ÁÆÄÁü≠ÊèêÁ§∫
                                    const currentIdx = lastMsgForToast.currentTodoIndex;
                                    if (currentIdx !== undefined && currentIdx >= 0 && currentIdx < lastMsgForToast.todoList.length) {
                                        showToast(`Â≠ê‰ªªÂä° ${currentIdx + 1}/${lastMsgForToast.todoList.length} ${data.success ? 'ÂÆåÊàê' : 'Â§±Ë¥•'}`, data.success ? 'success' : 'error');
                                    }
                                } else {
                                    // ÊôÆÈÄö‰ªªÂä°ÔºåÊòæÁ§∫ÂÆåÊï¥ÊèêÁ§∫
                                    showToast(data.message, data.success ? 'success' : 'error');
                                }
                                // Update chat message status and use screenshot from WebSocket
                                // Â§çÊùÇ‰ªªÂä°Ê®°Âºè‰∏ãÔºàÊ∂àÊÅØÊúâtodoListÔºâÔºå‰∏çË¶ÅÂú®ËøôÈáå‰øÆÊîπÁä∂ÊÄÅÔºåËÆ©Âæ™ÁéØËá™Â∑±ÊéßÂà∂
                                // ÊôÆÈÄö‰ªªÂä°ÔºàÊ∂àÊÅØÊ≤°ÊúâtodoListÔºâÊâçÂú®ËøôÈáåÊõ¥Êñ∞Áä∂ÊÄÅ
                                if (chatRunning.value && chatMessages.value.length > 0 && !isComplexTask) {
                                    const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                                    if (lastMsg.role === 'assistant' && lastMsg.status === 'running') {
                                        lastMsg.status = data.success ? 'success' : 'error';
                                        // ÊòæÁ§∫ÂÖ∑‰ΩìÁöÑÈîôËØØ‰ø°ÊÅØ
                                        if (data.success) {
                                            lastMsg.content = '‚úÖ ‰ªªÂä°ÊâßË°åÂÆåÊàêÔºÅ';
                                        } else {
                                            // ÊèêÂèñÂπ∂Ê†ºÂºèÂåñÈîôËØØ‰ø°ÊÅØ
                                            let errorMsg = data.message || '‰ªªÂä°ÊâßË°åÂ§±Ë¥•';
                                            if (errorMsg.includes('Token error') || errorMsg.includes('limited')) {
                                                errorMsg = '‚ùå ' + errorMsg + '\n\nüí° ÊèêÁ§∫ÔºöÊ®°ÂûãÊúçÂä°Ë¢´ÈôêÊµÅÔºåËØ∑Á®çÂêéÂÜçËØï„ÄÇ';
                                            } else if (errorMsg.includes('Task failed:')) {
                                                errorMsg = '‚ùå ' + errorMsg.replace('Task failed:', '‰ªªÂä°Â§±Ë¥•:');
                                            } else {
                                                errorMsg = '‚ùå ‰ªªÂä°ÊâßË°åÂ§±Ë¥•: ' + errorMsg;
                                            }
                                            lastMsg.content = errorMsg;
                                        }
                                        // ‰ΩøÁî® screenshot_id ‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÊà™ÂõæÔºå‰∏çÂÜç‰ΩøÁî® base64
                                        if (data.screenshot_id && currentSessionId.value && lastMsg.id) {
                                            // Á´ãÂç≥Êõ¥Êñ∞Ê∂àÊÅØÁöÑ screenshots Êï∞ÁªÑÔºå‰ΩøÁî® screenshot_id ÊûÑÂª∫ image_url
                                            if (!lastMsg.screenshots) {
                                                lastMsg.screenshots = [];
                                            }
                                            // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®Ëøô‰∏™Êà™ÂõæÔºåÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
                                            const exists = lastMsg.screenshots.some(s => s.id === data.screenshot_id);
                                            if (!exists) {
                                                lastMsg.screenshots.push({
                                                    id: data.screenshot_id,
                                                    image_url: `/api/chat/screenshots/${data.screenshot_id}`
                                                });
                                            }
                                        }
                                    }
                                    chatRunning.value = false;
                                    // Save session after task completes
                                    saveCurrentSession();
                                }
                                // Refresh scheduler logs when a scheduled task finishes
                                if (data.task_type === 'scheduled') {
                                    loadSchedulerLogs();
                                }
                                break;
                            case 'task_tokens':
                                // Update chat message tokens
                                if (chatMessages.value.length > 0) {
                                    // Find target message
                                    let targetMsg = null;
                                    for (let i = chatMessages.value.length - 1; i >= 0; i--) {
                                        const msg = chatMessages.value[i];
                                        if (msg.role === 'assistant') {
                                            const isRunning = msg.status === 'running';
                                            const isComplexTaskRunning = msg.todoList && msg.todoList.length > 0 &&
                                                msg.todoList.some(t => t.status === 'running' || t.status === 'pending');

                                            if (isRunning || isComplexTaskRunning) {
                                                if (data.task_id && msg.taskId && msg.taskId !== data.task_id) {
                                                    continue;
                                                }
                                                targetMsg = msg;
                                                break;
                                            }
                                        }
                                    }

                                    if (targetMsg) {
                                        if (!targetMsg.tokens) targetMsg.tokens = 0;
                                        // Á¥ØÂä† token (Âõ†‰∏∫ÊòØ‰∏ÄÊ¨°Ê¨°Êé®ËøáÊù•ÁöÑ)
                                        targetMsg.tokens += data.total_tokens;
                                    }
                                }
                                break;
                            case 'devices':
                                devices.value = data.devices;
                                break;
                            case 'ping':
                                if (ws && ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify({ type: 'pong' }));
                                }
                                break;
                            case 'tap_preview_request':
                                // Debug mode: show tap preview modal
                                if (debugMode.value) {
                                    tapPreviewData.value = {
                                        requestId: data.request_id,
                                        x: data.x,
                                        y: data.y,
                                        width: data.width,
                                        height: data.height,
                                        screenshot: data.screenshot
                                    };
                                    tapPreviewAdjustedX.value = data.x;
                                    tapPreviewAdjustedY.value = data.y;
                                    showTapPreview.value = true;
                                } else {
                                    // Auto-confirm if debug mode is not enabled
                                    if (ws && ws.readyState === WebSocket.OPEN) {
                                        ws.send(JSON.stringify({
                                            type: 'tap_preview_response',
                                            request_id: data.request_id,
                                            proceed: true,
                                            x: data.x,
                                            y: data.y
                                        }));
                                    }
                                }
                                break;
                        }
                    }

                    // Device functions

                    // Chat Session Management Functions
                    function loadSessions() {
                        try {
                            const stored = localStorage.getItem(SESSIONS_STORAGE_KEY);
                            if (stored) {
                                chatSessions.value = JSON.parse(stored);
                                // Sort by updatedAt descending
                                chatSessions.value.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                            }
                        } catch (e) {
                            console.error('Failed to load sessions:', e);
                            chatSessions.value = [];
                        }
                    }

                    function saveSessions() {
                        try {
                            // Deep copy sessions to avoid modifying reactive state
                            const sessionsToSave = JSON.parse(JSON.stringify(chatSessions.value));

                            // Remove heavy data (screenshots metadata and large logs) from saved sessions
                            sessionsToSave.forEach(session => {
                                if (session.messages) {
                                    session.messages.forEach(msg => {
                                        // Remove screenshot base64 (if any legacy data exists)
                                        if (msg.screenshot) {
                                            msg.screenshot = null;
                                        }
                                        // Screenshots are stored in database, only keep minimal metadata
                                        // Limit logs size
                                        if (msg.logs && msg.logs.length > 50) {
                                            msg.logs = msg.logs.slice(-50); // Keep only last 50 logs
                                        }
                                        // Clean subtask logs too
                                        if (msg.todoList) {
                                            msg.todoList.forEach(todo => {
                                                if (todo.logs && todo.logs.length > 20) {
                                                    todo.logs = todo.logs.slice(-20);
                                                }
                                            });
                                        }
                                    });
                                }
                            });

                            localStorage.setItem(SESSIONS_STORAGE_KEY, JSON.stringify(sessionsToSave));
                        } catch (e) {
                            console.error('Failed to save sessions:', e);
                            // Fallback: try to save only the current session if full save fails
                            if (e.name === 'QuotaExceededError') {
                                try {
                                    // Try to clean up old sessions
                                    const currentSession = sessionsToSave.find(s => s.id === currentSessionId.value);
                                    if (currentSession) {
                                        localStorage.setItem(SESSIONS_STORAGE_KEY, JSON.stringify([currentSession]));
                                        showToast('Â≠òÂÇ®Á©∫Èó¥‰∏çË∂≥ÔºåÂ∑≤Ê∏ÖÁêÜÊóß‰ºöËØù', 'warning');
                                    }
                                } catch (retryError) {
                                    showToast('Â≠òÂÇ®Á©∫Èó¥Â∑≤Êª°ÔºåÊó†Ê≥ï‰øùÂ≠ò‰ºöËØù', 'error');
                                }
                            }
                        }
                    }

                    function saveCurrentSession() {
                        if (!currentSessionId.value) return;

                        const session = chatSessions.value.find(s => s.id === currentSessionId.value);
                        if (session) {
                            session.messages = chatMessages.value;
                            // ‰ºöËØùÊó∂Èó¥‰ª•ÊúÄÊñ∞Ê∂àÊÅØÊó∂Èó¥‰∏∫ÂáÜ
                            if (chatMessages.value.length > 0) {
                                const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                                if (lastMsg.timestamp) {
                                    session.updatedAt = lastMsg.timestamp;
                                }
                            }
                            // Update title from first user message if not set
                            if (!session.title || session.title === 'Êñ∞‰ºöËØù') {
                                const firstUserMsg = chatMessages.value.find(m => m.role === 'user');
                                if (firstUserMsg) {
                                    session.title = firstUserMsg.content.substring(0, 30) + (firstUserMsg.content.length > 30 ? '...' : '');
                                }
                            }
                            saveSessions();

                            // ÂêåÊ≠• assistant Ê∂àÊÅØÁöÑ status Âíå todoList Âà∞ÊúçÂä°Âô®Êï∞ÊçÆÂ∫ì
                            saveMessageStatusToServer();
                        }
                    }

                    // ‰øùÂ≠òÊ∂àÊÅØÁä∂ÊÄÅÂà∞ÊúçÂä°Âô®ÔºàÈùûÈòªÂ°ûÔºå‰∏çÂΩ±ÂìçÊú¨Âú∞Êìç‰ΩúÔºâ
                    // üÜï ‰ΩøÁî®Èò≤ÊäñÈÅøÂÖçÈ¢ëÁπÅËØ∑Ê±Ç
                    let saveMessageTimer = null;
                    let lastSavedMessageStates = new Map(); // ËÆ∞ÂΩïÊØèÊù°Ê∂àÊÅØ‰∏äÊ¨°‰øùÂ≠òÁöÑÁä∂ÊÄÅ
                    async function saveMessageStatusToServer() {
                        // Ê∏ÖÈô§‰πãÂâçÁöÑÂÆöÊó∂Âô®
                        if (saveMessageTimer) {
                            clearTimeout(saveMessageTimer);
                        }

                        // Âª∂Ëøü300msÊâßË°åÔºåÂ¶ÇÊûú300msÂÜÖÂÜçÊ¨°Ë∞ÉÁî®ÂàôÈáçÊñ∞ËÆ°Êó∂
                        saveMessageTimer = setTimeout(async () => {
                            if (!currentSessionId.value) return;

                            // ÊâæÂá∫ÈúÄË¶Å‰øùÂ≠òÁä∂ÊÄÅÁöÑ assistant Ê∂àÊÅØ
                            for (const msg of chatMessages.value) {
                                if (msg.role === 'assistant' && msg.id && (msg.status || msg.todoList)) {
                                    // ËÆ°ÁÆóÂΩìÂâçÊ∂àÊÅØÁöÑÁä∂ÊÄÅÊåáÁ∫π
                                    const currentState = `${msg.status || ''}-${JSON.stringify(msg.todoList || null)}`;
                                    const lastState = lastSavedMessageStates.get(msg.id);

                                    // Ë∑≥ËøáÊú™ÂèòÂåñÁöÑÊ∂àÊÅØ
                                    if (lastState === currentState) {
                                        continue;
                                    }

                                    try {
                                        await apiCall(`/api/chat/sessions/${currentSessionId.value}/messages/${msg.id}`, {
                                            method: 'PATCH',
                                            body: JSON.stringify({
                                                status: msg.status || null,
                                                content: msg.content || null,
                                                todo_list: msg.todoList || null
                                            })
                                        });

                                        // ËÆ∞ÂΩï‰øùÂ≠òÊàêÂäüÁöÑÁä∂ÊÄÅ
                                        lastSavedMessageStates.set(msg.id, currentState);
                                    } catch (error) {
                                        // ÈùôÈªòÂ§±Ë¥•Ôºå‰∏çÂΩ±ÂìçÁî®Êà∑‰ΩìÈ™å
                                        console.debug('Failed to save message status to server:', error);
                                    }
                                }
                            }
                        }, 300); // 300msÈò≤ÊäñÂª∂Ëøü
                    }

                    async function createNewSession() {
                        // Save current session first
                        saveCurrentSession();

                        // Â∞ùËØï‰ªéÊúçÂä°Âô®ÂàõÂª∫‰ºöËØùÔºåÁ°Æ‰øù ID ÂêåÊ≠•
                        try {
                            const deviceId = chatDeviceId.value || 'default';
                            const serverSession = await apiCall('/api/chat/sessions', {
                                method: 'POST',
                                body: JSON.stringify({
                                    device_id: deviceId,
                                    title: 'Êñ∞‰ºöËØù'
                                })
                            });

                            const newSession = {
                                id: serverSession.id,
                                title: serverSession.title || 'Êñ∞‰ºöËØù',
                                deviceId: serverSession.device_id,
                                messages: [],
                                createdAt: serverSession.created_at,
                                updatedAt: serverSession.updated_at
                            };
                            chatSessions.value.unshift(newSession);
                            currentSessionId.value = newSession.id;
                            chatMessages.value = [];
                            saveSessions();
                        } catch (error) {
                            console.error('Failed to create session on server:', error);
                            // ÈôçÁ∫ßÊñπÊ°àÔºö‰ΩøÁî®Êú¨Âú∞ ID
                            const newSession = {
                                id: Date.now().toString(),
                                title: 'Êñ∞‰ºöËØù',
                                messages: [],
                                createdAt: new Date().toISOString(),
                                updatedAt: new Date().toISOString()
                            };
                            chatSessions.value.unshift(newSession);
                            currentSessionId.value = newSession.id;
                            chatMessages.value = [];
                            saveSessions();
                        }
                    }

                    async function switchSession(sessionId) {
                        if (sessionId === currentSessionId.value) return;

                        // Save current session first
                        saveCurrentSession();

                        const session = chatSessions.value.find(s => s.id === sessionId);
                        if (session) {
                            currentSessionId.value = session.id;
                            chatMessages.value = session.messages || [];

                            // Â∞ùËØï‰ªéÊúçÂä°Âô®Âä†ËΩΩÂÆåÊï¥ÁöÑÊ∂àÊÅØÊï∞ÊçÆÔºàÂåÖÊã¨ screenshotsÔºâ
                            // ËøôÊ†∑ÂèØ‰ª•Á°Æ‰øùÊúçÂä°ÈáçÂêØÂêé‰πüËÉΩÁúãÂà∞Êà™Âõæ
                            try {
                                const detailData = await apiCall(`/api/chat/sessions/${sessionId}/detail`);
                                if (detailData && detailData.messages) {
                                    // Êõ¥Êñ∞Ê∂àÊÅØÊï∞ÊçÆÔºåÁâπÂà´ÊòØ screenshots
                                    detailData.messages.forEach(serverMsg => {
                                        const localMsg = chatMessages.value.find(m => m.id === serverMsg.id);
                                        if (localMsg && serverMsg.screenshots && serverMsg.screenshots.length > 0) {
                                            localMsg.screenshots = serverMsg.screenshots;
                                        }
                                    });
                                }
                            } catch (error) {
                                // Â¶ÇÊûú‰ºöËØù‰∏çÂ≠òÂú®Ôºà404ÔºâÔºå‰ªéÂàóË°®‰∏≠ÁßªÈô§
                                if (error.message && error.message.includes('Session not found')) {
                                    console.warn(`Session ${sessionId} not found, removing from list`);
                                    const index = chatSessions.value.findIndex(s => s.id === sessionId);
                                    if (index !== -1) {
                                        chatSessions.value.splice(index, 1);
                                        saveSessions();

                                        // Â¶ÇÊûúÊúâÂÖ∂‰ªñ‰ºöËØùÔºåÂàáÊç¢Âà∞‰∏ã‰∏Ä‰∏™ÔºåÂê¶ÂàôÂàõÂª∫Êñ∞‰ºöËØù
                                        if (chatSessions.value.length > 0) {
                                            await switchSession(chatSessions.value[0].id);
                                            return;
                                        } else {
                                            createNewSession();
                                            return;
                                        }
                                    }
                                } else {
                                    console.error('Failed to load session detail from server:', error);
                                    // ÂÖ∂‰ªñÈîôËØØÁªßÁª≠‰ΩøÁî®Êú¨Âú∞Êï∞ÊçÆ
                                }
                            }

                            // ‰ΩøÁî® nextTick Á°Æ‰øù DOM Êõ¥Êñ∞ÂêéÂÜçÊªöÂä®
                            Vue.nextTick(() => {
                                scrollChatToBottom();
                            });
                        }
                    }

                    async function deleteSession(sessionId) {
                        if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™‰ºöËØùÂêóÔºü')) return;

                        // ‰ªéÊúçÂä°Âô®Âà†Èô§‰ºöËØù
                        try {
                            await apiCall(`/api/chat/sessions/${sessionId}`, { method: 'DELETE' });
                        } catch (error) {
                            console.error('Failed to delete session from server:', error);
                            // ÁªßÁª≠Âà†Èô§Êú¨Âú∞‰ºöËØùÔºåÂç≥‰ΩøÊúçÂä°Âô®Âà†Èô§Â§±Ë¥•
                        }

                        // ‰ªéÊú¨Âú∞Âà†Èô§‰ºöËØù
                        const index = chatSessions.value.findIndex(s => s.id === sessionId);
                        if (index !== -1) {
                            chatSessions.value.splice(index, 1);
                            saveSessions();

                            // If deleted current session, switch to another or create new
                            if (sessionId === currentSessionId.value) {
                                if (chatSessions.value.length > 0) {
                                    await switchSession(chatSessions.value[0].id);
                                } else {
                                    await createNewSession();
                                }
                            }
                        }
                    }

                    function formatSessionTime(isoString) {
                        if (!isoString) return '';
                        const date = new Date(isoString);
                        const now = new Date();
                        const diffMs = now - date;
                        const diffMins = Math.floor(diffMs / 60000);
                        const diffHours = Math.floor(diffMs / 3600000);
                        const diffDays = Math.floor(diffMs / 86400000);

                        if (diffMins < 1) return 'ÂàöÂàö';
                        if (diffMins < 60) return `${diffMins}ÂàÜÈíüÂâç`;
                        if (diffHours < 24) return `${diffHours}Â∞èÊó∂Ââç`;
                        if (diffDays < 7) return `${diffDays}Â§©Ââç`;
                        return date.toLocaleDateString();
                    }

                    function formatMsgTime(timestamp) {
                        if (!timestamp) return '';
                        const date = new Date(timestamp);
                        return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    }

                    async function initChatSessions() {
                        // ÂÖà‰ªéÊúçÂä°Âô®Âä†ËΩΩ‰ºöËØùÂàóË°®ÔºåÁ°Æ‰øùÊï∞ÊçÆÂêåÊ≠•
                        try {
                            const serverSessions = await apiCall('/api/chat/sessions?limit=50');
                            if (serverSessions && serverSessions.length > 0) {
                                // Â∞ÜÊúçÂä°Âô®‰ºöËØùËΩ¨Êç¢‰∏∫ÂâçÁ´ØÊ†ºÂºè
                                const serverSessionsFormatted = serverSessions.map(s => ({
                                    id: s.id,
                                    title: s.title || 'Êñ∞‰ºöËØù',
                                    deviceId: s.device_id,
                                    status: s.status,
                                    updatedAt: s.updated_at,
                                    totalTokens: s.total_tokens || 0,
                                    messages: []  // Ê∂àÊÅØÁ®çÂêéÂä†ËΩΩ
                                }));

                                // ÂêàÂπ∂ÊúçÂä°Âô®‰ºöËØùÂíåÊú¨Âú∞‰ºöËØùÔºà‰ºòÂÖà‰ΩøÁî®ÊúçÂä°Âô®Êï∞ÊçÆÔºâ
                                const localSessions = [];
                                try {
                                    const stored = localStorage.getItem(SESSIONS_STORAGE_KEY);
                                    if (stored) {
                                        localSessions.push(...JSON.parse(stored));
                                    }
                                } catch (e) {
                                    console.warn('Failed to load local sessions:', e);
                                }

                                // ÂêàÂπ∂ÔºöÊúçÂä°Âô®‰ºöËØù‰ºòÂÖàÔºå‰ΩÜ‰øùÁïôÊú¨Âú∞‰ºöËØùÁöÑÊ∂àÊÅØÊï∞ÊçÆÔºàÂ¶ÇÊûúÊúçÂä°Âô®‰ºöËØùÂ≠òÂú®Ôºâ
                                const mergedSessions = [];
                                const serverSessionIds = new Set(serverSessionsFormatted.map(s => s.id));

                                // ÂÖàÊ∑ªÂä†ÊúçÂä°Âô®‰ºöËØù
                                for (const serverSession of serverSessionsFormatted) {
                                    const localSession = localSessions.find(s => s.id === serverSession.id);
                                    if (localSession && localSession.messages) {
                                        // ‰øùÁïôÊú¨Âú∞Ê∂àÊÅØÊï∞ÊçÆ
                                        serverSession.messages = localSession.messages;
                                    }
                                    mergedSessions.push(serverSession);
                                }

                                // Ê∑ªÂä†Êú¨Âú∞Â≠òÂú®‰ΩÜÊúçÂä°Âô®‰∏çÂ≠òÂú®ÁöÑ‰ºöËØùÔºàÂèØËÉΩÊòØÊú™ÂêåÊ≠•ÁöÑÔºâ
                                for (const localSession of localSessions) {
                                    if (!serverSessionIds.has(localSession.id)) {
                                        mergedSessions.push(localSession);
                                    }
                                }

                                // ÊåâÊõ¥Êñ∞Êó∂Èó¥ÊéíÂ∫è
                                mergedSessions.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                                chatSessions.value = mergedSessions;
                                saveSessions();
                            } else {
                                // ÊúçÂä°Âô®Ê≤°Êúâ‰ºöËØùÔºå‰ΩøÁî®Êú¨Âú∞‰ºöËØù
                                loadSessions();
                            }
                        } catch (error) {
                            console.error('Failed to load sessions from server:', error);
                            // ÊúçÂä°Âô®Âä†ËΩΩÂ§±Ë¥•Ôºå‰ΩøÁî®Êú¨Âú∞‰ºöËØù
                            loadSessions();
                        }

                        // Auto-enter most recent session or create new one
                        if (chatSessions.value.length > 0) {
                            const mostRecent = chatSessions.value[0];
                            currentSessionId.value = mostRecent.id;

                            // Â¶ÇÊûúÊú¨Âú∞ÊúâÊ∂àÊÅØÊï∞ÊçÆÔºåÂÖà‰ΩøÁî®Êú¨Âú∞Êï∞ÊçÆ
                            if (mostRecent.messages && mostRecent.messages.length > 0) {
                                chatMessages.value = mostRecent.messages;
                            } else {
                                chatMessages.value = [];
                            }

                            // Â∞ùËØï‰ªéÊúçÂä°Âô®Âä†ËΩΩÂÆåÊï¥ÁöÑÊ∂àÊÅØÊï∞ÊçÆÔºàÂåÖÊã¨ screenshotsÔºâ
                            // ËøôÊ†∑ÂèØ‰ª•Á°Æ‰øùÊúçÂä°ÈáçÂêØÂêé‰πüËÉΩÁúãÂà∞Êà™Âõæ
                            try {
                                // Âú®Âä†ËΩΩÊúçÂä°Âô®Êï∞ÊçÆÂâçÔºåÂÖà‰øùÂ≠òÊú¨Âú∞Ê∂àÊÅØÁöÑÁä∂ÊÄÅÂíå todoListÔºàÊúçÂä°Âô®‰∏ç‰øùÂ≠òËøô‰∫õÂ≠óÊÆµÔºâ
                                const localDataMap = {};
                                if (chatMessages.value && chatMessages.value.length > 0) {
                                    chatMessages.value.forEach(msg => {
                                        if (msg.id) {
                                            localDataMap[msg.id] = {
                                                status: msg.status,
                                                todoList: msg.todoList,
                                                currentTodoIndex: msg.currentTodoIndex,
                                                logs: msg.logs || []  // ‰πü‰øùÂ≠òÊú¨Âú∞Êó•Âøó‰Ωú‰∏∫ÂêéÂ§á
                                            };
                                        }
                                    });
                                }

                                const detailData = await apiCall(`/api/chat/sessions/${mostRecent.id}/detail`);
                                if (detailData && detailData.messages) {
                                    // ‰ΩøÁî®ÊúçÂä°Âô®ÁöÑÊ∂àÊÅØÊï∞ÊçÆÔºàÊõ¥ÂÆåÊï¥ÔºåÂåÖÂê´ screenshotsÔºâ
                                    chatMessages.value = detailData.messages.map(msg => {
                                        const localData = localDataMap[msg.id] || {};
                                        // ‰ºòÂÖà‰ΩøÁî®ÊúçÂä°Âô®Áä∂ÊÄÅÔºåÂÖ∂Ê¨°‰ΩøÁî®Êú¨Âú∞‰øùÂ≠òÁöÑÁä∂ÊÄÅÔºåÊúÄÂêéÈªòËÆ§ success
                                        let status = null;
                                        let todoList = null;
                                        if (msg.role === 'assistant') {
                                            // ÊúçÂä°Âô®Áé∞Âú®ÂèØËÉΩËøîÂõû status Âíå todo_list
                                            status = msg.status || localData.status || 'success';
                                            // todo_list ‰ªéÊúçÂä°Âô®ËøîÂõûÔºàÂ¶ÇÊûúÊúâÔºâÔºåÂê¶Âàô‰ΩøÁî®Êú¨Âú∞
                                            todoList = msg.todo_list || localData.todoList || null;
                                        }

                                        // Êó•ÂøóÔºö‰ºòÂÖà‰ΩøÁî®ÊúçÂä°Âô®Êó•ÂøóÔºàÊõ¥ÂÆåÊï¥ÔºâÔºåÂ¶ÇÊûúÊúçÂä°Âô®Ê≤°ÊúâÂàôÁî®Êú¨Âú∞
                                        let logs = [];
                                        if (msg.logs && msg.logs.length > 0) {
                                            logs = msg.logs.map(l => l.content || l);
                                        } else if (localData.logs && localData.logs.length > 0) {
                                            logs = localData.logs;
                                        }

                                        return {
                                            id: msg.id,
                                            role: msg.role,
                                            content: msg.content,
                                            timestamp: msg.created_at,
                                            logs: logs,
                                            screenshots: msg.screenshots || [],
                                            status: status,
                                            // ‰ºòÂÖà‰ΩøÁî®ÊúçÂä°Âô®ÁöÑ todoListÔºåÂÖ∂Ê¨°ÊòØÊú¨Âú∞Êï∞ÊçÆ
                                            todoList: todoList,
                                            currentTodoIndex: localData.currentTodoIndex
                                        };
                                    });

                                    // Êõ¥Êñ∞‰ºöËØù‰∏≠ÁöÑÊ∂àÊÅØÊï∞ÊçÆ
                                    mostRecent.messages = chatMessages.value;
                                    saveSessions();
                                }
                            } catch (error) {
                                // Â¶ÇÊûú‰ºöËØù‰∏çÂ≠òÂú®Ôºà404ÔºâÔºå‰ªéÂàóË°®‰∏≠ÁßªÈô§
                                if (error.message && error.message.includes('Session not found')) {
                                    console.warn(`Session ${mostRecent.id} not found, removing from list`);
                                    const index = chatSessions.value.findIndex(s => s.id === mostRecent.id);
                                    if (index !== -1) {
                                        chatSessions.value.splice(index, 1);
                                        saveSessions();

                                        // Â¶ÇÊûúÊúâÂÖ∂‰ªñ‰ºöËØùÔºåÂàáÊç¢Âà∞‰∏ã‰∏Ä‰∏™
                                        if (chatSessions.value.length > 0) {
                                            await switchSession(chatSessions.value[0].id);
                                            return;
                                        } else {
                                            createNewSession();
                                            return;
                                        }
                                    }
                                } else {
                                    console.error('Failed to load session detail from server:', error);
                                    // ÁªßÁª≠‰ΩøÁî®Êú¨Âú∞Êï∞ÊçÆ
                                }
                            }

                            // ‰øÆÂ§çÂà∑Êñ∞Âêé running Áä∂ÊÄÅÁöÑÊ∂àÊÅØÔºöÂÖàÊ£ÄÊü•ÊúçÂä°Âô®‰ªªÂä°Áä∂ÊÄÅ
                            // Â¶ÇÊûú‰ªªÂä°Á°ÆÂÆûËøòÂú®ËøêË°åÔºå‰øùÊåÅ running Áä∂ÊÄÅÔºõÂê¶ÂàôÊîπ‰∏∫Â∑≤ÂÆåÊàêÁä∂ÊÄÅ
                            try {
                                const taskStatus = await apiCall('/api/tasks/status');
                                const isServerTaskRunning = taskStatus && taskStatus.running;

                                chatMessages.value.forEach(msg => {
                                    if (msg.role === 'assistant' && msg.status === 'running') {
                                        if (isServerTaskRunning) {
                                            // ÊúçÂä°Âô®‰ªªÂä°ËøòÂú®ËøêË°åÔºå‰øùÊåÅ running Áä∂ÊÄÅ
                                            // ÊÅ¢Â§ç chatRunning Áä∂ÊÄÅ‰ª•‰æøÁªßÁª≠Êé•Êî∂Êó•ÂøóÊõ¥Êñ∞
                                            chatRunning.value = true;
                                            console.log('[Âà∑Êñ∞ÊÅ¢Â§ç] Ê£ÄÊµãÂà∞‰ªªÂä°‰ªçÂú®ËøêË°åÔºå‰øùÊåÅ running Áä∂ÊÄÅ');
                                        } else {
                                            // ÊúçÂä°Âô®‰ªªÂä°Â∑≤ÁªìÊùüÔºåÂ∞ÜÁä∂ÊÄÅÊîπ‰∏∫Â∑≤ÂÆåÊàê
                                            msg.status = 'success';
                                            msg.content = msg.content || '‰ªªÂä°ÊâßË°åÂÆåÊàêÔºÅ';
                                        }
                                    }

                                    // ‰øÆÂ§ç todoList Â≠ê‰ªªÂä°ÁöÑËøáÊúü running/pending Áä∂ÊÄÅ
                                    if (msg.todoList && msg.todoList.length > 0 && !isServerTaskRunning) {
                                        msg.todoList.forEach(todo => {
                                            if (todo.status === 'running' || todo.status === 'pending') {
                                                todo.status = 'failed';
                                                console.log('[Âà∑Êñ∞ÊÅ¢Â§ç] Â∞ÜËøáÊúüÁöÑÂ≠ê‰ªªÂä°Áä∂ÊÄÅÊîπ‰∏∫ failed:', todo.content);
                                            }
                                        });
                                    }
                                });
                            } catch (statusError) {
                                console.error('Failed to check task status:', statusError);
                                // Ê£ÄÊü•Â§±Ë¥•Êó∂Ôºå‰øùÂÆàÂ§ÑÁêÜÔºöÂÅáËÆæ‰ªªÂä°Â∑≤ÂÆåÊàê
                                chatMessages.value.forEach(msg => {
                                    if (msg.role === 'assistant' && msg.status === 'running') {
                                        msg.status = 'success';
                                        msg.content = msg.content || '‰ªªÂä°ÊâßË°åÂÆåÊàêÔºÅ';
                                    }
                                    // ÂêåÊ†∑‰øÆÂ§ç todoList Â≠ê‰ªªÂä°Áä∂ÊÄÅ
                                    if (msg.todoList && msg.todoList.length > 0) {
                                        msg.todoList.forEach(todo => {
                                            if (todo.status === 'running' || todo.status === 'pending') {
                                                todo.status = 'failed';
                                            }
                                        });
                                    }
                                });
                            }
                            // ‰øùÂ≠ò‰øÆÂ§çÂêéÁöÑÁä∂ÊÄÅ
                            saveCurrentSession();
                            // È°µÈù¢Âä†ËΩΩÂêéËá™Âä®ÊªöÂä®Âà∞ÊúÄÊñ∞Ê∂àÊÅØ
                            Vue.nextTick(() => {
                                scrollChatToBottom();
                            });
                        } else {
                            createNewSession();
                        }
                    }

                    // Chat functions
                    function scrollChatToBottom() {
                        setTimeout(() => {
                            if (chatMessagesRef.value) {
                                chatMessagesRef.value.scrollTop = chatMessagesRef.value.scrollHeight;
                            }
                        }, 50);
                    }

                    function onChatDeviceChange() {
                        // Auto-select device for preview too
                        if (chatDeviceId.value && !previewDeviceId.value) {
                            previewDeviceId.value = chatDeviceId.value;
                        }
                    }

                    function adjustChatInputHeight(e) {
                        const el = e.target;
                        el.style.height = 'auto';
                        el.style.height = Math.min(el.scrollHeight, 100) + 'px';
                    }

                    // ÁõëÂê¨ËæìÂÖ•ÂÜÖÂÆπÂèòÂåñÔºåËá™Âä®Ë∞ÉÊï¥È´òÂ∫¶
                    watch(chatInput, () => {
                        Vue.nextTick(() => {
                            const el = document.querySelector('.chat-input');
                            if (el) {
                                el.style.height = 'auto';
                                // Â¶ÇÊûúÂÜÖÂÆπ‰∏∫Á©∫ÔºåÈáçÁΩÆ‰∏∫ÂàùÂßãÈ´òÂ∫¶ÔºàÈÄöËøá rows Â±ûÊÄßÊéßÂà∂Ôºâ
                                if (!chatInput.value) {
                                    el.style.height = '';
                                } else {
                                    el.style.height = Math.min(el.scrollHeight, 100) + 'px';
                                }
                            }
                        });
                    });

                    // Retry a previous message
                    function retryMessage(content) {
                        if (chatRunning.value) return;
                        chatInput.value = content;
                        sendChatMessage();
                    }

                    const isSkipping = ref(false);

                    async function skipSubtask(msg) {
                        if (!chatRunning.value) return;
                        if (confirm('Á°ÆÂÆöË¶ÅË∑≥ËøáÂΩìÂâçÂ≠ê‰ªªÂä°ÂêóÔºü(Â∞ÜÂÅúÊ≠¢ÂΩìÂâçÊìç‰ΩúÂπ∂ËøõÂÖ•‰∏ã‰∏ÄÊ≠•)')) {
                            isSkipping.value = true;
                            // Âº∫Âà∂ÂÅúÊ≠¢ÂΩìÂâç‰ªªÂä°
                            await apiCall('/api/tasks/stop', { method: 'POST' });
                        }
                    }

                    // TodoList Confirmation Functions
                    async function confirmTodoList(msg) {
                        if (!msg.todoList || msg.todoList.length === 0) {
                            showToast('‰ªªÂä°Ê∏ÖÂçï‰∏∫Á©∫', 'error');
                            return;
                        }

                        // Validate all subtasks have content
                        const emptyTask = msg.todoList.find(item => !item.content || !item.content.trim());
                        if (emptyTask) {
                            showToast('ËØ∑Â°´ÂÜôÊâÄÊúâÂ≠ê‰ªªÂä°ÂÜÖÂÆπ', 'error');
                            return;
                        }

                        // Update message status
                        msg.status = 'running';
                        msg.content = 'üìã ÂºÄÂßãÊâßË°å‰ªªÂä°Ê∏ÖÂçï...';
                        awaitingTodoListConfirmation.value = false;
                        chatRunning.value = true;

                        // Save changes
                        saveCurrentSession();
                        scrollChatToBottom();

                        // Continue with task execution
                        try {
                            // Execute the confirmed todoList
                            await executeConfirmedTodoList(msg);
                        } catch (error) {
                            console.error('Task execution error:', error);
                            msg.status = 'error';
                            msg.content = `‚ùå ÊâßË°åÂ§±Ë¥•: ${error.message}`;
                            chatRunning.value = false;
                            saveCurrentSession();
                        }
                    }

                    function cancelTodoList(msg) {
                        if (!confirm('Á°ÆÂÆöË¶ÅÂèñÊ∂àÊ≠§‰ªªÂä°ÂêóÔºü')) {
                            return;
                        }

                        msg.status = 'cancelled';
                        msg.content = '‚ùå ‰ªªÂä°Â∑≤ÂèñÊ∂à';
                        awaitingTodoListConfirmation.value = false;
                        chatRunning.value = false;
                        saveCurrentSession();
                        scrollChatToBottom();
                    }

                    // TodoList Management Functions
                    function moveTodoUp(msg, index) {
                        if (index === 0) return;
                        const temp = msg.todoList[index];
                        msg.todoList[index] = msg.todoList[index - 1];
                        msg.todoList[index - 1] = temp;
                        saveCurrentSession();
                    }

                    function moveTodoDown(msg, index) {
                        if (index === msg.todoList.length - 1) return;
                        const temp = msg.todoList[index];
                        msg.todoList[index] = msg.todoList[index + 1];
                        msg.todoList[index + 1] = temp;
                        saveCurrentSession();
                    }

                    function deleteTodo(msg, index) {
                        if (msg.todoList.length <= 1) {
                            showToast('Ëá≥Â∞ëÈúÄË¶Å‰øùÁïô‰∏Ä‰∏™Â≠ê‰ªªÂä°', 'error');
                            return;
                        }
                        if (confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§Â≠ê‰ªªÂä°"${msg.todoList[index].content}"ÂêóÔºü`)) {
                            msg.todoList.splice(index, 1);
                            saveCurrentSession();
                        }
                    }

                    function autoResizeTextarea(event) {
                        const textarea = event.target;
                        textarea.style.height = 'auto';
                        textarea.style.height = textarea.scrollHeight + 'px';
                    }

                    async function executeConfirmedTodoList(msg) {
                        // This function continues the execution flow that was paused
                        // It should follow the same logic as the normal complex task execution

                        // Check if there's a running task and handle priority
                        const status = await apiCall('/api/tasks/status');
                        if (status.running && status.task) {
                            const currentTaskType = status.task.task_type || 'manual';
                            const currentTaskContent = status.task.task_content || 'Êú™Áü•‰ªªÂä°';
                            const typeNames = { 'manual': 'ÊâãÂä®‰ªªÂä°', 'scheduled': 'ÂÆöÊó∂‰ªªÂä°', 'chat': 'Chat‰ªªÂä°' };
                            const typeName = typeNames[currentTaskType] || 'Êú™Áü•‰ªªÂä°';

                            if (currentTaskType !== 'chat') {
                                msg.content = `‚ö†Ô∏è Ê≠£Âú®ÊâìÊñ≠${typeName}: ${currentTaskContent.substring(0, 30)}...`;
                                saveCurrentSession();
                                await apiCall('/api/tasks/stop', { method: 'POST' });
                                await new Promise(resolve => setTimeout(resolve, 1500));
                            } else {
                                // Another chat task is running, wait for it
                                let waitAttempts = 0;
                                const maxWaitAttempts = 60;
                                while (waitAttempts < maxWaitAttempts) {
                                    const checkStatus = await apiCall('/api/tasks/status');
                                    if (!checkStatus.running) break;
                                    await new Promise(resolve => setTimeout(resolve, 1000));
                                    waitAttempts++;
                                }
                            }
                        }

                        // Execute subtasks sequentially
                        let initialLockState = null;  // Will be set after first subtask
                        for (let i = 0; i < msg.todoList.length; i++) {
                            const item = msg.todoList[i];
                            item.status = 'running';
                            msg.currentTodoIndex = i;
                            saveCurrentSession();
                            scrollChatToBottom();

                            // Start countdown timer
                            subtaskCountdown.value = subtaskTimeoutSeconds.value;
                            subtaskCountdownTimer = setInterval(() => {
                                if (subtaskCountdown.value > 0) {
                                    subtaskCountdown.value--;
                                } else {
                                    clearInterval(subtaskCountdownTimer);
                                }
                            }, 1000);

                            // Execute subtask via tasks/run API
                            // Only prevent auto-lock for non-final subtasks
                            const isLastSubtask = (i === msg.todoList.length - 1);
                            const isFirstSubtask = (i === 0);

                            console.log(`üîç [SUBTASK ${i + 1}/${msg.todoList.length}] isFirst: ${isFirstSubtask}, isLast: ${isLastSubtask}, initialLockState: ${initialLockState}`);

                            const requestBody = {
                                device_ids: [chatDeviceId.value],
                                task_content: item.content,
                                task_type: 'chat',
                                debug_mode: debugMode.value,
                                send_email: false,
                                no_auto_lock: !isLastSubtask,  // Only prevent lock between subtasks
                                session_id: currentSessionId.value,
                                message_id: msg.id
                            };

                            // For non-first subtasks, explicitly pass the initial lock state
                            if (!isFirstSubtask && initialLockState !== null) {
                                requestBody.restore_lock_to_state = initialLockState;
                                console.log(`üîê Passing initial lock state to subtask ${i + 1}: ${initialLockState}`);
                            }

                            const runResponse = await apiCall('/api/tasks/run', {
                                method: 'POST',
                                body: JSON.stringify(requestBody)
                            });

                            // For first subtask, immediately check status to get initial_lock_state
                            if (isFirstSubtask) {
                                await new Promise(resolve => setTimeout(resolve, 500)); // Short wait for task to initialize
                                const initialStatusCheck = await apiCall('/api/tasks/status');
                                console.log(`üîç Initial status check:`, initialStatusCheck);
                                if (initialStatusCheck.task && initialStatusCheck.task.initial_lock_state !== undefined) {
                                    initialLockState = initialStatusCheck.task.initial_lock_state;
                                    console.log(`üîê Got initial lock state immediately after start: ${initialLockState}`);
                                } else {
                                    console.warn(`‚ö†Ô∏è initial_lock_state not found in task:`, initialStatusCheck.task);
                                }
                            }

                            // Poll for task completion
                            let taskSuccess = false;
                            let pollAttempts = 0;
                            const maxPollAttempts = subtaskTimeoutSeconds.value;

                            while (pollAttempts < maxPollAttempts) {
                                const statusCheck = await apiCall('/api/tasks/status');

                                // For first subtask, try to get initial lock state from current task (while running)
                                if (isFirstSubtask && initialLockState === null && statusCheck.task && statusCheck.task.initial_lock_state !== undefined) {
                                    initialLockState = statusCheck.task.initial_lock_state;
                                    console.log(`üîê Got initial lock state from task (polling): ${initialLockState}`);
                                }

                                if (!statusCheck.running) {
                                    // Task completed - assume success (errors would throw exceptions)
                                    taskSuccess = true;
                                    break;
                                }

                                // Check if skip requested
                                if (isSkipping.value) {
                                    await apiCall('/api/tasks/stop', { method: 'POST' });
                                    break;
                                }

                                await new Promise(resolve => setTimeout(resolve, 1000));
                                pollAttempts++;
                            }

                            await new Promise(resolve => setTimeout(resolve, 1000));
                            // Clear countdown timer
                            clearInterval(subtaskCountdownTimer);
                            subtaskCountdown.value = 0;

                            // Update subtask status
                            if (isSkipping.value) {
                                item.status = 'skipped';
                                isSkipping.value = false;
                                // Skip remaining tasks
                                for (let j = i + 1; j < msg.todoList.length; j++) {
                                    msg.todoList[j].status = 'skipped';
                                }
                                break;
                            } else if (taskSuccess) {
                                item.status = 'completed';
                            } else {
                                item.status = 'failed';
                                msg.content = `‚ùå Â≠ê‰ªªÂä°Â§±Ë¥•: ${item.content}`;
                                msg.status = 'error';
                                chatRunning.value = false;
                                saveCurrentSession();
                                return;
                            }

                            saveCurrentSession();
                        }

                        // All subtasks completed
                        const allCompleted = msg.todoList.every(t => t.status === 'completed');
                        if (allCompleted) {
                            msg.content = '‚úÖ ÊâÄÊúâÂ≠ê‰ªªÂä°Â∑≤ÂÆåÊàê';
                            msg.status = 'success';
                        } else {
                            msg.content = '‚ö†Ô∏è ÈÉ®ÂàÜ‰ªªÂä°Â∑≤Ë∑≥Ëøá';
                            msg.status = 'success';
                        }
                        chatRunning.value = false;
                        saveCurrentSession();
                        scrollChatToBottom();
                    }

                    // Tap preview functions (debug mode)
                    function confirmTapPreview() {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'tap_preview_response',
                                request_id: tapPreviewData.value.requestId,
                                proceed: true,
                                x: tapPreviewAdjustedX.value,
                                y: tapPreviewAdjustedY.value
                            }));
                        }
                        showTapPreview.value = false;
                    }

                    function cancelTapPreview() {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'tap_preview_response',
                                request_id: tapPreviewData.value.requestId,
                                proceed: false,
                                x: tapPreviewData.value.x,
                                y: tapPreviewData.value.y
                            }));
                        }
                        showTapPreview.value = false;
                    }

                    function handleTapPreviewClick(event) {
                        const rect = event.currentTarget.getBoundingClientRect();
                        const x = event.clientX - rect.left;
                        const y = event.clientY - rect.top;

                        // Convert to device coordinates
                        const scaleX = tapPreviewData.value.width / rect.width;
                        const scaleY = tapPreviewData.value.height / rect.height;

                        tapPreviewAdjustedX.value = Math.round(x * scaleX);
                        tapPreviewAdjustedY.value = Math.round(y * scaleY);
                    }

                    async function sendChatMessage() {
                        const content = chatInput.value.trim();
                        if (!content || !chatDeviceId.value || chatRunning.value) return;

                        // Á°Æ‰øùÊúâ‰ºöËØùÂ≠òÂú®ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÂàõÂª∫
                        if (!currentSessionId.value) {
                            await createNewSession();
                        }

                        // ÂêåÊ≠•‰ºöËØùÂà∞ÊúçÂä°Âô®ÔºàÂ¶ÇÊûú‰ºöËØùIDÊòØÊú¨Âú∞ÁîüÊàêÁöÑÔºåÈúÄË¶ÅÂú®ÊúçÂä°Âô®ÂàõÂª∫Ôºâ
                        let serverSessionId = currentSessionId.value;
                        let serverMessageId = null;

                        // Â∞ùËØïÂ∞ÜÊ∂àÊÅØ‰øùÂ≠òÂà∞ÊúçÂä°Âô®
                        try {
                            // Ê£ÄÊü•‰ºöËØùÊòØÂê¶Â≠òÂú®‰∫éÊúçÂä°Âô®
                            const sessionCheck = await apiCall(`/api/chat/sessions/${currentSessionId.value}`).catch(() => null);

                            if (!sessionCheck) {
                                // ‰ºöËØù‰∏çÂ≠òÂú®ÔºåÂú®ÊúçÂä°Âô®ÂàõÂª∫
                                const newSession = await apiCall('/api/chat/sessions', {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        device_id: chatDeviceId.value,
                                        title: content.substring(0, 30) + (content.length > 30 ? '...' : '')
                                    })
                                });
                                serverSessionId = newSession.id;

                                // Êõ¥Êñ∞Êú¨Âú∞‰ºöËØùID
                                const oldSessionId = currentSessionId.value;
                                currentSessionId.value = serverSessionId;
                                const localSession = chatSessions.value.find(s => s.id === oldSessionId);
                                if (localSession) {
                                    localSession.id = serverSessionId;
                                }
                                saveSessions();
                            }

                            // Âú®ÊúçÂä°Âô®Ê∑ªÂä†Áî®Êà∑Ê∂àÊÅØ
                            const userMsgResult = await apiCall(`/api/chat/sessions/${serverSessionId}/messages`, {
                                method: 'POST',
                                body: JSON.stringify({
                                    role: 'user',
                                    content: content
                                })
                            });

                            // Âú®ÊúçÂä°Âô®Ê∑ªÂä†Âä©ÊâãÊ∂àÊÅØÂç†‰ΩçÁ¨¶
                            const assistantMsgResult = await apiCall(`/api/chat/sessions/${serverSessionId}/messages`, {
                                method: 'POST',
                                body: JSON.stringify({
                                    role: 'assistant',
                                    content: 'ÊâßË°å‰∏≠...'
                                })
                            });
                            serverMessageId = assistantMsgResult.id;
                        } catch (error) {
                            console.error('Failed to sync messages to server:', error);
                            // ÁªßÁª≠ÊâßË°åÔºå‰ΩÜÊó†Ê≥ï‰øùÂ≠òÊà™ÂõæÂà∞Êï∞ÊçÆÂ∫ì
                        }

                        // Add user message to local state
                        chatMessages.value.push({
                            role: 'user',
                            content: content,
                            timestamp: new Date().toISOString()
                        });

                        // Clear input
                        chatInput.value = '';

                        // Add assistant message (running state)
                        const assistantMsg = {
                            id: serverMessageId,  // ÊúçÂä°Âô®Ê∂àÊÅØIDÔºåÁî®‰∫éÁªëÂÆöÊà™Âõæ
                            role: 'assistant',
                            content: '',
                            status: 'running',
                            logs: [],
                            screenshots: [],  // ‰ΩøÁî® screenshots Êï∞ÁªÑËÄå‰∏çÊòØ screenshot
                            timestamp: new Date().toISOString(),
                            todoList: null,  // Â§çÊùÇ‰ªªÂä°Ê®°Âºè‰∏ãÁöÑtodoList
                            tokens: 0,
                            taskId: null  // ÂÖ≥ËÅîÁöÑ‰ªªÂä°IDÔºåÁî®‰∫éÂåπÈÖçWebSocket‰∫ã‰ª∂
                        };
                        chatMessages.value.push(assistantMsg);

                        scrollChatToBottom();
                        chatRunning.value = true;

                        try {
                            // Â§çÊùÇ‰ªªÂä°Ê®°ÂºèÔºöÂÖàÊãÜËß£‰ªªÂä°
                            if (complexTaskMode.value) {
                                assistantMsg.content = 'üß© Ê≠£Âú®ÂàÜÊûê‰ªªÂä°...';
                                saveCurrentSession();

                                // Ë∞ÉÁî®‰ªªÂä°ÊãÜËß£API
                                const decomposeResult = await apiCall('/api/tasks/decompose', {
                                    method: 'POST',
                                    body: JSON.stringify({ task_content: content }),
                                });

                                if (decomposeResult.success && decomposeResult.todoList) {
                                    // ÂàùÂßãÂåñtodoListÔºåÊâÄÊúâ‰ªªÂä°Áä∂ÊÄÅ‰∏∫pendingÔºåÊØè‰∏™Â≠ê‰ªªÂä°ÊúâÁã¨Á´ãÁöÑlogsÊï∞ÁªÑ
                                    assistantMsg.todoList = decomposeResult.todoList.map(item => ({
                                        content: item.content,
                                        status: 'pending',
                                        logs: []  // ÊØè‰∏™Â≠ê‰ªªÂä°Áã¨Á´ãÁöÑÊó•ÂøóÊï∞ÁªÑ
                                    }));
                                    assistantMsg.tokens = decomposeResult.tokens || 0;
                                    assistantMsg.currentTodoIndex = -1;  // Áî®‰∫éË∑üË∏™ÂΩìÂâçÊâßË°åÁöÑÂ≠ê‰ªªÂä°Á¥¢Âºï

                                    // üÜï NEW: Check if both debug and complex modes are enabled
                                    if (debugMode.value) {
                                        // Pause for user confirmation
                                        assistantMsg.status = 'pending_confirmation';
                                        assistantMsg.content = 'üìã ‰ªªÂä°Â∑≤ÊãÜËß£‰∏∫‰ª•‰∏ãÊ∏ÖÂçïÔºåËØ∑Á°ÆËÆ§Ôºö';
                                        awaitingTodoListConfirmation.value = true;
                                        chatRunning.value = false;  // Stop "running" indicator
                                        saveCurrentSession();
                                        scrollChatToBottom();
                                        return;  // üõë PAUSE HERE - Wait for user confirmation
                                    }

                                    // Original flow (no confirmation needed)
                                    assistantMsg.content = 'üìã ‰ªªÂä°Â∑≤ÊãÜËß£ÔºåÂáÜÂ§áÊâßË°å...';
                                    saveCurrentSession();
                                    scrollChatToBottom();

                                    // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖ∂‰ªñ‰ªªÂä°Âú®ËøêË°å
                                    const status = await apiCall('/api/tasks/status');
                                    if (status.running && status.task) {
                                        // Êúâ‰ªªÂä°Âú®ËøêË°åÔºåChat‰ªªÂä°‰ºòÂÖàÁ∫ßÊúÄÈ´òÔºåÁõ¥Êé•ÊâìÊñ≠
                                        const currentTaskType = status.task.task_type || 'manual';
                                        const currentTaskContent = status.task.task_content || 'Êú™Áü•‰ªªÂä°';
                                        const typeNames = { 'manual': 'ÊâãÂä®‰ªªÂä°', 'scheduled': 'ÂÆöÊó∂‰ªªÂä°', 'chat': 'Chat‰ªªÂä°' };
                                        const typeName = typeNames[currentTaskType] || 'Êú™Áü•‰ªªÂä°';

                                        // Chat‰ªªÂä°ÂèØ‰ª•ÊâìÊñ≠ÂÖ∂‰ªñÁ±ªÂûãÁöÑ‰ªªÂä°
                                        if (currentTaskType !== 'chat') {
                                            assistantMsg.content = `‚ö†Ô∏è Ê≠£Âú®ÊâìÊñ≠${typeName}: ${currentTaskContent.substring(0, 30)}...`;
                                            saveCurrentSession();
                                            // Âº∫Âà∂ÂÅúÊ≠¢ÂΩìÂâç‰ªªÂä°
                                            await apiCall('/api/tasks/stop', { method: 'POST' });
                                            // Á≠âÂæÖ‰ªªÂä°ÂÅúÊ≠¢
                                            await new Promise(resolve => setTimeout(resolve, 1500));
                                        } else {
                                            // Âè¶‰∏Ä‰∏™Chat‰ªªÂä°Ê≠£Âú®ËøêË°åÔºåÈúÄË¶ÅÁ≠âÂæÖ
                                            let waitAttempts = 0;
                                            const maxWaitAttempts = 60;
                                            while (waitAttempts < maxWaitAttempts) {
                                                const checkStatus = await apiCall('/api/tasks/status');
                                                if (!checkStatus.running) break;
                                                assistantMsg.content = `‚è≥ Á≠âÂæÖÂÖ∂‰ªñChat‰ªªÂä°ÂÆåÊàê... (${waitAttempts + 1}s)`;
                                                saveCurrentSession();
                                                await new Promise(resolve => setTimeout(resolve, 1000));
                                                waitAttempts++;
                                                if (!chatRunning.value) throw new Error('Áî®Êà∑ÂèñÊ∂à‰∫Ü‰ªªÂä°');
                                            }
                                            if (waitAttempts >= maxWaitAttempts) {
                                                throw new Error('Á≠âÂæÖË∂ÖÊó∂ÔºåÂÖ∂‰ªñ‰ªªÂä°‰ªçÂú®ËøêË°å');
                                            }
                                        }
                                    }

                                    assistantMsg.content = 'üìã ÂºÄÂßãÈÄê‰∏™ÊâßË°åÂ≠ê‰ªªÂä°...';
                                    saveCurrentSession();

                                    // ÈÄê‰∏™ÊâßË°åÂ≠ê‰ªªÂä°
                                    let allSuccess = true;
                                    const totalTasks = assistantMsg.todoList.length;

                                    for (let i = 0; i < totalTasks; i++) {
                                        // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶ÂÅúÊ≠¢‰∫Ü‰ªªÂä°
                                        if (!chatRunning.value) {
                                            console.log(`[Â≠ê‰ªªÂä° ${i + 1}/${totalTasks}] Áî®Êà∑ÂÅúÊ≠¢‰∫Ü‰ªªÂä°`);
                                            // Â∞ÜÂΩìÂâçÂíåÂâ©‰Ωô‰ªªÂä°Ê†áËÆ∞‰∏∫Â§±Ë¥•
                                            for (let j = i; j < totalTasks; j++) {
                                                if (assistantMsg.todoList[j].status === 'pending' || assistantMsg.todoList[j].status === 'running') {
                                                    assistantMsg.todoList[j].status = 'failed';
                                                }
                                            }
                                            allSuccess = false;
                                            break;
                                        }

                                        const todoItem = assistantMsg.todoList[i];
                                        const maxRetries = 2;  // ÊúÄÂ§öÈáçËØï2Ê¨°
                                        let retryCount = 0;
                                        let subtaskSuccess = false;
                                        let skipRetry = false;  // Ë∂ÖÊó∂Âêé‰∏çÈáçËØï

                                        // ÈáçËØïÂæ™ÁéØÔºàË∂ÖÊó∂Âêé‰∏çÈáçËØïÔºâ
                                        while (retryCount <= maxRetries && !subtaskSuccess && !skipRetry) {
                                            if (retryCount > 0) {
                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}/${totalTasks}] ÈáçËØïÁ¨¨ ${retryCount} Ê¨°...`);
                                                assistantMsg.content = `üîÑ ÈáçËØïÂ≠ê‰ªªÂä° (${retryCount}/${maxRetries}): ${todoItem.content} (${i + 1}/${totalTasks})`;
                                                saveCurrentSession();
                                                // ÈáçËØïÂâçÁ≠âÂæÖ‰∏Ä‰∏ã
                                                await new Promise(resolve => setTimeout(resolve, 2000));
                                            }

                                            todoItem.status = 'running';
                                            assistantMsg.currentTodoIndex = i;  // ËÆæÁΩÆÂΩìÂâçÊâßË°åÁöÑÂ≠ê‰ªªÂä°Á¥¢Âºï
                                            if (retryCount === 0) {
                                                assistantMsg.content = `üîÑ Ê≠£Âú®ÊâßË°å: ${todoItem.content} (${i + 1}/${totalTasks})`;
                                            }
                                            saveCurrentSession();
                                            scrollChatToBottom();

                                            // ÂêØÂä®ÂÄíËÆ°Êó∂ÂÆöÊó∂Âô®
                                            const countdownStartTime = Date.now();
                                            subtaskCountdown.value = subtaskTimeoutSeconds.value;
                                            if (subtaskCountdownTimer) clearInterval(subtaskCountdownTimer);
                                            subtaskCountdownTimer = setInterval(() => {
                                                const elapsed = Math.floor((Date.now() - countdownStartTime) / 1000);
                                                subtaskCountdown.value = Math.max(0, subtaskTimeoutSeconds.value - elapsed);
                                            }, 1000);

                                            try {
                                                // ÊâßË°åÂçï‰∏™Â≠ê‰ªªÂä°
                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}/${totalTasks}] ÂºÄÂßãÊâßË°å (Â∞ùËØï ${retryCount + 1}):`, todoItem.content);

                                                // ÂÖàÁ≠âÂæÖ‰∏Ä‰∏ãÁ°Æ‰øùÂâç‰∏Ä‰∏™‰ªªÂä°ÂÆåÂÖ®Ê∏ÖÁêÜ
                                                if (i > 0 || retryCount > 0) {
                                                    console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Á≠âÂæÖ‰ªªÂä°Ê∏ÖÁêÜ...`);
                                                    await new Promise(resolve => setTimeout(resolve, 1500));
                                                }

                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Ë∞ÉÁî® /api/tasks/run...`);
                                                const runResult = await apiCall('/api/tasks/run', {
                                                    method: 'POST',
                                                    body: JSON.stringify({
                                                        task_content: todoItem.content,
                                                        device_ids: [chatDeviceId.value],
                                                        send_email: false,  // Â≠ê‰ªªÂä°‰∏çÂèëÈÇÆ‰ª∂
                                                        no_auto_lock: true,  // ÊâÄÊúâÂ≠ê‰ªªÂä°ÈÉΩ‰∏çËá™Âä®ÈîÅÂ±èÔºåÊúÄÂêéÁªü‰∏ÄÂ§ÑÁêÜ
                                                        task_type: "chat",  // Ê†áËÆ∞‰∏∫ chat ‰ªªÂä°ÔºåÈÅøÂÖçÊó•ÂøóÂá∫Áé∞Âú® Run Task È°µÈù¢
                                                        session_id: serverSessionId,  // ‰º†ÈÄí‰ºöËØùID
                                                        message_id: serverMessageId,  // ‰º†ÈÄíÊ∂àÊÅØID
                                                        debug_mode: debugMode.value,  // Ë∞ÉËØïÊ®°Âºè
                                                    }),
                                                });
                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}] run Ë∞ÉÁî®ÊàêÂäü:`, runResult);

                                                // Á≠âÂæÖ‰ªªÂä°ÂÆåÊàêÔºàÈÄöËøáËΩÆËØ¢Áä∂ÊÄÅÔºâ
                                                let taskCompleted = false;
                                                let attempts = 0;
                                                const maxAttempts = 600;  // ÊúÄÂ§öÁ≠â10ÂàÜÈíü (600 * 1000ms)ÔºåÂÆûÈôÖÁî±Ë∂ÖÊó∂ËÆæÁΩÆÊéßÂà∂
                                                const subtaskStartTime = Date.now();  // ËÆ∞ÂΩïÂ≠ê‰ªªÂä°ÂºÄÂßãÊó∂Èó¥

                                                while (!taskCompleted && attempts < maxAttempts) {
                                                    // ÊØèÊ¨°ËΩÆËØ¢ÂâçÊ£ÄÊü•Áî®Êà∑ÊòØÂê¶ÂÅúÊ≠¢‰∫Ü‰ªªÂä°
                                                    if (!chatRunning.value) {
                                                        console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ËΩÆËØ¢‰∏≠Ê£ÄÊµãÂà∞Áî®Êà∑ÂÅúÊ≠¢`);
                                                        todoItem.status = 'failed';
                                                        break;
                                                    }

                                                    // Ê£ÄÊü•ÊòØÂê¶Ë∂ÖÊó∂
                                                    const elapsedSeconds = (Date.now() - subtaskStartTime) / 1000;
                                                    if (elapsedSeconds > subtaskTimeoutSeconds.value) {
                                                        console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Ë∂ÖÊó∂ (${elapsedSeconds.toFixed(0)}s > ${subtaskTimeoutSeconds.value}s)`);
                                                        todoItem.status = 'failed';
                                                        todoItem.logs.push(`‚è∞ Ë∂ÖÊó∂ (${subtaskTimeoutSeconds.value}Áßí)`);
                                                        // Âº∫Âà∂ÂÅúÊ≠¢ÂΩìÂâçËøêË°åÁöÑ‰ªªÂä°
                                                        await apiCall('/api/tasks/stop', { method: 'POST' });
                                                        taskCompleted = true;
                                                        allSuccess = false;
                                                        skipRetry = true;  // Ë∂ÖÊó∂Âêé‰∏çÈáçËØï
                                                        break;
                                                    }

                                                    await new Promise(resolve => setTimeout(resolve, 1000));
                                                    const status = await apiCall('/api/tasks/status');
                                                    console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ËΩÆËØ¢Áä∂ÊÄÅ #${attempts + 1}:`, status);
                                                    if (!status.running) {
                                                        taskCompleted = true;
                                                        // Ê£ÄÊü•‰ªªÂä°ÊòØÂê¶ÊàêÂäü
                                                        if (status.task) {
                                                            if (status.task.status === 'completed') {
                                                                todoItem.status = 'completed';
                                                                subtaskSuccess = true;
                                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ÂÆåÊàê (status=completed)`);
                                                                todoItem.status = 'completed';
                                                                subtaskSuccess = true;
                                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ÂÆåÊàê (status=completed)`);
                                                            } else if (status.task.status === 'stopped') {
                                                                // Ê£ÄÊü•ÊòØÂê¶ÊòØÁî®Êà∑ÊâãÂä®Ë∑≥Ëøá
                                                                if (isSkipping.value) {
                                                                    todoItem.status = 'skipped';
                                                                    subtaskSuccess = true; // ËßÜ‰∏∫ÊàêÂäüÔºåÁªßÁª≠‰∏ã‰∏Ä‰∏™
                                                                    console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Â∑≤Ë∑≥Ëøá`);
                                                                    isSkipping.value = false; // ÈáçÁΩÆÊ†áÂøó
                                                                    // Áªô‰∏ÄÁÇπÊó∂Èó¥ËÆ©ÁïåÈù¢Êõ¥Êñ∞
                                                                    await new Promise(resolve => setTimeout(resolve, 500));
                                                                } else {
                                                                    todoItem.status = 'failed';
                                                                    console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Â∑≤ÂÅúÊ≠¢`);
                                                                }
                                                            } else {
                                                                todoItem.status = 'failed';
                                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Â§±Ë¥• (status=${status.task.status})`);
                                                            }
                                                        } else {
                                                            // task ‰∏∫ null ‰∏î running ‰∏∫ falseÔºåËØ¥Êòé‰ªªÂä°Â∑≤Ê≠£Â∏∏ÂÆåÊàêÂπ∂Ë¢´Ê∏ÖÁêÜ
                                                            todoItem.status = 'completed';
                                                            subtaskSuccess = true;
                                                            console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ÂÆåÊàê (task cleared)`);
                                                        }
                                                    }
                                                    attempts++;
                                                }

                                                // Ê£ÄÊü•ÊòØÂê¶Ë¢´ÂÅúÊ≠¢ÊàñË∂ÖÊó∂
                                                if (!chatRunning.value && todoItem.status === 'running') {
                                                    todoItem.status = 'failed';
                                                    console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ÊâßË°åÊúüÈó¥Ë¢´ÂÅúÊ≠¢`);
                                                }

                                                if (!taskCompleted && todoItem.status === 'running') {
                                                    todoItem.status = 'failed';
                                                    console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Ë∂ÖÊó∂Â§±Ë¥•`);
                                                }
                                            } catch (error) {
                                                todoItem.status = 'failed';
                                                console.error(`[Â≠ê‰ªªÂä° ${i + 1}] ÂºÇÂ∏∏Â§±Ë¥• (Â∞ùËØï ${retryCount + 1}):`, error);
                                                console.error(`[Â≠ê‰ªªÂä° ${i + 1}] ÈîôËØØËØ¶ÊÉÖ:`, error.message);
                                            }

                                            // Â¶ÇÊûúÂ≠ê‰ªªÂä°Â§±Ë¥•‰∏î‰∏çÊòØË∂ÖÊó∂ÔºåÂ¢ûÂä†ÈáçËØïËÆ°Êï∞
                                            if (!subtaskSuccess && todoItem.status === 'failed' && !skipRetry) {
                                                retryCount++;
                                                if (retryCount <= maxRetries) {
                                                    todoItem.logs = todoItem.logs || [];
                                                    todoItem.logs.push(`‚ö†Ô∏è Â≠ê‰ªªÂä°Â§±Ë¥•ÔºåÊ≠£Âú®ÈáçËØï (${retryCount}/${maxRetries})...`);
                                                }
                                            }
                                        }

                                        // ÂÅúÊ≠¢ÂÄíËÆ°Êó∂ÂÆöÊó∂Âô®
                                        if (subtaskCountdownTimer) {
                                            clearInterval(subtaskCountdownTimer);
                                            subtaskCountdownTimer = null;
                                        }
                                        subtaskCountdown.value = 0;

                                        // ÈáçËØïÂêé‰ªçÁÑ∂Â§±Ë¥•ÔºàÈùûË∂ÖÊó∂ÊÉÖÂÜµÔºâÔºå‰∏≠Ê≠¢Êï¥‰∏™‰ªªÂä°
                                        // Ë∂ÖÊó∂ÊÉÖÂÜµ‰∏ãÁªßÁª≠ÊâßË°å‰∏ã‰∏Ä‰∏™Â≠ê‰ªªÂä°
                                        if (!subtaskSuccess && !skipRetry) {
                                            allSuccess = false;
                                            todoItem.logs = todoItem.logs || [];
                                            todoItem.logs.push(`‚ùå Â≠ê‰ªªÂä°Âú®ÈáçËØï ${maxRetries} Ê¨°Âêé‰ªçÁÑ∂Â§±Ë¥•Ôºå‰∏≠Ê≠¢‰ªªÂä°ÊâßË°å`);
                                            console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ÈáçËØï ${maxRetries} Ê¨°Âêé‰ªçÁÑ∂Â§±Ë¥•Ôºå‰∏≠Ê≠¢Êï¥‰∏™‰ªªÂä°`);

                                            // Â∞ÜÂâ©‰Ωô‰ªªÂä°Ê†áËÆ∞‰∏∫Êú™ÊâßË°åÔºàpendingÔºâ
                                            for (let j = i + 1; j < totalTasks; j++) {
                                                if (assistantMsg.todoList[j].status === 'pending') {
                                                    // ‰øùÊåÅ pending Áä∂ÊÄÅÔºåË°®Á§∫Êú™ÊâßË°å
                                                }
                                            }
                                            break;  // ‰∏≠Ê≠¢Êï¥‰∏™‰ªªÂä°Âæ™ÁéØ
                                        } else if (skipRetry) {
                                            // Ë∂ÖÊó∂ÊÉÖÂÜµ‰∏ãÔºåÁªßÁª≠ÊâßË°å‰∏ã‰∏Ä‰∏™Â≠ê‰ªªÂä°
                                            console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Ë∂ÖÊó∂Â§±Ë¥•ÔºåÁªßÁª≠ÊâßË°å‰∏ã‰∏Ä‰∏™Â≠ê‰ªªÂä°`);
                                        }

                                        saveCurrentSession();
                                        scrollChatToBottom();
                                    }

                                    // Ê∏ÖÈô§ÂΩìÂâçÊâßË°åÁ¥¢Âºï
                                    assistantMsg.currentTodoIndex = undefined;

                                    // Âú®ÈîÅÂ±èÂâçÊà™ÂèñÊúÄÁªàÊà™ÂõæÂπ∂‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
                                    try {
                                        console.log('[Â§çÊùÇ‰ªªÂä°] Êà™ÂèñÊúÄÁªàÊà™Âõæ...');
                                        const screenshotResponse = await fetch(`/api/devices/${chatDeviceId.value}/screenshot/base64`);
                                        if (screenshotResponse.ok) {
                                            const screenshotData = await screenshotResponse.json();
                                            // API ËøîÂõûÁöÑÊòØ {"image": "base64..."} Ê†ºÂºè
                                            if (screenshotData.image && currentSessionId.value && assistantMsg.id) {
                                                // ‰øùÂ≠òÊà™ÂõæÂà∞Êï∞ÊçÆÂ∫ìÔºå‰∏çÂÜç‰øùÂ≠ò base64 Âà∞Ê∂àÊÅØÂØπË±°
                                                try {
                                                    const saveResult = await apiCall(
                                                        `/api/chat/sessions/${currentSessionId.value}/messages/${assistantMsg.id}/screenshots`,
                                                        {
                                                            method: 'POST',
                                                            body: JSON.stringify({
                                                                image: screenshotData.image,
                                                                description: 'Â§çÊùÇ‰ªªÂä°ÂÆåÊàêÊà™Âõæ'
                                                            })
                                                        }
                                                    );
                                                    if (saveResult && saveResult.id) {
                                                        // Êõ¥Êñ∞Ê∂àÊÅØÁöÑ screenshots Êï∞ÁªÑ
                                                        if (!assistantMsg.screenshots) {
                                                            assistantMsg.screenshots = [];
                                                        }
                                                        assistantMsg.screenshots.push({
                                                            id: saveResult.id,
                                                            image_url: `/api/chat/screenshots/${saveResult.id}`
                                                        });
                                                        console.log('[Â§çÊùÇ‰ªªÂä°] Êà™ÂõæÂ∑≤‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì:', saveResult.id);
                                                    }
                                                } catch (saveError) {
                                                    console.error('[Â§çÊùÇ‰ªªÂä°] ‰øùÂ≠òÊà™ÂõæÂà∞Êï∞ÊçÆÂ∫ìÂ§±Ë¥•:', saveError);
                                                }
                                            }
                                        }
                                    } catch (screenshotError) {
                                        console.error('[Â§çÊùÇ‰ªªÂä°] Êà™ÂõæÂ§±Ë¥•:', screenshotError);
                                    }

                                    // Êà™ÂõæÂÆåÊàêÂêéÈîÅÂ±è
                                    try {
                                        console.log('[Â§çÊùÇ‰ªªÂä°] ÈîÅÂÆöËÆæÂ§á...');
                                        await apiCall(`/api/devices/${chatDeviceId.value}/lock`, { method: 'POST' });
                                        console.log('[Â§çÊùÇ‰ªªÂä°] ËÆæÂ§áÂ∑≤ÈîÅÂÆö');
                                    } catch (lockError) {
                                        console.error('[Â§çÊùÇ‰ªªÂä°] ÈîÅÂ±èÂ§±Ë¥•:', lockError);
                                    }

                                    // ÊâÄÊúâÂ≠ê‰ªªÂä°ÊâßË°åÂÆåÊàê
                                    assistantMsg.status = allSuccess ? 'success' : 'error';
                                    assistantMsg.content = allSuccess
                                        ? `‚úÖ Â§çÊùÇ‰ªªÂä°ÊâßË°åÂÆåÊàêÔºÅÂÖ± ${totalTasks} ‰∏™Â≠ê‰ªªÂä°ÂÖ®ÈÉ®ÊàêÂäü„ÄÇ`
                                        : `‚ö†Ô∏è Â§çÊùÇ‰ªªÂä°ÊâßË°åÂÆåÊàêÔºåÈÉ®ÂàÜÂ≠ê‰ªªÂä°Â§±Ë¥•„ÄÇ`;
                                    assistantMsg.timestamp = new Date().toISOString();

                                    // ÂèëÈÄÅÊ±áÊÄªÈÇÆ‰ª∂ÔºàÂ¶ÇÊûúÂºÄÂêØÔºâ
                                    if (chatAutoEmail.value) {
                                        try {
                                            console.log('[Â§çÊùÇ‰ªªÂä°] ÂèëÈÄÅÊ±áÊÄªÈÇÆ‰ª∂...');
                                            // Ëé∑ÂèñÊúÄÊñ∞ÁöÑÊà™Âõæ IDÔºàÂ¶ÇÊûúÊúâÔºâ
                                            const latestScreenshotId = assistantMsg.screenshots && assistantMsg.screenshots.length > 0
                                                ? assistantMsg.screenshots[assistantMsg.screenshots.length - 1].id
                                                : null;
                                            const emailResult = await apiCall('/api/tasks/send-complex-email', {
                                                method: 'POST',
                                                body: JSON.stringify({
                                                    task_name: content,
                                                    subtasks: assistantMsg.todoList.map(t => ({
                                                        content: t.content,
                                                        status: t.status,
                                                        logs: t.logs || []
                                                    })),
                                                    total_tokens: assistantMsg.tokens || 0,
                                                    screenshot_id: latestScreenshotId  // ‰ΩøÁî® screenshot_id ËÄå‰∏çÊòØ base64
                                                }),
                                            });
                                            if (emailResult.success) {
                                                console.log('[Â§çÊùÇ‰ªªÂä°] ÈÇÆ‰ª∂ÂèëÈÄÅÊàêÂäü');
                                            } else {
                                                console.log('[Â§çÊùÇ‰ªªÂä°] ÈÇÆ‰ª∂ÂèëÈÄÅÂ§±Ë¥•:', emailResult.message);
                                            }
                                        } catch (emailError) {
                                            console.error('[Â§çÊùÇ‰ªªÂä°] ÈÇÆ‰ª∂ÂèëÈÄÅÂ§±Ë¥•:', emailError);
                                        }
                                    }
                                } else {
                                    throw new Error('‰ªªÂä°ÊãÜËß£Â§±Ë¥•');
                                }
                            } else {
                                // ÊôÆÈÄöÊ®°ÂºèÔºöÁõ¥Êé•ÊâßË°å‰ªªÂä°
                                const runResult = await apiCall('/api/tasks/run', {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        task_content: content,
                                        device_ids: [chatDeviceId.value],
                                        send_email: chatAutoEmail.value,
                                        task_type: "chat",  // Ê†áËÆ∞‰∏∫ chat ‰ªªÂä°ÔºåÈÅøÂÖçÊó•ÂøóÂá∫Áé∞Âú® Run Task È°µÈù¢
                                        session_id: serverSessionId,  // ‰º†ÈÄí‰ºöËØùID
                                        message_id: serverMessageId,  // ‰º†ÈÄíÊ∂àÊÅØID
                                        debug_mode: debugMode.value,  // Ë∞ÉËØïÊ®°Âºè
                                    }),
                                });
                                // ‰øùÂ≠ò‰ªªÂä°IDÁî®‰∫éÂåπÈÖçWebSocket‰∫ã‰ª∂
                                if (runResult && runResult.task_id) {
                                    assistantMsg.taskId = runResult.task_id;
                                }
                                // Task started, WebSocket will handle updates
                            }
                        } catch (error) {
                            // Update last message to error
                            const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                            if (lastMsg.role === 'assistant') {
                                lastMsg.status = 'error';
                                let errorMsg = error.message || 'Êú™Áü•ÈîôËØØ';

                                // Êèê‰æõÊõ¥ÂèãÂ•ΩÁöÑÈîôËØØÊèêÁ§∫
                                if (errorMsg.includes('Token error') || errorMsg.includes('limited')) {
                                    errorMsg = '‚ùå ' + errorMsg + '\n\nüí° ÊèêÁ§∫ÔºöÊ®°ÂûãÊúçÂä°Ë¢´ÈôêÊµÅÔºåËØ∑Á®çÂêéÂÜçËØïÔºåÊàñÊ£ÄÊü•Ê®°ÂûãÈÖçÁΩÆ‰∏≠ÁöÑAPIÈ¢ùÂ∫¶„ÄÇ';
                                } else if (errorMsg.includes('Failed to parse todoList')) {
                                    errorMsg = '‚ùå ‰ªªÂä°ÊãÜËß£Â§±Ë¥•ÔºöÊ®°ÂûãËøîÂõûÁöÑÊ†ºÂºè‰∏çÊ≠£Á°Æ„ÄÇ\n\nüí° ÊèêÁ§∫ÔºöËØ∑Â∞ùËØïÂ∞Ü‰ªªÂä°ÊèèËø∞ÂæóÊõ¥Ê∏ÖÊô∞ÔºåÊàñÂàáÊç¢Âà∞ÊôÆÈÄö‰ªªÂä°Ê®°ÂºèÊâßË°å„ÄÇ';
                                }

                                lastMsg.content = 'ÂêØÂä®‰ªªÂä°Â§±Ë¥•: ' + errorMsg;
                            }
                            chatRunning.value = false;
                        }

                        // Â§çÊùÇ‰ªªÂä°Ê®°Âºè‰∏ãÔºåÊâßË°åÂÆåÊàêÂêéÈáçÁΩÆÁä∂ÊÄÅ
                        if (complexTaskMode.value) {
                            chatRunning.value = false;
                        }

                        // Save session after sending message
                        saveCurrentSession();
                    }

                    // Stop chat task
                    async function stopChatTask() {
                        try {
                            await apiCall('/api/tasks/stop', { method: 'POST' });
                            showToast('Ê≠£Âú®ÂÅúÊ≠¢‰ªªÂä°...');

                            // Update chat message status
                            if (chatMessages.value.length > 0) {
                                const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                                if (lastMsg.role === 'assistant' && lastMsg.status === 'running') {
                                    lastMsg.status = 'error';
                                    lastMsg.content = '‰ªªÂä°Â∑≤ÂÅúÊ≠¢';
                                }
                            }
                            chatRunning.value = false;
                            saveCurrentSession();
                        } catch (error) {
                            showToast('ÂÅúÊ≠¢‰ªªÂä°Â§±Ë¥•', 'error');
                        }
                    }

                    // Open task detail modal
                    async function openTaskDetail(msg) {
                        // ÂßãÁªà‰ªéÊúçÂä°Âô®Ëé∑ÂèñÂÆåÊï¥ÁöÑÊà™ÂõæÂàóË°®ÔºàWebSocket ÂèØËÉΩÂè™Êé®ÈÄÅ‰∫ÜÈÉ®ÂàÜÊà™ÂõæÔºâ
                        let screenshots = [];

                        // Â¶ÇÊûúÂ≠òÂú® session_id Âíå message_idÔºåÂàô‰ªéÊúçÂä°Âô®Ëé∑ÂèñÂÆåÊï¥Êà™ÂõæÂàóË°®
                        if (currentSessionId.value && msg.id) {
                            try {
                                const screenshotData = await apiCall(
                                    `/api/chat/sessions/${currentSessionId.value}/screenshots?message_id=${msg.id}`
                                );
                                if (screenshotData && screenshotData.length > 0) {
                                    screenshots = screenshotData;
                                    // Êõ¥Êñ∞Ê∂àÊÅØÂØπË±°‰∏≠ÁöÑ screenshots
                                    msg.screenshots = screenshots;
                                }
                            } catch (error) {
                                console.error('Failed to load screenshots:', error);
                                // Ëé∑ÂèñÂ§±Ë¥•Êó∂‰ΩøÁî®Êú¨Âú∞ÁºìÂ≠òÁöÑÊï∞ÊçÆ
                                screenshots = msg.screenshots || [];
                            }
                        } else {
                            // Ê≤°Êúâ session/message idÔºå‰ΩøÁî®Êú¨Âú∞Êï∞ÊçÆ
                            screenshots = msg.screenshots || [];
                        }

                        // Smart log processing for ZhipuAI streaming output
                        // ZhipuAI sends each token as separate array element, causing fragmented display
                        function processLogs(logs) {
                            if (!logs || logs.length === 0) return [];

                            const result = [];
                            let buffer = '';  // Buffer for merging consecutive short tokens

                            for (let i = 0; i < logs.length; i++) {
                                const log = logs[i];

                                // If this is a short token (likely streaming output)
                                if (log.length <= 3) {
                                    buffer += log;
                                } else {
                                    // This is a complete log entry
                                    // First, flush any buffered content
                                    if (buffer.trim().length > 0) {
                                        result.push(buffer);
                                        buffer = '';
                                    }
                                    // Then add this complete entry
                                    result.push(log);
                                }
                            }

                            // Flush any remaining buffered content
                            if (buffer.trim().length > 0) {
                                result.push(buffer);
                            }

                            return result;
                        }

                        taskDetailData.value = {
                            status: msg.status,
                            logs: processLogs(msg.logs || []),
                            screenshots: screenshots  // Âè™‰ΩøÁî® screenshotsÔºå‰∏çÂÜç‰ΩøÁî® base64 screenshot
                        };
                        showTaskDetail.value = true;
                    }

                    // Device functions (original)
                    async function refreshDevices() {
                        loading.value = true;
                        try {
                            const data = await apiCall('/api/devices/refresh', { method: 'POST' });
                            devices.value = data;
                            showToast(`Found ${data.length
                                } device(s)`);
                        } catch (e) {
                            console.error('Failed to refresh devices:', e);
                        } finally {
                            loading.value = false;
                        }
                    }

                    function toggleDeviceSelection(deviceId) {
                        const index = selectedDevices.value.indexOf(deviceId);
                        if (index === -1) {
                            selectedDevices.value.push(deviceId);
                        } else {
                            selectedDevices.value.splice(index, 1);
                        }
                    }

                    function selectAllDevices() {
                        if (selectedDevices.value.length === devices.value.length) {
                            selectedDevices.value = [];
                        } else {
                            selectedDevices.value = devices.value.map(d => d.id);
                        }
                    }

                    function getDeviceName(id) {
                        const device = devices.value.find(d => d.id === id);
                        return device ? (device.name || device.id.substring(0, 20)) : id.substring(0, 20);
                    }

                    async function unlockDevice(deviceId) {
                        try {
                            const pin = pinInputValues.value[deviceId] || '';
                            await apiCall(`/ api / devices / ${deviceId} / unlock`, {
                                method: 'POST',
                                body: JSON.stringify({ pin: pin }),
                            });
                            showToast('ËÆæÂ§áÂ∑≤Ëß£ÈîÅ');
                        } catch (error) {
                            showToast('Ëß£ÈîÅÂ§±Ë¥•', 'error');
                        }
                    }

                    // Wireless pairing functions
                    async function wirelessPair() {
                        if (!pairAddress.value) {
                            showToast('ËØ∑ËæìÂÖ•ÈÖçÂØπÂú∞ÂùÄ', 'error');
                            return;
                        }
                        if (!pairCode.value || pairCode.value.length !== 6) {
                            showToast('ËØ∑ËæìÂÖ•6‰ΩçÈÖçÂØπÁ†Å', 'error');
                            return;
                        }
                        pairingLoading.value = true;
                        deviceLogs.value = [];
                        try {
                            const data = await apiCall('/api/devices/pair', {
                                method: 'POST',
                                body: JSON.stringify({
                                    pair_address: pairAddress.value,
                                    pair_code: pairCode.value,
                                }),
                            });
                            deviceLogs.value = data.logs || [];
                            if (data.success) {
                                showToast(data.message, 'success');
                                pairCode.value = '';
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('ÈÖçÂØπÂ§±Ë¥•: ' + error.message, 'error');
                        } finally {
                            pairingLoading.value = false;
                        }
                    }

                    async function tcpConnect() {
                        if (!connectAddress.value) {
                            showToast('ËØ∑ËæìÂÖ•ËøûÊé•Âú∞ÂùÄ', 'error');
                            return;
                        }
                        connectingLoading.value = true;
                        deviceLogs.value = [];
                        try {
                            const data = await apiCall('/api/devices/connect', {
                                method: 'POST',
                                body: JSON.stringify({
                                    connect_address: connectAddress.value,
                                }),
                            });
                            deviceLogs.value = data.logs || [];
                            if (data.success) {
                                showToast(data.message, 'success');
                                await refreshDevices();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('ËøûÊé•Â§±Ë¥•: ' + error.message, 'error');
                        } finally {
                            connectingLoading.value = false;
                        }
                    }

                    async function disconnectDevice(deviceId) {
                        try {
                            const data = await apiCall(`/ api / devices / disconnect / ${deviceId}`, {
                                method: 'POST',
                            });
                            if (data.success) {
                                showToast('ËÆæÂ§áÂ∑≤Êñ≠ÂºÄ');
                                await refreshDevices();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('Êñ≠ÂºÄÂ§±Ë¥•', 'error');
                        }
                    }

                    // APK install functions
                    function onApkFileSelect(event) {
                        const file = event.target.files[0];
                        if (file && file.name.toLowerCase().endsWith('.apk')) {
                            apkFile.value = file;
                            apkLogs.value = [];
                        } else {
                            apkFile.value = null;
                            showToast('ËØ∑ÈÄâÊã© APK Êñá‰ª∂', 'error');
                        }
                    }

                    async function installApk() {
                        if (!apkTargetDevice.value) {
                            showToast('ËØ∑ÈÄâÊã©ÁõÆÊ†áËÆæÂ§á', 'error');
                            return;
                        }
                        if (!apkFile.value) {
                            showToast('ËØ∑ÈÄâÊã© APK Êñá‰ª∂', 'error');
                            return;
                        }

                        apkInstalling.value = true;
                        apkLogs.value = ['ÂáÜÂ§á‰∏ä‰º† APK Êñá‰ª∂...'];

                        try {
                            const formData = new FormData();
                            formData.append('file', apkFile.value);

                            apkLogs.value.push(`‰∏ä‰º†‰∏≠: ${apkFile.value.name}`);

                            const response = await fetch(`/ api / devices / ${apkTargetDevice.value} / install - apk`, {
                                method: 'POST',
                                body: formData,
                            });

                            const data = await response.json();
                            apkLogs.value = data.logs || [];

                            if (data.success) {
                                showToast(data.message, 'success');
                                // Clear file input
                                apkFile.value = null;
                                if (apkFileInput.value) {
                                    apkFileInput.value.value = '';
                                }
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            apkLogs.value.push(`‚ùå ÂÆâË£ÖÂ§±Ë¥•: ${error.message}`);
                            showToast('APK ÂÆâË£ÖÂ§±Ë¥•', 'error');
                        } finally {
                            apkInstalling.value = false;
                        }
                    }

                    // File manager functions
                    async function loadFiles() {
                        if (!fileDevice.value) return;
                        fileLoading.value = true;
                        try {
                            const data = await apiCall(`/ api / devices / ${fileDevice.value} / files ? path = ${encodeURIComponent(filePath.value)
                                } `);
                            fileList.value = data.files || [];
                        } catch (error) {
                            showToast('Âä†ËΩΩÊñá‰ª∂ÂàóË°®Â§±Ë¥•: ' + error.message, 'error');
                            fileList.value = [];
                        } finally {
                            fileLoading.value = false;
                        }
                    }

                    function navigateTo(path) {
                        // Normalize path
                        path = path.replace(/\/+/g, '/');
                        if (path !== '/' && path.endsWith('/')) {
                            path = path.slice(0, -1);
                        }
                        filePath.value = path;
                        loadFiles();
                    }

                    function goUp() {
                        const parts = filePath.value.split('/').filter(p => p);
                        if (parts.length > 0) {
                            parts.pop();
                            filePath.value = '/' + parts.join('/');
                            loadFiles();
                        }
                    }

                    function formatFileSize(size) {
                        const num = parseInt(size);
                        if (isNaN(num)) return size;
                        if (num < 1024) return num + ' B';
                        if (num < 1024 * 1024) return (num / 1024).toFixed(1) + ' KB';
                        if (num < 1024 * 1024 * 1024) return (num / 1024 / 1024).toFixed(1) + ' MB';
                        return (num / 1024 / 1024 / 1024).toFixed(1) + ' GB';
                    }

                    function isImageFile(name) {
                        return /\.(jpg|jpeg|png|gif|bmp|webp)$/i.test(name);
                    }

                    function isVideoFile(name) {
                        return /\.(mp4|mkv|avi|mov|wmv|flv|webm)$/i.test(name);
                    }

                    function isAudioFile(name) {
                        return /\.(mp3|wav|flac|aac|ogg|m4a)$/i.test(name);
                    }

                    async function downloadFile(filename) {
                        const fullPath = filePath.value + '/' + filename;
                        try {
                            const response = await fetch(`/ api / devices / ${fileDevice.value} /files/download ? path = ${encodeURIComponent(fullPath)} `);
                            if (!response.ok) throw new Error('‰∏ãËΩΩÂ§±Ë¥•');
                            const blob = await response.blob();
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = filename;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            showToast('‰∏ãËΩΩÊàêÂäü');
                        } catch (error) {
                            showToast('‰∏ãËΩΩÂ§±Ë¥•: ' + error.message, 'error');
                        }
                    }

                    function onUploadFileSelect(event) {
                        uploadSelectedFile.value = event.target.files[0] || null;
                    }

                    async function uploadFile() {
                        if (!uploadSelectedFile.value || !fileDevice.value) return;
                        fileUploading.value = true;
                        try {
                            const formData = new FormData();
                            formData.append('file', uploadSelectedFile.value);
                            formData.append('path', filePath.value);

                            const response = await fetch(`/ api / devices / ${fileDevice.value} /files/upload`, {
                                method: 'POST',
                                body: formData,
                            });
                            const data = await response.json();

                            if (data.success) {
                                showToast('‰∏ä‰º†ÊàêÂäü');
                                uploadSelectedFile.value = null;
                                if (uploadFileInput.value) uploadFileInput.value.value = '';
                                await loadFiles();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('‰∏ä‰º†Â§±Ë¥•: ' + error.message, 'error');
                        } finally {
                            fileUploading.value = false;
                        }
                    }

                    async function deleteFileConfirm(filename, isDir) {
                        const type = isDir ? 'Êñá‰ª∂Â§π' : 'Êñá‰ª∂';
                        if (!confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§${type} "${filename}" ÂêóÔºü`)) return;

                        const fullPath = filePath.value + '/' + filename;
                        try {
                            const data = await apiCall(`/ api / devices / ${fileDevice.value}/files?path=${encodeURIComponent(fullPath)}`, {
                                method: 'DELETE',
                            });
                            if (data.success) {
                                showToast('Âà†Èô§ÊàêÂäü');
                                await loadFiles();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('Âà†Èô§Â§±Ë¥•: ' + error.message, 'error');
                        }
                    }

                    // PIN management functions
                    async function loadDevicePins() {
                        try {
                            const data = await apiCall('/api/devices/pins');
                            devicePins.value = data.pins || {};
                            // Load actual PIN values for display
                            for (const deviceId of Object.keys(devicePins.value)) {
                                try {
                                    const pinData = await apiCall(`/api/devices/${deviceId}/pin`);
                                    if (pinData.pin) {
                                        pinInputValues.value[deviceId] = pinData.pin;
                                    }
                                } catch (e) {
                                    // Ignore errors for individual PIN fetch
                                }
                            }
                        } catch (error) {
                            console.error('Failed to load device PINs:', error);
                        }
                    }

                    function updateDevicePin(deviceId, pin) {
                        pinInputValues.value[deviceId] = pin;
                        devicePins.value[deviceId] = pin ? true : false;
                    }

                    function toggleShowPin(deviceId) {
                        if (showPinFor.value === deviceId) {
                            showPinFor.value = '';
                        } else {
                            showPinFor.value = deviceId;
                        }
                    }

                    async function saveDevicePin(deviceId, pin) {
                        if (!pin) return;
                        try {
                            await apiCall(`/api/devices/${deviceId}/pin`, {
                                method: 'PUT',
                                body: JSON.stringify({ pin: pin }),
                            });
                            showToast('PIN saved');
                        } catch (error) {
                            showToast('Failed to save PIN', 'error');
                        }
                    }

                    // Auto-scroll log container
                    function scrollLogsToBottom() {
                        if (logContainer.value) {
                            logContainer.value.scrollTop = logContainer.value.scrollHeight;
                        }
                    }

                    // Task functions
                    async function runTask() {
                        if (!taskContent.value.trim()) {
                            showToast('Please enter a task', 'warning');
                            return;
                        }
                        if (selectedDevices.value.length === 0) {
                            showToast('Please select at least one device', 'warning');
                            return;
                        }

                        taskLogs.value = [];
                        taskProgress.value = 0;

                        try {
                            await apiCall('/api/tasks/run', {
                                method: 'POST',
                                body: JSON.stringify({
                                    task_content: taskContent.value,
                                    device_ids: selectedDevices.value,
                                }),
                            });
                            taskRunning.value = true;
                            showToast('Task started');
                        } catch (error) {
                            showToast('Failed to start task', 'error');
                        }
                    }

                    async function stopTask() {
                        try {
                            await apiCall('/api/tasks/stop', { method: 'POST' });
                            showToast('Stop signal sent');
                        } catch (error) {
                            showToast('Failed to stop task', 'error');
                        }
                    }

                    // Scheduler functions
                    async function loadScheduledTasks() {
                        try {
                            const data = await apiCall('/api/scheduler/tasks');
                            scheduledTasks.value = data.tasks;
                        } catch (error) {
                            console.error('Failed to load scheduled tasks:', error);
                        }
                    }

                    async function toggleScheduledTask(taskId, enabled) {
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}/toggle`, {
                                method: 'PATCH',
                                body: JSON.stringify({ enabled }),
                            });
                            await loadScheduledTasks();
                        } catch (error) {
                            showToast('Failed to toggle task', 'error');
                        }
                    }

                    async function runScheduledTaskNow(taskId) {
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}/run`, { method: 'POST' });
                            showToast('Task triggered');
                        } catch (error) {
                            showToast('Failed to run task', 'error');
                        }
                    }

                    async function deleteScheduledTask(taskId) {
                        if (!confirm('Are you sure you want to delete this task?')) return;
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}`, { method: 'DELETE' });
                            await loadScheduledTasks();
                            showToast('Task deleted');
                        } catch (error) {
                            showToast('Failed to delete task', 'error');
                        }
                    }

                    // Scheduler form functions
                    function showCreateScheduledTask() {
                        schedulerForm.value = getDefaultSchedulerForm();
                        schedulerFormMode.value = 'create';
                        showSchedulerForm.value = true;
                    }

                    function editScheduledTask(task) {
                        schedulerForm.value = {
                            id: task.id,
                            name: task.name,
                            task_content: task.task_content,
                            enabled: task.enabled,
                            schedule_type: task.schedule_type,
                            run_at: task.run_at || '',
                            interval_minutes: task.interval_minutes || 60,
                            daily_time: task.daily_time || '09:00',
                            weekly_days: task.weekly_days || [1],
                            weekly_time: task.weekly_time || '09:00',
                            monthly_day: task.monthly_day || 1,
                            monthly_time: task.monthly_time || '09:00',
                            devices: task.devices || [],
                        };
                        schedulerFormMode.value = 'edit';
                        showSchedulerForm.value = true;
                    }

                    function cancelSchedulerForm() {
                        showSchedulerForm.value = false;
                        schedulerForm.value = getDefaultSchedulerForm();
                    }

                    async function saveScheduledTask() {
                        if (!schedulerForm.value.name.trim()) {
                            showToast('Please enter a task name', 'warning');
                            return;
                        }
                        if (!schedulerForm.value.task_content.trim()) {
                            showToast('Please enter task content', 'warning');
                            return;
                        }

                        loading.value = true;
                        try {
                            if (schedulerFormMode.value === 'create') {
                                await apiCall('/api/scheduler/tasks', {
                                    method: 'POST',
                                    body: JSON.stringify(schedulerForm.value),
                                });
                                showToast('Task created');
                            } else {
                                await apiCall(`/api/scheduler/tasks/${schedulerForm.value.id}`, {
                                    method: 'PUT',
                                    body: JSON.stringify(schedulerForm.value),
                                });
                                showToast('Task updated');
                            }
                            await loadScheduledTasks();
                            cancelSchedulerForm();
                        } catch (error) {
                            showToast('Failed to save task', 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    function formatScheduleType(task) {
                        switch (task.schedule_type) {
                            case 'once': return `Once: ${task.run_at}`;
                            case 'interval': return `Every ${task.interval_minutes} min`;
                            case 'daily': return `Daily @ ${task.daily_time}`;
                            case 'weekly': return `Weekly @ ${task.weekly_time}`;
                            case 'monthly': return `Monthly day ${task.monthly_day} @ ${task.monthly_time}`;
                            default: return task.schedule_type;
                        }
                    }

                    // Scheduler logs functions
                    async function loadSchedulerLogs() {
                        try {
                            const data = await apiCall('/api/scheduler/logs?limit=50');
                            schedulerLogs.value = data.logs || [];
                        } catch (error) {
                            console.error('Failed to load scheduler logs:', error);
                        }
                    }

                    async function clearAllSchedulerLogs() {
                        if (!confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÂÆöÊó∂‰ªªÂä°ÁöÑÊâßË°åÊó•ÂøóÂêóÔºü')) return;
                        try {
                            await apiCall('/api/scheduler/logs', { method: 'DELETE' });
                            showToast('ÊâÄÊúâÊó•ÂøóÂ∑≤Ê∏ÖÁ©∫');
                            schedulerLogs.value = [];
                        } catch (error) {
                            showToast('Ê∏ÖÁ©∫Êó•ÂøóÂ§±Ë¥•: ' + error.message, 'error');
                        }
                    }

                    function formatLogTime(timestamp) {
                        if (!timestamp) return '-';
                        const date = new Date(timestamp);
                        const now = new Date();
                        const isToday = date.toDateString() === now.toDateString();
                        if (isToday) {
                            return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                        }
                        return date.toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
                    }

                    function showLogDetails(log) {
                        // Process details if it's an array (handle ZhipuAI streaming tokens)
                        const processedLog = { ...log };

                        try {
                            if (Array.isArray(log.details)) {
                                // Apply same smart processing as taskDetailData
                                const processLogs = (logs) => {
                                    if (!logs || logs.length === 0) return '';

                                    const result = [];
                                    let buffer = '';

                                    for (let i = 0; i < logs.length; i++) {
                                        const logItem = logs[i];
                                        // Ensure logItem is a string
                                        const itemStr = String(logItem || '');

                                        if (itemStr.length <= 3) {
                                            buffer += itemStr;
                                        } else {
                                            if (buffer.trim().length > 0) {
                                                result.push(buffer);
                                                buffer = '';
                                            }
                                            result.push(itemStr);
                                        }
                                    }

                                    if (buffer.trim().length > 0) {
                                        result.push(buffer);
                                    }

                                    return result.join('\n');
                                };

                                processedLog.details = processLogs(log.details);
                            } else if (typeof log.details === 'string') {
                                // Already a string, use as-is
                                processedLog.details = log.details;
                            } else {
                                // Unexpected type, convert to string
                                processedLog.details = String(log.details || 'Êó†ËØ¶ÁªÜÊó•Âøó');
                            }
                        } catch (error) {
                            console.error('Error processing log details:', error);
                            // Fallback: use original details or JSON stringify
                            if (Array.isArray(log.details)) {
                                processedLog.details = log.details.join('\n');
                            } else {
                                processedLog.details = String(log.details || 'Â§ÑÁêÜÊó•ÂøóÊó∂Âá∫Èîô');
                            }
                        }

                        logDetailData.value = processedLog;
                        showLogDetailModal.value = true;
                    }

                    async function clearTaskLogs(taskId) {
                        if (!confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÈô§ËØ•‰ªªÂä°ÁöÑÊâÄÊúâÊó•ÂøóÂêóÔºü')) return;
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}/logs`, { method: 'DELETE' });
                            showToast('Êó•ÂøóÂ∑≤Ê∏ÖÈô§');
                            await loadSchedulerLogs();
                        } catch (error) {
                            showToast('Ê∏ÖÈô§Êó•ÂøóÂ§±Ë¥•', 'error');
                        }
                    }

                    // Model functions
                    async function loadModels() {
                        try {
                            const data = await apiCall('/api/models');
                            modelServices.value = data.services;
                            const active = modelServices.value.find(s => s.is_active);
                            activeModel.value = active || null;
                        } catch (error) {
                            console.error('Failed to load models:', error);
                        }
                    }

                    async function activateModel(serviceId) {
                        try {
                            await apiCall(`/api/models/${serviceId}/activate`, { method: 'POST' });
                            await loadModels();
                            showToast('Model activated');
                        } catch (error) {
                            showToast('Failed to activate model', 'error');
                        }
                    }

                    async function testModel(serviceId) {
                        loading.value = true;
                        try {
                            const data = await apiCall(`/api/models/${serviceId}/test`, { method: 'POST' });
                            showToast(data.message, data.success ? 'success' : 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    // Model CRUD functions
                    async function loadModelPresets() {
                        try {
                            const data = await apiCall('/api/models/presets');
                            modelPresets.value = data.presets || [];
                        } catch (error) {
                            console.error('Failed to load model presets:', error);
                        }
                    }

                    function openModelForm(mode, service = null) {
                        modelFormMode.value = mode;
                        if (mode === 'edit' && service) {
                            modelForm.value = { ...service };
                        } else {
                            modelForm.value = getDefaultModelForm();
                        }
                        showModelForm.value = true;
                    }

                    async function saveModel() {
                        if (!modelForm.value.name || !modelForm.value.base_url || !modelForm.value.model_name) {
                            showToast('ËØ∑Â°´ÂÜôÂøÖÂ°´Â≠óÊÆµÔºàÂêçÁß∞„ÄÅBase URL„ÄÅÊ®°ÂûãÂêçÁß∞Ôºâ', 'error');
                            return;
                        }
                        loading.value = true;
                        try {
                            if (modelFormMode.value === 'create') {
                                await apiCall('/api/models', {
                                    method: 'POST',
                                    body: JSON.stringify(modelForm.value),
                                });
                                showToast('Ê®°ÂûãÊúçÂä°ÂàõÂª∫ÊàêÂäü');
                            } else {
                                await apiCall(`/api/models/${modelForm.value.id}`, {
                                    method: 'PUT',
                                    body: JSON.stringify(modelForm.value),
                                });
                                showToast('Ê®°ÂûãÊúçÂä°Êõ¥Êñ∞ÊàêÂäü');
                            }
                            showModelForm.value = false;
                            await loadModels();
                        } catch (error) {
                            showToast('‰øùÂ≠òÂ§±Ë¥•: ' + error.message, 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    async function deleteModel(serviceId, serviceName) {
                        if (!confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§Ê®°ÂûãÊúçÂä° "${serviceName}" ÂêóÔºü`)) {
                            return;
                        }
                        try {
                            await apiCall(`/api/models/${serviceId}`, { method: 'DELETE' });
                            showToast('Ê®°ÂûãÊúçÂä°Â∑≤Âà†Èô§');
                            await loadModels();
                        } catch (error) {
                            showToast('Âà†Èô§Â§±Ë¥•: ' + error.message, 'error');
                        }
                    }

                    async function testModelConfig() {
                        if (!modelForm.value.base_url || !modelForm.value.model_name) {
                            showToast('ËØ∑Â°´ÂÜô Base URL ÂíåÊ®°ÂûãÂêçÁß∞', 'error');
                            return;
                        }
                        loading.value = true;
                        try {
                            const data = await apiCall('/api/models/test', {
                                method: 'POST',
                                body: JSON.stringify({
                                    base_url: modelForm.value.base_url,
                                    api_key: modelForm.value.api_key,
                                    model_name: modelForm.value.model_name,
                                }),
                            });
                            showToast(data.message, data.success ? 'success' : 'error');
                        } catch (error) {
                            showToast('ÊµãËØïÂ§±Ë¥•: ' + error.message, 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    function addFromPreset(preset) {
                        modelForm.value = {
                            ...getDefaultModelForm(),
                            name: preset.name,
                            base_url: preset.base_url,
                            model_name: preset.model_name,
                            description: preset.description || '',
                            max_tokens: preset.max_tokens || 3000,
                            temperature: preset.temperature || 0.0,
                            protocol: preset.protocol || 'openai',
                            category: preset.category || '',
                        };
                        modelFormMode.value = 'create';
                        showModelForm.value = true;
                    }

                    // ÊåâÂàÜÁ±ªËé∑ÂèñÈ¢ÑËÆæÊ®°Êùø
                    function getPresetsByCategory(category) {
                        return modelPresets.value.filter(p => p.category === category);
                    }

                    // Settings functions
                    async function loadEmailConfig() {
                        try {
                            emailConfig.value = await apiCall('/api/settings/email');
                        } catch (error) {
                            console.error('Failed to load email config:', error);
                        }
                    }

                    async function saveEmailConfig() {
                        try {
                            await apiCall('/api/settings/email', {
                                method: 'PUT',
                                body: JSON.stringify(emailConfig.value),
                            });
                            showToast('Email settings saved');
                        } catch (error) {
                            showToast('Failed to save email settings', 'error');
                        }
                    }

                    async function testEmail() {
                        loading.value = true;
                        try {
                            const data = await apiCall('/api/settings/email/test', { method: 'POST' });
                            showToast(data.message, data.success ? 'success' : 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    // Screenshot configuration
                    async function saveScreenshotConfig() {
                        loading.value = true;
                        try {
                            await apiCall('/api/settings/screenshot', {
                                method: 'PUT',
                                body: JSON.stringify({
                                    max_image_dimension: screenshotConfig.value.max_dimension,
                                    jpeg_quality: screenshotConfig.value.jpeg_quality
                                })
                            });
                            showToast('Screenshot settings saved successfully!', 'success');
                        } catch (error) {
                            console.error('Failed to save screenshot settings:', error);
                            showToast('Failed to save screenshot settings', 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    async function loadScreenshotConfig() {
                        try {
                            const data = await apiCall('/api/settings/screenshot');
                            screenshotConfig.value = {
                                max_dimension: data.max_image_dimension,
                                jpeg_quality: data.jpeg_quality
                            };
                        } catch (error) {
                            console.error('Failed to load screenshot settings:', error);
                        }
                    }

                    async function resetScreenshotConfig() {
                        screenshotConfig.value = {
                            max_dimension: 1920,
                            jpeg_quality: 70
                        };
                        showToast('Â∑≤ÊÅ¢Â§çÈªòËÆ§ËÆæÁΩÆ');
                    }

                    // Rules configuration functions
                    async function loadAppMappings() {
                        try {
                            const data = await apiCall('/api/rules/apps');
                            appMappings.value = data.apps || [];
                        } catch (error) {
                            console.error('Failed to load app mappings:', error);
                        }
                    }

                    async function loadTimingConfig() {
                        try {
                            timingConfig.value = await apiCall('/api/rules/timing');
                        } catch (error) {
                            console.error('Failed to load timing config:', error);
                        }
                    }

                    async function loadSystemPrompts() {
                        try {
                            const data = await apiCall('/api/rules/prompts');
                            systemPrompts.value = data.prompts || {};
                        } catch (error) {
                            console.error('Failed to load prompts:', error);
                        }
                    }

                    function formatTimingKey(key) {
                        return key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    }

                    async function updateTiming(category, key, value) {
                        try {
                            await apiCall('/api/rules/timing', {
                                method: 'PUT',
                                body: JSON.stringify({ category, key, value: parseFloat(value) }),
                            });
                            showToast('Êó∂Èó¥ÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞');
                        } catch (error) {
                            showToast('Êõ¥Êñ∞Â§±Ë¥•', 'error');
                            loadTimingConfig(); // Reload on error
                        }
                    }

                    function editAppMapping(app) {
                        editingApp.value = app;
                        appForm.value = { app_name: app.app_name, package_name: app.package_name };
                        showAddAppModal.value = true;
                    }

                    async function saveAppMapping() {
                        if (!appForm.value.app_name || !appForm.value.package_name) {
                            showToast('ËØ∑Â°´ÂÜôÂÆåÊï¥‰ø°ÊÅØ', 'error');
                            return;
                        }
                        try {
                            if (editingApp.value) {
                                await apiCall(`/api/rules/apps/${encodeURIComponent(editingApp.value.app_name)}`, {
                                    method: 'PUT',
                                    body: JSON.stringify({
                                        new_name: appForm.value.app_name,
                                        package_name: appForm.value.package_name,
                                    }),
                                });
                                showToast('Â∫îÁî®Êò†Â∞ÑÂ∑≤Êõ¥Êñ∞');
                            } else {
                                await apiCall('/api/rules/apps', {
                                    method: 'POST',
                                    body: JSON.stringify(appForm.value),
                                });
                                showToast('Â∫îÁî®Êò†Â∞ÑÂ∑≤Ê∑ªÂä†');
                            }
                            showAddAppModal.value = false;
                            editingApp.value = null;
                            appForm.value = { app_name: '', package_name: '' };
                            await loadAppMappings();
                        } catch (error) {
                            showToast(error.message || 'Êìç‰ΩúÂ§±Ë¥•', 'error');
                        }
                    }

                    async function deleteAppMapping(appName) {
                        if (!confirm(`Á°ÆÂÆöÂà†Èô§Â∫îÁî®Êò†Â∞Ñ„Äå${appName}„ÄçÂêóÔºü`)) return;
                        try {
                            await apiCall(`/api/rules/apps/${encodeURIComponent(appName)}`, { method: 'DELETE' });
                            showToast('Â∫îÁî®Êò†Â∞ÑÂ∑≤Âà†Èô§');
                            await loadAppMappings();
                        } catch (error) {
                            showToast('Âà†Èô§Â§±Ë¥•', 'error');
                        }
                    }

                    async function savePrompt(key, content) {
                        try {
                            await apiCall(`/api/rules/prompts/${key}`, {
                                method: 'PUT',
                                body: JSON.stringify({ content }),
                            });
                            showToast('ÊèêÁ§∫ËØçÂ∑≤‰øùÂ≠ò');
                        } catch (error) {
                            showToast('‰øùÂ≠òÂ§±Ë¥•', 'error');
                        }
                    }

                    async function resetPrompt(key) {
                        if (!confirm('Á°ÆÂÆöÈáçÁΩÆ‰∏∫ÈªòËÆ§ÊèêÁ§∫ËØçÂêóÔºü')) return;
                        try {
                            await apiCall(`/api/rules/prompts/${key}/reset`, { method: 'POST' });
                            showToast('ÊèêÁ§∫ËØçÂ∑≤ÈáçÁΩÆ');
                            await loadSystemPrompts();
                        } catch (error) {
                            showToast('ÈáçÁΩÆÂ§±Ë¥•', 'error');
                        }
                    }

                    // Action rules functions
                    async function loadActionRules() {
                        try {
                            const data = await apiCall('/api/rules/actions');
                            actionRules.value = data.actions || [];
                        } catch (error) {
                            console.error('Failed to load action rules:', error);
                        }
                    }

                    function toggleActionExpand(actionName) {
                        expandedActions.value[actionName] = !expandedActions.value[actionName];
                    }

                    async function toggleRuleEnabled(actionName, ruleId) {
                        try {
                            await apiCall(`/api/rules/actions/${encodeURIComponent(actionName)}/rules/${ruleId}/toggle`, { method: 'PUT' });
                            await loadActionRules();
                        } catch (error) {
                            showToast('Êìç‰ΩúÂ§±Ë¥•', 'error');
                        }
                    }

                    function showAddRuleModal(actionName) {
                        editingRuleAction.value = actionName;
                        editingRule.value = null;
                        ruleForm.value = { condition: '', action: '', priority: 0, enabled: true };
                        showRuleModal.value = true;
                    }

                    function editRuleItem(actionName, rule) {
                        editingRuleAction.value = actionName;
                        editingRule.value = rule;
                        ruleForm.value = {
                            condition: rule.condition,
                            action: rule.action,
                            priority: rule.priority || 0,
                            enabled: rule.enabled
                        };
                        showRuleModal.value = true;
                    }

                    async function saveRuleItem() {
                        if (!ruleForm.value.condition || !ruleForm.value.action) {
                            showToast('ËØ∑Â°´ÂÜôÂÆåÊï¥‰ø°ÊÅØ', 'error');
                            return;
                        }
                        try {
                            if (editingRule.value) {
                                // Update existing rule
                                await apiCall(`/api/rules/actions/${encodeURIComponent(editingRuleAction.value)}/rules/${editingRule.value.id}`, {
                                    method: 'PUT',
                                    body: JSON.stringify(ruleForm.value),
                                });
                                showToast('ËßÑÂàôÂ∑≤Êõ¥Êñ∞');
                            } else {
                                // Add new rule
                                await apiCall(`/api/rules/actions/${encodeURIComponent(editingRuleAction.value)}/rules`, {
                                    method: 'POST',
                                    body: JSON.stringify(ruleForm.value),
                                });
                                showToast('ËßÑÂàôÂ∑≤Ê∑ªÂä†');
                            }
                            showRuleModal.value = false;
                            await loadActionRules();
                        } catch (error) {
                            showToast(error.message || 'Êìç‰ΩúÂ§±Ë¥•', 'error');
                        }
                    }

                    async function deleteRuleItem(actionName, ruleId) {
                        if (!confirm('Á°ÆÂÆöÂà†Èô§Ê≠§ËßÑÂàôÂêóÔºü')) return;
                        try {
                            await apiCall(`/api/rules/actions/${encodeURIComponent(actionName)}/rules/${ruleId}`, { method: 'DELETE' });
                            showToast('ËßÑÂàôÂ∑≤Âà†Èô§');
                            await loadActionRules();
                        } catch (error) {
                            showToast('Âà†Èô§Â§±Ë¥•', 'error');
                        }
                    }

                    async function resetActionRules() {
                        if (!confirm('Á°ÆÂÆöÈáçÁΩÆÊâÄÊúâÂä®‰ΩúËßÑÂàô‰∏∫ÈªòËÆ§ÂÄºÂêóÔºü')) return;
                        try {
                            await apiCall('/api/rules/actions/reset', { method: 'POST' });
                            showToast('Âä®‰ΩúËßÑÂàôÂ∑≤ÈáçÁΩÆ');
                            await loadActionRules();
                        } catch (error) {
                            showToast('ÈáçÁΩÆÂ§±Ë¥•', 'error');
                        }
                    }

                    // Phone Preview Functions
                    const phonePreviewStyle = Vue.computed(() => ({
                        left: previewPosition.value.x + 'px',
                        top: previewPosition.value.y + 'px',
                    }));

                    async function refreshPreview() {
                        if (!previewDeviceId.value) return;
                        // Don't set loading state - keep showing old image for smooth transition
                        try {
                            const response = await fetch(`/api/devices/${previewDeviceId.value}/screenshot/base64`);
                            if (response.ok) {
                                const data = await response.json();
                                if (data.image) {
                                    previewImage.value = data.image;
                                }
                            }
                        } catch (e) {
                            // Silently fail, keep old image
                        }
                    }

                    function openPhonePreview() {
                        updatePreviewPosition();
                        showPhonePreview.value = true;
                        if (!previewDeviceId.value && devices.value.length) {
                            previewDeviceId.value = devices.value[0].id;
                        }
                        refreshPreview();
                    }

                    function startDragPreview(e) {
                        if (e.target.closest('.phone-preview-controls') || e.target.closest('.phone-preview-body')) return;
                        isDragging = true;
                        dragOffset.x = e.clientX - previewPosition.value.x;
                        dragOffset.y = e.clientY - previewPosition.value.y;
                        document.addEventListener('mousemove', onDragPreview);
                        document.addEventListener('mouseup', stopDragPreview);
                    }

                    function onDragPreview(e) {
                        if (!isDragging) return;
                        const maxX = window.innerWidth - 320;
                        const maxY = window.innerHeight - 600;
                        previewPosition.value.x = Math.max(0, Math.min(maxX, e.clientX - dragOffset.x));
                        previewPosition.value.y = Math.max(0, Math.min(maxY, e.clientY - dragOffset.y));
                    }

                    function stopDragPreview() {
                        isDragging = false;
                        document.removeEventListener('mousemove', onDragPreview);
                        document.removeEventListener('mouseup', stopDragPreview);
                    }

                    function startPreviewAutoRefresh() {
                        stopPreviewAutoRefresh();
                        previewInterval = setInterval(() => {
                            if (showPhonePreview.value && previewDeviceId.value) {
                                refreshPreview();
                            }
                        }, 2000); // Refresh every 2 seconds
                    }

                    function stopPreviewAutoRefresh() {
                        if (previewInterval) {
                            clearInterval(previewInterval);
                            previewInterval = null;
                        }
                    }

                    // Watch showPhonePreview to start/stop auto refresh
                    watch(showPhonePreview, (show) => {
                        if (show) {
                            startPreviewAutoRefresh();
                        } else {
                            stopPreviewAutoRefresh();
                        }
                    });

                    // Lifecycle
                    onMounted(() => {
                        console.log('App mounted, initializing...');
                        connectWebSocket();
                        refreshDevices();
                        loadModels();
                        loadDevicePins();
                        initChatSessions();  // Initialize chat sessions from localStorage

                        // Initialize dark mode
                        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                        const savedTheme = localStorage.getItem('theme');
                        const initialTheme = savedTheme || (systemPrefersDark ? 'dark' : 'light');
                        darkMode.value = initialTheme === 'dark';
                        applyTheme(initialTheme);

                        // Listen for system theme changes
                        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                            if (!localStorage.getItem('theme')) {
                                darkMode.value = e.matches;
                                applyTheme(e.matches ? 'dark' : 'light');
                            }
                        });
                    });

                    onUnmounted(() => {
                        if (ws) ws.close();
                        if (reconnectTimer) clearTimeout(reconnectTimer);
                    });

                    // Watch page changes to load data
                    watch(currentPage, (page, oldPage) => {
                        // Á¶ªÂºÄ Chat È°µÈù¢Êó∂‰øùÂ≠òÊªöÂä®‰ΩçÁΩÆ
                        if (oldPage === 'chat' && chatMessagesRef.value) {
                            chatScrollPosition = chatMessagesRef.value.scrollTop;
                        }

                        // ËøõÂÖ• Chat È°µÈù¢Êó∂ÊÅ¢Â§çÊªöÂä®‰ΩçÁΩÆ
                        if (page === 'chat') {
                            Vue.nextTick(() => {
                                if (chatMessagesRef.value && chatScrollPosition > 0) {
                                    chatMessagesRef.value.scrollTop = chatScrollPosition;
                                }
                            });
                        }

                        if (page === 'scheduler') {
                            loadScheduledTasks();
                            loadSchedulerLogs();
                        }
                        if (page === 'models') {
                            loadModels();
                            loadModelPresets();
                        }
                        if (page === 'settings') {
                            loadEmailConfig();
                            loadScreenshotConfig();
                        }
                        if (page === 'rules') {
                            loadAppMappings();
                            loadTimingConfig();
                            loadActionRules();
                            loadSystemPrompts();
                        }
                    });

                    // Watch taskLogs for auto-scroll
                    watch(taskLogs, () => {
                        // Use nextTick equivalent with setTimeout
                        setTimeout(scrollLogsToBottom, 50);
                    }, { deep: true });

                    return {
                        currentPage,
                        devices,
                        selectedDevices,
                        taskContent,
                        taskRunning,
                        taskProgress,
                        taskLogs,
                        scheduledTasks,
                        modelServices,
                        activeModel,
                        modelPresets,
                        showModelForm,
                        modelFormMode,
                        modelForm,
                        openModelForm,
                        saveModel,
                        deleteModel,
                        testModelConfig,
                        addFromPreset,
                        loadModelPresets,
                        getPresetsByCategory,
                        emailConfig,
                        // Rules configuration
                        appMappings,
                        timingConfig,
                        systemPrompts,
                        showAddAppModal,
                        editingApp,
                        appForm,
                        formatTimingKey,
                        updateTiming,
                        editAppMapping,
                        saveAppMapping,
                        deleteAppMapping,
                        savePrompt,
                        resetPrompt,
                        // Action rules
                        actionRules,
                        expandedActions,
                        showRuleModal,
                        editingRuleAction,
                        editingRule,
                        ruleForm,
                        toggleActionExpand,
                        toggleRuleEnabled,
                        showAddRuleModal,
                        editRuleItem,
                        saveRuleItem,
                        deleteRuleItem,
                        resetActionRules,
                        wsConnected,
                        loading,
                        toasts,
                        devicePins,
                        logContainer,
                        showSchedulerForm,
                        schedulerFormMode,
                        schedulerForm,
                        // Scheduler logs
                        schedulerLogs,
                        showLogDetailModal,
                        logDetailData,
                        loadSchedulerLogs,
                        clearAllSchedulerLogs,
                        formatLogTime,
                        showLogDetails,
                        clearTaskLogs,
                        // Chat
                        chatMessages,
                        chatInput,
                        chatDeviceId,
                        chatRunning,
                        chatMessagesRef,
                        chatAutoEmail,
                        complexTaskMode,
                        debugMode,
                        darkMode,
                        toggleDarkMode,
                        subtaskTimeoutSeconds,
                        subtaskCountdown,
                        sendChatMessage,
                        retryMessage,
                        skipSubtask,
                        // TodoList confirmation functions
                        confirmTodoList,
                        cancelTodoList,
                        moveTodoUp,
                        moveTodoDown,
                        deleteTodo,
                        autoResizeTextarea,
                        stopChatTask,
                        // Tap preview (debug mode)
                        showTapPreview,
                        tapPreviewData,
                        tapPreviewAdjustedX,
                        tapPreviewAdjustedY,
                        confirmTapPreview,
                        cancelTapPreview,
                        handleTapPreviewClick,
                        onChatDeviceChange,
                        adjustChatInputHeight,
                        openTaskDetail,
                        showTaskDetail,
                        taskDetailData,
                        // Chat sessions
                        chatSessions,
                        currentSessionId,
                        createNewSession,
                        switchSession,
                        deleteSession,
                        formatSessionTime,
                        formatMsgTime,
                        // Phone preview
                        showPhonePreview,
                        previewDeviceId,
                        previewImage,
                        previewLoading,
                        phonePreviewStyle,
                        refreshPreview,
                        openPhonePreview,
                        startDragPreview,
                        // Functions
                        showToast,
                        refreshDevices,
                        toggleDeviceSelection,
                        selectAllDevices,
                        getDeviceName,
                        unlockDevice,
                        updateDevicePin,
                        saveDevicePin,
                        loadDevicePins,
                        pinInputValues,
                        showPinFor,
                        toggleShowPin,
                        // Wireless pairing
                        pairAddress,
                        pairCode,
                        connectAddress,
                        pairingLoading,
                        connectingLoading,
                        deviceLogs,
                        wirelessPair,
                        tcpConnect,
                        disconnectDevice,
                        // APK install
                        apkTargetDevice,
                        apkFile,
                        apkInstalling,
                        apkLogs,
                        apkFileInput,
                        onApkFileSelect,
                        installApk,
                        // File manager
                        fileDevice,
                        filePath,
                        fileList,
                        fileLoading,
                        uploadSelectedFile,
                        fileUploading,
                        uploadFileInput,
                        loadFiles,
                        navigateTo,
                        goUp,
                        formatFileSize,
                        isImageFile,
                        isVideoFile,
                        isAudioFile,
                        downloadFile,
                        onUploadFileSelect,
                        uploadFile,
                        deleteFileConfirm,
                        runTask,
                        stopTask,
                        loadScheduledTasks,
                        toggleScheduledTask,
                        runScheduledTaskNow,
                        deleteScheduledTask,
                        showCreateScheduledTask,
                        editScheduledTask,
                        cancelSchedulerForm,
                        saveScheduledTask,
                        formatScheduleType,
                        loadModels,
                        activateModel,
                        testModel,
                        loadEmailConfig,
                        saveEmailConfig,
                        testEmail,
                        // Screenshot config
                        screenshotConfig,
                        loadScreenshotConfig,
                        saveScreenshotConfig,
                        resetScreenshotConfig,
                    };
                },
            });

            app.mount('#app');
            console.log('Vue app mounted successfully');
        }

        // Initialize after page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initApp, 100);
            });
        } else {
            setTimeout(initApp, 100);
        }
    </script>
</body>

</html>