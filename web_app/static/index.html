<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutoGLM Web Server</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        [v-cloak] {
            display: none;
        }

        /* Chat Page Styles */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 48px);
            max-height: calc(100vh - 48px);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .chat-message {
            display: flex;
            gap: 10px;
            max-width: 90%;
        }

        .chat-message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .chat-message.assistant {
            align-self: flex-start;
        }

        .chat-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .chat-message.user .chat-avatar {
            background: #3b82f6;
        }

        .chat-message.assistant .chat-avatar {
            background: #10b981;
        }

        .chat-bubble {
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.5;
            word-break: break-word;
            width: 480px;
            min-width: 200px;
            max-width: 480px;
            overflow: hidden;
        }

        .chat-message.user .chat-bubble {
            background: #3b82f6;
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.assistant .chat-bubble {
            background: #f3f4f6;
            color: #18181b;
            border-bottom-left-radius: 4px;
        }

        .chat-bubble.running {
            background: #fef3c7;
            border: 1px solid #f59e0b;
        }

        .chat-bubble.error {
            background: #fee2e2;
            border: 1px solid #ef4444;
        }

        .chat-bubble.success {
            background: #d1fae5;
            border: 1px solid #10b981;
        }

        /* Compact task result */
        .task-result {
            font-size: 12px;
            margin-top: 6px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 6px;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            word-break: break-all;
        }

        .task-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .task-log-item {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            color: #666;
            padding: 2px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            word-break: break-all;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }

        .task-log-item:last-child {
            border-bottom: none;
        }

        .subtask-log-section {
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px dashed rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .subtask-log-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .subtask-log-header {
            font-size: 11px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            word-break: break-all;
            overflow-wrap: break-word;
        }

        .task-log-more {
            font-size: 10px;
            color: #9ca3af;
            font-style: italic;
        }

        .chat-meta {
            font-size: 10px;
            color: #999;
            margin-top: 4px;
            text-align: right;
        }

        /* TodoList Ê†∑Âºè (Â§çÊùÇ‰ªªÂä°Ê®°Âºè) */
        .todo-list-card {
            margin-top: 10px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .todo-list-header {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 8px;
            color: #334155;
        }

        .todo-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .todo-item:last-child {
            margin-bottom: 0;
        }

        .todo-item.pending {
            background: #fff;
            color: #64748b;
        }

        .todo-item.running {
            background: #fef3c7;
            color: #92400e;
        }

        .todo-item.completed {
            background: #d1fae5;
            color: #065f46;
        }

        .todo-item.failed {
            background: #fee2e2;
            color: #991b1b;
        }

        .todo-status {
            flex-shrink: 0;
            width: 18px;
            text-align: center;
        }

        .todo-content {
            flex: 1;
            word-break: break-all;
            overflow-wrap: break-word;
            min-width: 0;
        }

        .chat-input-container {
            padding: 12px 16px;
            border-top: 1px solid #e5e5e5;
            background: white;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid #e5e5e5;
            border-radius: 20px;
            font-size: 14px;
            resize: none;
            max-height: 100px;
            line-height: 1.4;
        }

        .chat-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .chat-send-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #3b82f6;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0;
        }

        .chat-send-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }

        .chat-send-btn:hover:not(:disabled) {
            background: #2563eb;
        }

        .chat-stop-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
            animation: pulse-red 1.5s infinite;
        }

        .chat-stop-btn:hover {
            background: #dc2626;
        }

        @keyframes pulse-red {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }

            50% {
                box-shadow: 0 0 0 8px rgba(239, 68, 68, 0);
            }
        }

        .chat-device-selector {
            padding: 8px 16px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .chat-device-selector select {
            padding: 4px 8px;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            font-size: 12px;
            max-width: 200px;
        }

        .mini-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f59e0b;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 6px;
        }

        /* Chat header with email toggle */
        .chat-header {
            padding: 8px 16px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .chat-header-right {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #666;
        }

        .email-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toggle-switch {
            position: relative;
            width: 36px;
            height: 20px;
            background: #d1d5db;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle-switch.active {
            background: #3b82f6;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: left 0.2s;
        }

        .toggle-switch.active::after {
            left: 18px;
        }

        /* Clickable task result */
        .task-result {
            font-size: 12px;
            margin-top: 6px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 6px;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            word-break: break-all;
            cursor: pointer;
            transition: background 0.2s;
        }

        .task-result:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        .task-result-hint {
            font-size: 10px;
            color: #999;
            text-align: center;
            margin-top: 4px;
        }

        /* Task Detail Modal */
        .task-detail-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .task-detail-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .task-detail-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .task-detail-header h3 {
            margin: 0;
            font-size: 16px;
        }

        .task-detail-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #999;
        }

        .task-detail-close:hover {
            color: #333;
        }

        .task-detail-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .task-detail-section {
            margin-bottom: 20px;
        }

        .task-detail-section h4 {
            font-size: 14px;
            margin: 0 0 10px 0;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .task-detail-logs {
            background: #18181b;
            color: #a1a1aa;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .task-detail-screenshot {
            text-align: center;
        }

        .task-detail-screenshot img {
            max-width: 280px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        .task-detail-screenshot-placeholder {
            padding: 40px;
            background: #f5f5f5;
            border-radius: 8px;
            color: #999;
        }

        .task-detail-stats {
            display: flex;
            gap: 20px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .task-detail-stat {
            text-align: center;
        }

        .task-detail-stat-value {
            font-size: 24px;
            font-weight: 600;
        }

        .task-detail-stat-label {
            font-size: 11px;
            color: #666;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Phone Preview Window Styles */
        .phone-preview-window {
            position: fixed;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            overflow: hidden;
            min-width: 180px;
            min-height: 200px;
        }

        .phone-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #18181b;
            color: white;
            cursor: move;
            user-select: none;
        }

        .phone-preview-title {
            font-size: 13px;
            font-weight: 500;
        }

        .phone-preview-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .phone-preview-select {
            background: #27272a;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            max-width: 100px;
            cursor: pointer;
        }

        .phone-preview-btn {
            background: #27272a;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .phone-preview-btn:hover {
            background: #3f3f46;
        }

        .phone-preview-body {
            width: 300px;
            height: 540px;
            background: #f4f4f5;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .phone-preview-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .phone-preview-placeholder {
            color: #a1a1aa;
            font-size: 12px;
            text-align: center;
            padding: 20px;
        }

        .phone-preview-toggle {
            position: fixed;
            bottom: 120px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #18181b;
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .phone-preview-toggle:hover {
            background: #27272a;
            transform: scale(1.1);
        }

        /* Chat Sessions Sidebar */
        .chat-sessions-sidebar {
            width: 220px;
            background: #f9fafb;
            border-right: 1px solid #e5e5e5;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .chat-sessions-header {
            padding: 12px;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-sessions-header h3 {
            font-size: 13px;
            margin: 0;
            color: #333;
        }

        .chat-new-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .chat-new-btn:hover {
            background: #2563eb;
        }

        .chat-sessions-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .chat-session-item {
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .chat-session-item:hover {
            background: #e5e7eb;
        }

        .chat-session-item.active {
            background: #dbeafe;
        }

        .chat-session-info {
            flex: 1;
            min-width: 0;
        }

        .chat-session-title {
            font-size: 13px;
            font-weight: 500;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-session-time {
            font-size: 11px;
            color: #999;
            margin-top: 2px;
        }

        .chat-session-delete {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .chat-session-item:hover .chat-session-delete {
            opacity: 1;
        }

        .chat-session-delete:hover {
            background: #fee2e2;
            color: #ef4444;
        }

        .chat-main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .chat-with-sidebar {
            display: flex;
            height: calc(100vh - 48px);
        }
    </style>
</head>

<body>
    <div id="app" v-cloak>
        <div class="app-container">
            <!-- Sidebar -->
            <aside class="sidebar">
                <div class="sidebar-header">
                    <h1>AutoGLM</h1>
                    <div class="subtitle">AI Phone Automation</div>
                </div>

                <ul class="nav-menu">
                    <li class="nav-item" :class="{ active: currentPage === 'chat' }" @click="currentPage = 'chat'">
                        <span>üí¨</span>
                        <span>Chat</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'devices' }"
                        @click="currentPage = 'devices'">
                        <span>üì±</span>
                        <span>Devices</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'tasks' }" @click="currentPage = 'tasks'">
                        <span>‚ñ∂Ô∏è</span>
                        <span>Run Task</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'scheduler' }"
                        @click="currentPage = 'scheduler'">
                        <span>‚è∞</span>
                        <span>Scheduler</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'models' }" @click="currentPage = 'models'">
                        <span>ü§ñ</span>
                        <span>Models</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'files' }" @click="currentPage = 'files'">
                        <span>üìÅ</span>
                        <span>Files</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'settings' }"
                        @click="currentPage = 'settings'">
                        <span>‚öôÔ∏è</span>
                        <span>Settings</span>
                    </li>
                </ul>

                <!-- Connection Status -->
                <div style="position: absolute; bottom: 20px; left: 20px; right: 20px;">
                    <div class="connection-status" :class="wsConnected ? 'connected' : 'disconnected'">
                        <span class="status-dot"></span>
                        <span>{{ wsConnected ? 'Connected' : 'Disconnected' }}</span>
                    </div>
                </div>
            </aside>

            <!-- Main Content -->
            <main class="main-content">
                <!-- Chat Page (Default) -->
                <div v-if="currentPage === 'chat'" class="fade-in chat-with-sidebar">
                    <!-- Sessions Sidebar -->
                    <div class="chat-sessions-sidebar">
                        <div class="chat-sessions-header">
                            <h3>üí¨ ‰ºöËØùÂéÜÂè≤</h3>
                            <button class="chat-new-btn" @click="createNewSession">
                                <span>+</span> Êñ∞Âª∫
                            </button>
                        </div>
                        <div class="chat-sessions-list">
                            <div v-if="chatSessions.length === 0"
                                style="text-align: center; color: #999; padding: 20px; font-size: 12px;">
                                ÊöÇÊó†‰ºöËØùËÆ∞ÂΩï
                            </div>
                            <div v-for="session in chatSessions" :key="session.id" class="chat-session-item"
                                :class="{ active: currentSessionId === session.id }" @click="switchSession(session.id)">
                                <div class="chat-session-info">
                                    <div class="chat-session-title">{{ session.title || 'Êñ∞‰ºöËØù' }}</div>
                                    <div class="chat-session-time">{{ formatSessionTime(session.updatedAt) }}</div>
                                </div>
                                <button class="chat-session-delete" @click.stop="deleteSession(session.id)"
                                    title="Âà†Èô§‰ºöËØù">
                                    üóëÔ∏è
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Main Chat Area -->
                    <div class="chat-main-area">
                        <!-- Chat Header with Device Selector and Email Toggle -->
                        <div class="chat-header">
                            <div class="chat-header-left">
                                <span>üì± ËÆæÂ§á:</span>
                                <select v-model="chatDeviceId" @change="onChatDeviceChange">
                                    <option value="">ÈÄâÊã©ËÆæÂ§á</option>
                                    <option v-for="d in devices" :key="d.id" :value="d.id">
                                        {{ d.name || d.id.substring(0, 20) }}
                                    </option>
                                </select>
                                <span v-if="chatDeviceId" style="color: #10b981;">‚úì Â∑≤ËøûÊé•</span>
                                <span v-else style="color: #f59e0b;">ËØ∑ÂÖàÈÄâÊã©ËÆæÂ§á</span>
                            </div>
                            <div class="chat-header-right">
                                <div class="email-toggle">
                                    <span>üß© Â§çÊùÇ‰ªªÂä°</span>
                                    <div class="toggle-switch" :class="{ active: complexTaskMode }"
                                        @click="complexTaskMode = !complexTaskMode"></div>
                                </div>
                                <div class="email-toggle">
                                    <span>üìß Ëá™Âä®ÂèëÈÄÅÈÇÆ‰ª∂</span>
                                    <div class="toggle-switch" :class="{ active: chatAutoEmail }"
                                        @click="chatAutoEmail = !chatAutoEmail"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Messages Area -->
                        <div class="chat-messages" ref="chatMessagesRef">
                            <div v-if="chatMessages.length === 0"
                                style="text-align: center; color: #999; padding: 40px;">
                                <div style="font-size: 48px; margin-bottom: 16px;">ü§ñ</div>
                                <div>‰Ω†Â•ΩÔºÅËØ∑ËæìÂÖ•‰ªªÂä°Êåá‰ª§ÔºåÊàë‰ºöÂ∏Æ‰Ω†Âú®ÊâãÊú∫‰∏äÊâßË°å„ÄÇ</div>
                                <div style="font-size: 12px; margin-top: 8px; color: #bbb;">‰æãÂ¶ÇÔºöÊâìÂºÄÂæÆ‰ø°ÔºåÂèëÈÄÅÊ∂àÊÅØÁªôÊüê‰∫∫...</div>
                            </div>
                            <div v-for="(msg, idx) in chatMessages" :key="idx" class="chat-message" :class="msg.role">
                                <div class="chat-avatar">{{ msg.role === 'user' ? 'üë§' : 'ü§ñ' }}</div>
                                <div class="chat-bubble" :class="msg.status || ''">
                                    <div v-if="msg.role === 'user'">{{ msg.content }}</div>
                                    <div v-else>
                                        <div v-if="msg.status === 'running'">
                                            <span class="mini-spinner"></span>Ê≠£Âú®ÊâßË°å‰ªªÂä°...
                                        </div>
                                        <div v-else>{{ msg.content }}</div>
                                        <!-- TodoList ÊòæÁ§∫ (Â§çÊùÇ‰ªªÂä°Ê®°Âºè) -->
                                        <div v-if="msg.todoList && msg.todoList.length > 0" class="todo-list-card">
                                            <div class="todo-list-header">üìã ‰ªªÂä°Ê∏ÖÂçï</div>
                                            <div v-for="(item, ti) in msg.todoList" :key="ti" class="todo-item"
                                                :class="item.status">
                                                <div class="todo-item-header">
                                                    <span class="todo-status">
                                                        <span v-if="item.status === 'completed'">‚úÖ</span>
                                                        <span v-else-if="item.status === 'running'"
                                                            class="mini-spinner"></span>
                                                        <span v-else-if="item.status === 'failed'">‚ùå</span>
                                                        <span v-else>‚¨ú</span>
                                                    </span>
                                                    <span class="todo-content">{{ item.content }}</span>
                                                </div>
                                            </div>
                                        </div>
                                        <!-- Compact Task Result (Clickable) - ÈõÜ‰∏≠ÊòæÁ§∫ÊâÄÊúâÂ≠ê‰ªªÂä°Êó•Âøó -->
                                        <div v-if="(msg.logs && msg.logs.length > 0) || (msg.todoList && msg.todoList.some(t => t.logs && t.logs.length > 0))"
                                            class="task-result" @click="openTaskDetail(msg)">
                                            <div class="task-result-header">
                                                <span>ÊâßË°åÊó•Âøó</span>
                                                <span v-if="msg.status === 'success'" style="color: #10b981;">‚úì
                                                    ÂÆåÊàê</span>
                                                <span v-else-if="msg.status === 'error'" style="color: #ef4444;">‚úó
                                                    Â§±Ë¥•</span>
                                            </div>
                                            <!-- ÊåâÂ≠ê‰ªªÂä°ÂàÜÁªÑÊòæÁ§∫Êó•Âøó -->
                                            <template
                                                v-if="msg.todoList && msg.todoList.some(t => t.logs && t.logs.length > 0)">
                                                <template v-for="(item, ti) in msg.todoList" :key="'todo-log-'+ti">
                                                    <div v-if="item.logs && item.logs.length > 0"
                                                        class="subtask-log-section">
                                                        <div class="subtask-log-header">
                                                            <span v-if="item.status === 'completed'">‚úÖ</span>
                                                            <span v-else-if="item.status === 'running'"
                                                                class="mini-spinner"></span>
                                                            <span v-else-if="item.status === 'failed'">‚ùå</span>
                                                            <span v-else>‚¨ú</span>
                                                            {{ item.content }}
                                                        </div>
                                                        <div v-for="(log, li) in item.logs.slice(-3)" :key="li"
                                                            class="task-log-item">{{ log }}</div>
                                                        <div v-if="item.logs.length > 3" class="task-log-more">... ÂÖ± {{
                                                            item.logs.length }} Êù°</div>
                                                    </div>
                                                </template>
                                            </template>
                                            <!-- ÊôÆÈÄöÊó•ÂøóÔºàÈùûÂ≠ê‰ªªÂä°Ê®°ÂºèÔºâ -->
                                            <template v-else-if="msg.logs && msg.logs.length > 0">
                                                <div v-for="(log, i) in msg.logs.slice(-3)" :key="i"
                                                    class="task-log-item">
                                                    {{ log }}
                                                </div>
                                            </template>
                                            <div class="task-result-hint">ÁÇπÂáªÊü•ÁúãËØ¶ÊÉÖÂíåÊà™Âõæ ‚Üí</div>
                                        </div>
                                    </div>
                                    <!-- Êó∂Èó¥Êà≥ÂíåtokenÊòæÁ§∫ -->
                                    <div class="chat-meta" v-if="msg.timestamp">
                                        <span>{{ formatMsgTime(msg.timestamp) }}</span>
                                        <span v-if="msg.tokens" style="margin-left: 8px;">{{ msg.tokens }} tokens</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Input Area -->
                        <div class="chat-input-container">
                            <textarea v-model="chatInput" class="chat-input" placeholder="ËæìÂÖ•‰ªªÂä°Êåá‰ª§..." rows="1"
                                @keydown.enter.exact.prevent="sendChatMessage" @input="adjustChatInputHeight"
                                :disabled="chatRunning"></textarea>
                            <button v-if="chatRunning" class="chat-stop-btn" @click="stopChatTask" title="ÂÅúÊ≠¢‰ªªÂä°">
                                ‚èπ
                            </button>
                            <button v-else class="chat-send-btn" @click="sendChatMessage"
                                :disabled="!chatInput.trim() || !chatDeviceId">
                                ‚û§
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Devices Page -->
                <div v-if="currentPage === 'devices'" class="fade-in">
                    <!-- Wireless Pairing Card -->
                    <div class="card" style="margin-bottom: 16px;">
                        <div class="card-header">
                            <h2 class="card-title">üì∂ Êó†Á∫øËøûÊé•</h2>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <!-- Wireless Pairing -->
                            <div style="padding: 12px; background: #f8fafc; border-radius: 8px;">
                                <h4 style="margin-bottom: 12px; font-size: 14px;">Êó†Á∫øÈÖçÂØπ (È¶ñÊ¨°ËøûÊé•)</h4>
                                <div class="form-group" style="margin-bottom: 8px;">
                                    <input type="text" v-model="pairAddress" class="form-input"
                                        placeholder="ÈÖçÂØπÂú∞ÂùÄ (Â¶Ç: 192.168.1.100:37000)">
                                </div>
                                <div class="form-group" style="margin-bottom: 8px;">
                                    <input type="text" v-model="pairCode" class="form-input" placeholder="6‰ΩçÈÖçÂØπÁ†Å"
                                        maxlength="6">
                                </div>
                                <button class="btn btn-primary" @click="wirelessPair" :disabled="pairingLoading">
                                    {{ pairingLoading ? 'ÈÖçÂØπ‰∏≠...' : 'üîó ÈÖçÂØπ' }}
                                </button>
                            </div>
                            <!-- TCP Connect -->
                            <div style="padding: 12px; background: #f8fafc; border-radius: 8px;">
                                <h4 style="margin-bottom: 12px; font-size: 14px;">TCP ËøûÊé• (Â∑≤ÈÖçÂØπËÆæÂ§á)</h4>
                                <div class="form-group" style="margin-bottom: 8px;">
                                    <input type="text" v-model="connectAddress" class="form-input"
                                        placeholder="ËøûÊé•Âú∞ÂùÄ (Â¶Ç: 192.168.1.100:5555)">
                                </div>
                                <button class="btn btn-success" @click="tcpConnect" :disabled="connectingLoading">
                                    {{ connectingLoading ? 'ËøûÊé•‰∏≠...' : 'üì± ËøûÊé•' }}
                                </button>
                            </div>
                        </div>
                        <!-- Connection Logs -->
                        <div v-if="deviceLogs.length > 0" style="margin-top: 12px;">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">ËøûÊé•Êó•Âøó:</div>
                            <div
                                style="background: #18181b; color: #a1a1aa; padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 11px; max-height: 100px; overflow-y: auto;">
                                <div v-for="(log, i) in deviceLogs" :key="i">{{ log }}</div>
                            </div>
                        </div>
                    </div>

                    <!-- Devices List Card -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Â∑≤ËøûÊé•ËÆæÂ§á</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-primary" @click="refreshDevices" :disabled="loading">
                                    <span v-if="loading" class="loading-spinner"></span>
                                    <span v-else>üîÑ</span>
                                    Âà∑Êñ∞
                                </button>
                            </div>
                        </div>

                        <!-- APK Install Section -->
                        <div v-if="devices.length > 0"
                            style="margin-bottom: 16px; padding: 12px; background: #f0fdf4; border-radius: 8px; border: 1px solid #86efac;">
                            <h4 style="margin-bottom: 12px; font-size: 14px;">üì¶ APK ÂÆâË£Ö</h4>
                            <div style="display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap;">
                                <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 200px;">
                                    <label class="form-label" style="font-size: 12px;">ÈÄâÊã©ËÆæÂ§á</label>
                                    <select v-model="apkTargetDevice" class="form-select">
                                        <option value="">ËØ∑ÈÄâÊã©ËÆæÂ§á</option>
                                        <option v-for="d in devices" :key="d.id" :value="d.id">
                                            {{ d.name || d.id.substring(0, 20) }}
                                        </option>
                                    </select>
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" style="font-size: 12px;">APK Êñá‰ª∂</label>
                                    <input type="file" ref="apkFileInput" accept=".apk" @change="onApkFileSelect"
                                        style="font-size: 12px;">
                                </div>
                                <button class="btn btn-success" @click="installApk"
                                    :disabled="apkInstalling || !apkTargetDevice || !apkFile">
                                    {{ apkInstalling ? 'ÂÆâË£Ö‰∏≠...' : 'üì≤ ÂÆâË£Ö' }}
                                </button>
                            </div>
                            <div v-if="apkFile" style="margin-top: 8px; font-size: 12px; color: #666;">
                                Â∑≤ÈÄâÊã©: {{ apkFile.name }} ({{ (apkFile.size / 1024 / 1024).toFixed(2) }} MB)
                            </div>
                            <!-- APK Install Logs -->
                            <div v-if="apkLogs.length > 0" style="margin-top: 12px;">
                                <div
                                    style="background: #18181b; color: #a1a1aa; padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 11px; max-height: 100px; overflow-y: auto;">
                                    <div v-for="(log, i) in apkLogs" :key="i">{{ log }}</div>
                                </div>
                            </div>
                        </div>

                        <div v-if="loading && devices.length === 0" class="empty-state" style="padding: 40px;">
                            <div class="loading-spinner" style="width: 40px; height: 40px;"></div>
                            <p style="margin-top: 16px;">Âä†ËΩΩËÆæÂ§á‰∏≠...</p>
                        </div>

                        <div v-else-if="devices.length === 0" class="empty-state">
                            <div style="font-size: 3rem; margin-bottom: 16px;">üì±</div>
                            <h3>Êú™ÂèëÁé∞ËÆæÂ§á</h3>
                            <p>ÈÄöËøáUSBËøûÊé•ËÆæÂ§áÊàñ‰ΩøÁî®‰∏äÊñπÊó†Á∫øÈÖçÂØπÔºåÁÑ∂ÂêéÁÇπÂáªÂà∑Êñ∞</p>
                        </div>

                        <div v-else class="device-grid">
                            <div v-for="device in devices" :key="device.id" class="device-card"
                                :class="{ selected: selectedDevices.includes(device.id) }"
                                @click="toggleDeviceSelection(device.id)">
                                <div class="device-header">
                                    <div class="device-icon">üì±</div>
                                    <div>
                                        <div class="device-name">{{ device.name || device.id }}</div>
                                        <div class="device-id">{{ device.id.substring(0, 30) }}...</div>
                                    </div>
                                </div>
                                <div>
                                    <span class="device-status" :class="'status-' + device.status">
                                        {{ device.status }}
                                    </span>
                                    <span v-if="device.model"
                                        style="margin-left: 8px; font-size: 0.75rem; color: var(--text-secondary);">
                                        {{ device.model }}
                                    </span>
                                </div>
                                <div
                                    style="margin-top: 12px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                                    <button class="btn btn-sm btn-secondary" @click.stop="unlockDevice(device.id)">
                                        üîì Ëß£ÈîÅ
                                    </button>
                                    <button v-if="device.id.includes(':')" class="btn btn-sm btn-danger"
                                        @click.stop="disconnectDevice(device.id)" title="Êñ≠ÂºÄÊó†Á∫øËøûÊé•">
                                        ‚ùå Êñ≠ÂºÄ
                                    </button>
                                    <div style="position: relative; display: flex; align-items: center;">
                                        <input :type="showPinFor === device.id ? 'text' : 'password'" class="form-input"
                                            style="width: 100px; height: 28px; font-size: 12px; padding: 4px 28px 4px 8px;"
                                            :placeholder="devicePins[device.id] ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : 'PIN'" @click.stop
                                            :value="pinInputValues[device.id] || ''"
                                            @input="updateDevicePin(device.id, $event.target.value)"
                                            @blur="saveDevicePin(device.id, $event.target.value)">
                                        <button v-if="devicePins[device.id] || pinInputValues[device.id]"
                                            style="position: absolute; right: 4px; background: none; border: none; cursor: pointer; font-size: 14px; padding: 2px;"
                                            @click.stop="toggleShowPin(device.id)"
                                            :title="showPinFor === device.id ? 'ÈöêËóèPIN' : 'ÊòæÁ§∫PIN'">
                                            {{ showPinFor === device.id ? 'üôà' : 'üëÅÔ∏è' }}
                                        </button>
                                    </div>
                                    <span v-if="devicePins[device.id]" style="color: #22c55e; font-size: 12px;">‚úì</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tasks Page -->
                <div v-if="currentPage === 'tasks'" class="fade-in">
                    <!-- Selected Devices -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Selected Devices ({{ selectedDevices.length }})</h2>
                            <button class="btn btn-secondary btn-sm" @click="selectAllDevices">
                                {{ selectedDevices.length === devices.length ? 'Deselect All' : 'Select All' }}
                            </button>
                        </div>
                        <div v-if="selectedDevices.length === 0" class="empty-state" style="padding: 20px;">
                            <p>No devices selected. Go to Devices page to select devices.</p>
                        </div>
                        <div v-else style="display: flex; flex-wrap: wrap; gap: 8px;">
                            <span v-for="id in selectedDevices" :key="id" class="badge badge-info">
                                {{ getDeviceName(id) }}
                            </span>
                        </div>
                    </div>

                    <!-- Task Input -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Task</h2>
                        </div>
                        <div class="form-group">
                            <textarea v-model="taskContent" class="form-textarea"
                                placeholder="Enter task instructions... (e.g., Open WeChat and send a message to...)"
                                rows="4" :disabled="taskRunning"></textarea>
                        </div>
                        <div style="display: flex; gap: 12px;">
                            <button class="btn btn-primary" @click="runTask"
                                :disabled="taskRunning || selectedDevices.length === 0">
                                ‚ñ∂Ô∏è Run Task
                            </button>
                            <button class="btn btn-danger" @click="stopTask" :disabled="!taskRunning">
                                ‚èπÔ∏è Stop
                            </button>
                        </div>

                        <!-- Progress -->
                        <div v-if="taskRunning" style="margin-top: 16px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span>Progress</span>
                                <span>{{ taskProgress }}%</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" :style="{ width: taskProgress + '%' }"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Logs -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Execution Log</h2>
                            <button class="btn btn-secondary btn-sm" @click="taskLogs = []">
                                Clear
                            </button>
                        </div>
                        <div class="log-output" ref="logContainer">
                            <div v-if="taskLogs.length === 0" style="color: #666;">
                                Logs will appear here...
                            </div>
                            <div v-for="(log, index) in taskLogs" :key="index">
                                <span style="color: #888;">[{{ log.time }}]</span> {{ log.message }}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Scheduler Page -->
                <div v-if="currentPage === 'scheduler'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Scheduled Tasks</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-primary" @click="showCreateScheduledTask">
                                    ‚ûï New Task
                                </button>
                                <button class="btn btn-secondary" @click="loadScheduledTasks">
                                    üîÑ Refresh
                                </button>
                            </div>
                        </div>

                        <div v-if="scheduledTasks.length === 0 && !showSchedulerForm" class="empty-state">
                            <div style="font-size: 3rem; margin-bottom: 16px;">‚è∞</div>
                            <h3>No scheduled tasks</h3>
                            <p>Click "New Task" to create a scheduled task</p>
                        </div>

                        <div v-else-if="!showSchedulerForm" class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Schedule</th>
                                        <th>Next Run</th>
                                        <th>Status</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="task in scheduledTasks" :key="task.id">
                                        <td>
                                            <strong>{{ task.name }}</strong>
                                            <div style="font-size: 0.75rem; color: var(--text-secondary);">
                                                {{ task.task_content.substring(0, 50) }}...
                                            </div>
                                        </td>
                                        <td>{{ formatScheduleType(task) }}</td>
                                        <td>{{ task.next_run ? new Date(task.next_run).toLocaleString() : '-' }}</td>
                                        <td>
                                            <span class="badge"
                                                :class="task.enabled ? 'badge-success' : 'badge-warning'">
                                                {{ task.enabled ? 'Enabled' : 'Disabled' }}
                                            </span>
                                        </td>
                                        <td>
                                            <button class="btn btn-sm btn-secondary" @click="editScheduledTask(task)">
                                                ‚úèÔ∏è Edit
                                            </button>
                                            <button class="btn btn-sm btn-secondary"
                                                @click="toggleScheduledTask(task.id, !task.enabled)"
                                                style="margin-left: 4px;">
                                                {{ task.enabled ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è' }}
                                            </button>
                                            <button class="btn btn-sm btn-primary" @click="runScheduledTaskNow(task.id)"
                                                style="margin-left: 4px;">
                                                ‚ö° Run
                                            </button>
                                            <button class="btn btn-sm btn-danger" @click="deleteScheduledTask(task.id)"
                                                style="margin-left: 4px;">
                                                üóëÔ∏è
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Scheduler Form -->
                        <div v-if="showSchedulerForm" style="padding: 16px;">
                            <h3 style="margin-bottom: 16px;">{{ schedulerFormMode === 'create' ? 'Create New Task' :
                                'Edit Task' }}</h3>

                            <div class="form-group">
                                <label class="form-label">Task Name</label>
                                <input type="text" v-model="schedulerForm.name" class="form-input"
                                    placeholder="My Scheduled Task">
                            </div>

                            <div class="form-group">
                                <label class="form-label">Task Content</label>
                                <textarea v-model="schedulerForm.task_content" class="form-textarea" rows="3"
                                    placeholder="Enter task instructions..."></textarea>
                            </div>

                            <div class="form-group">
                                <label class="form-label">Schedule Type</label>
                                <select v-model="schedulerForm.schedule_type" class="form-select">
                                    <option value="once">Once</option>
                                    <option value="interval">Interval</option>
                                    <option value="daily">Daily</option>
                                    <option value="weekly">Weekly</option>
                                    <option value="monthly">Monthly</option>
                                </select>
                            </div>

                            <!-- Once -->
                            <div v-if="schedulerForm.schedule_type === 'once'" class="form-group">
                                <label class="form-label">Run At</label>
                                <input type="datetime-local" v-model="schedulerForm.run_at" class="form-input">
                            </div>

                            <!-- Interval -->
                            <div v-if="schedulerForm.schedule_type === 'interval'" class="form-group">
                                <label class="form-label">Interval (minutes)</label>
                                <input type="number" v-model.number="schedulerForm.interval_minutes" class="form-input"
                                    min="1">
                            </div>

                            <!-- Daily -->
                            <div v-if="schedulerForm.schedule_type === 'daily'" class="form-group">
                                <label class="form-label">Daily Time</label>
                                <input type="time" v-model="schedulerForm.daily_time" class="form-input">
                            </div>

                            <!-- Weekly -->
                            <div v-if="schedulerForm.schedule_type === 'weekly'">
                                <div class="form-group">
                                    <label class="form-label">Days of Week</label>
                                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                        <label v-for="(day, index) in ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']"
                                            :key="index" style="display: flex; align-items: center; gap: 4px;">
                                            <input type="checkbox" :value="index" v-model="schedulerForm.weekly_days">
                                            {{ day }}
                                        </label>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Time</label>
                                    <input type="time" v-model="schedulerForm.weekly_time" class="form-input">
                                </div>
                            </div>

                            <!-- Monthly -->
                            <div v-if="schedulerForm.schedule_type === 'monthly'">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                                    <div class="form-group">
                                        <label class="form-label">Day of Month</label>
                                        <input type="number" v-model.number="schedulerForm.monthly_day"
                                            class="form-input" min="1" max="31">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Time</label>
                                        <input type="time" v-model="schedulerForm.monthly_time" class="form-input">
                                    </div>
                                </div>
                            </div>

                            <!-- Target Devices -->
                            <div class="form-group">
                                <label class="form-label">Target Devices (leave empty for all)</label>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <label v-for="device in devices" :key="device.id"
                                        style="display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: #f3f4f6; border-radius: 4px;">
                                        <input type="checkbox" :value="device.id" v-model="schedulerForm.devices">
                                        {{ device.name || device.id.substring(0, 15) }}
                                    </label>
                                </div>
                            </div>

                            <div class="form-group">
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" v-model="schedulerForm.enabled">
                                    Enable task immediately
                                </label>
                            </div>

                            <div style="display: flex; gap: 12px; margin-top: 16px;">
                                <button class="btn btn-primary" @click="saveScheduledTask" :disabled="loading">
                                    {{ schedulerFormMode === 'create' ? '‚úÖ Create' : 'üíæ Save' }}
                                </button>
                                <button class="btn btn-secondary" @click="cancelSchedulerForm">
                                    Cancel
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Scheduler Logs Card -->
                    <div class="card" style="margin-top: 16px;">
                        <div class="card-header">
                            <h2 class="card-title">üìã ÊâßË°åÊó•Âøó</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-secondary btn-sm" @click="clearAllSchedulerLogs">
                                    üóëÔ∏è Ê∏ÖÁ©∫ÊâÄÊúâ
                                </button>
                                <button class="btn btn-secondary btn-sm" @click="loadSchedulerLogs">
                                    üîÑ Âà∑Êñ∞Êó•Âøó
                                </button>
                            </div>
                        </div>

                        <div v-if="schedulerLogs.length === 0" class="empty-state" style="padding: 30px;">
                            <div style="font-size: 2rem; margin-bottom: 12px;">üìù</div>
                            <p>ÊöÇÊó†ÊâßË°åÊó•Âøó</p>
                        </div>

                        <div v-else class="table-container" style="max-height: 300px; overflow-y: auto;">
                            <table>
                                <thead>
                                    <tr>
                                        <th style="width: 60px;">Áä∂ÊÄÅ</th>
                                        <th>‰ªªÂä°ÂêçÁß∞</th>
                                        <th>ÊâßË°åÊó∂Èó¥</th>
                                        <th>ÁªìÊûú</th>
                                        <th style="width: 80px;">ËØ¶ÊÉÖ</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="(log, i) in schedulerLogs" :key="i">
                                        <td style="text-align: center;">
                                            <span v-if="log.success" style="color: #22c55e;">‚úÖ</span>
                                            <span v-else style="color: #ef4444;">‚ùå</span>
                                        </td>
                                        <td>{{ log.task_name }}</td>
                                        <td style="font-size: 12px;">{{ formatLogTime(log.timestamp) }}</td>
                                        <td>{{ log.message }}</td>
                                        <td>
                                            <button v-if="log.details" class="btn btn-sm btn-secondary"
                                                @click="showLogDetails(log)">
                                                üëÅÔ∏è
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Log Details Modal -->
                    <div v-if="showLogDetailModal" class="modal-overlay" @click.self="showLogDetailModal = false">
                        <div class="modal-content" style="max-width: 700px;">
                            <div class="modal-header">
                                <h3>üìã ÊâßË°åÊó•ÂøóËØ¶ÊÉÖ</h3>
                                <button class="btn btn-sm" @click="showLogDetailModal = false">‚úï</button>
                            </div>
                            <div class="modal-body">
                                <div style="margin-bottom: 12px;">
                                    <strong>‰ªªÂä°:</strong> {{ logDetailData.task_name }}<br>
                                    <strong>Êó∂Èó¥:</strong> {{ formatLogTime(logDetailData.timestamp) }}<br>
                                    <strong>Áä∂ÊÄÅ:</strong>
                                    <span :style="{ color: logDetailData.success ? '#22c55e' : '#ef4444' }">
                                        {{ logDetailData.success ? 'ÊàêÂäü' : 'Â§±Ë¥•' }}
                                    </span>
                                </div>
                                <div
                                    style="background: #18181b; color: #a1a1aa; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 11px; max-height: 400px; overflow-y: auto; white-space: pre-wrap;">
                                    {{ logDetailData.details || 'Êó†ËØ¶ÁªÜÊó•Âøó' }}</div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" @click="showLogDetailModal = false">ÂÖ≥Èó≠</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Models Page -->
                <div v-if="currentPage === 'models'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Ê®°ÂûãÊúçÂä°ÁÆ°ÁêÜ</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-success" @click="openModelForm('create')">
                                    ‚ûï Êñ∞Â¢ûÊ®°Âûã
                                </button>
                                <button class="btn btn-primary" @click="loadModels">
                                    üîÑ Âà∑Êñ∞
                                </button>
                            </div>
                        </div>

                        <div v-if="activeModel"
                            style="margin-bottom: 16px; padding: 12px; background: #eff6ff; border-radius: 8px;">
                            <strong>ÂΩìÂâçÊøÄÊ¥ª:</strong> {{ activeModel.name }} ({{ activeModel.model_name }})
                        </div>

                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>ÂêçÁß∞</th>
                                        <th>ÂçèËÆÆ</th>
                                        <th>Ê®°Âûã</th>
                                        <th>Base URL</th>
                                        <th>Áä∂ÊÄÅ</th>
                                        <th>Êìç‰Ωú</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="service in modelServices" :key="service.id">
                                        <td>
                                            <strong>{{ service.name }}</strong>
                                            <div style="font-size: 0.75rem; color: var(--text-secondary);">
                                                {{ service.description }}
                                            </div>
                                        </td>
                                        <td>
                                            <span class="badge" :style="{
                                                background: service.protocol === 'openai' ? '#10a37f' :
                                                           service.protocol === 'anthropic' ? '#d97706' :
                                                           service.protocol === 'gemini' ? '#4285f4' : '#666',
                                                color: 'white'
                                            }">
                                                {{ service.protocol === 'openai' ? 'OpenAI' :
                                                service.protocol === 'anthropic' ? 'Anthropic' :
                                                service.protocol === 'gemini' ? 'Gemini' : 'Unknown' }}
                                            </span>
                                        </td>
                                        <td>{{ service.model_name }}</td>
                                        <td
                                            style="font-size: 0.75rem; max-width: 200px; overflow: hidden; text-overflow: ellipsis;">
                                            {{ service.base_url }}</td>
                                        <td>
                                            <span class="badge"
                                                :class="service.is_active ? 'badge-success' : 'badge-info'">
                                                {{ service.is_active ? 'Â∑≤ÊøÄÊ¥ª' : 'Êú™ÊøÄÊ¥ª' }}
                                            </span>
                                        </td>
                                        <td>
                                            <button class="btn btn-sm btn-primary" @click="activateModel(service.id)"
                                                :disabled="service.is_active" title="ÊøÄÊ¥ªÊ≠§Ê®°Âûã">
                                                ÊøÄÊ¥ª
                                            </button>
                                            <button class="btn btn-sm btn-secondary" @click="testModel(service.id)"
                                                :disabled="loading" style="margin-left: 4px;" title="ÊµãËØïËøûÊé•">
                                                ÊµãËØï
                                            </button>
                                            <button class="btn btn-sm btn-secondary"
                                                @click="openModelForm('edit', service)" style="margin-left: 4px;"
                                                title="ÁºñËæë">
                                                ‚úèÔ∏è
                                            </button>
                                            <button class="btn btn-sm btn-danger"
                                                @click="deleteModel(service.id, service.name)"
                                                :disabled="service.is_active" style="margin-left: 4px;" title="Âà†Èô§">
                                                üóëÔ∏è
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- È¢ÑËÆæÊ®°Êùø - ÊåâÂçèËÆÆÂàÜÁ±ª -->
                        <div style="margin-top: 20px;">
                            <h3 style="font-size: 1rem; margin-bottom: 12px;">üöÄ Âø´ÈÄüÊ∑ªÂä†È¢ÑËÆæÊ®°Êùø</h3>

                            <!-- OpenAI ÂçèËÆÆ -->
                            <div v-if="getPresetsByCategory('OpenAI ÂçèËÆÆ').length > 0" style="margin-bottom: 16px;">
                                <div
                                    style="font-size: 0.85rem; color: #666; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                    <span
                                        style="background: #10a37f; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem;">OpenAI</span>
                                    <span>ÂÖºÂÆπÂçèËÆÆ (/v1/chat/completions)</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <button v-for="preset in getPresetsByCategory('OpenAI ÂçèËÆÆ')" :key="preset.id"
                                        class="btn btn-sm btn-secondary" @click="addFromPreset(preset)"
                                        :title="preset.description">
                                        {{ preset.name }}
                                    </button>
                                </div>
                            </div>

                            <!-- Anthropic ÂçèËÆÆ -->
                            <div v-if="getPresetsByCategory('Anthropic ÂçèËÆÆ').length > 0" style="margin-bottom: 16px;">
                                <div
                                    style="font-size: 0.85rem; color: #666; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                    <span
                                        style="background: #d97706; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem;">Anthropic</span>
                                    <span>ÂçèËÆÆ (/v1/messages)</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <button v-for="preset in getPresetsByCategory('Anthropic ÂçèËÆÆ')" :key="preset.id"
                                        class="btn btn-sm btn-secondary" @click="addFromPreset(preset)"
                                        :title="preset.description" style="border-color: #d97706;">
                                        {{ preset.name }}
                                    </button>
                                </div>
                            </div>

                            <!-- Gemini ÂçèËÆÆ -->
                            <div v-if="getPresetsByCategory('Gemini ÂçèËÆÆ').length > 0" style="margin-bottom: 16px;">
                                <div
                                    style="font-size: 0.85rem; color: #666; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                    <span
                                        style="background: #4285f4; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem;">Gemini</span>
                                    <span>ÂçèËÆÆ (Google AI)</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <button v-for="preset in getPresetsByCategory('Gemini ÂçèËÆÆ')" :key="preset.id"
                                        class="btn btn-sm btn-secondary" @click="addFromPreset(preset)"
                                        :title="preset.description" style="border-color: #4285f4;">
                                        {{ preset.name }}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Ê®°ÂûãÁºñËæëÂºπÁ™ó -->
                    <div v-if="showModelForm" class="modal-overlay" @click.self="showModelForm = false">
                        <div class="modal-content" style="max-width: 500px;">
                            <div class="modal-header">
                                <h3>{{ modelFormMode === 'create' ? 'Êñ∞Â¢ûÊ®°ÂûãÊúçÂä°' : 'ÁºñËæëÊ®°ÂûãÊúçÂä°' }}</h3>
                                <button class="btn btn-sm" @click="showModelForm = false">‚úï</button>
                            </div>
                            <div class="modal-body">
                                <div class="form-group">
                                    <label class="form-label">ÊúçÂä°ÂêçÁß∞ *</label>
                                    <input type="text" v-model="modelForm.name" class="form-input"
                                        placeholder="‰æãÂ¶Ç: OpenAI GPT-4">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">ÂçèËÆÆÁ±ªÂûã *</label>
                                    <select v-model="modelForm.protocol" class="form-select">
                                        <option value="openai">OpenAI ÂçèËÆÆ (/v1/chat/completions)</option>
                                        <option value="anthropic">Anthropic ÂçèËÆÆ (/v1/messages)</option>
                                        <option value="gemini">Gemini ÂçèËÆÆ (Google AI)</option>
                                    </select>
                                    <div style="font-size: 0.75rem; color: #666; margin-top: 4px;">
                                        <span v-if="modelForm.protocol === 'openai'">ÈÄÇÁî®‰∫éÂ§ßÂ§öÊï∞ÂÖºÂÆπOpenAI APIÁöÑÊúçÂä°</span>
                                        <span v-else-if="modelForm.protocol === 'anthropic'">ÈÄÇÁî®‰∫éAnthropic Claude
                                            API</span>
                                        <span v-else-if="modelForm.protocol === 'gemini'">ÈÄÇÁî®‰∫éGoogle Gemini API</span>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Base URL *</label>
                                    <input type="text" v-model="modelForm.base_url" class="form-input"
                                        :placeholder="modelForm.protocol === 'openai' ? 'https://api.openai.com/v1' : modelForm.protocol === 'anthropic' ? 'https://api.anthropic.com/v1/messages' : 'https://generativelanguage.googleapis.com/v1beta'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Ê®°ÂûãÂêçÁß∞ *</label>
                                    <input type="text" v-model="modelForm.model_name" class="form-input"
                                        :placeholder="modelForm.protocol === 'openai' ? 'gpt-4o' : modelForm.protocol === 'anthropic' ? 'claude-sonnet-4-20250514' : 'gemini-2.0-flash'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">API Key</label>
                                    <input type="password" v-model="modelForm.api_key" class="form-input"
                                        placeholder="sk-...">
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                    <div class="form-group">
                                        <label class="form-label">Max Tokens</label>
                                        <input type="number" v-model="modelForm.max_tokens" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Temperature</label>
                                        <input type="number" step="0.1" v-model="modelForm.temperature"
                                            class="form-input">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">ÊèèËø∞</label>
                                    <input type="text" v-model="modelForm.description" class="form-input"
                                        placeholder="ÂèØÈÄâÊèèËø∞">
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" @click="showModelForm = false">ÂèñÊ∂à</button>
                                <button class="btn btn-primary" @click="testModelConfig" :disabled="loading">
                                    {{ loading ? 'ÊµãËØï‰∏≠...' : 'ÊµãËØïËøûÊé•' }}
                                </button>
                                <button class="btn btn-success" @click="saveModel" :disabled="loading">
                                    {{ modelFormMode === 'create' ? 'ÂàõÂª∫' : '‰øùÂ≠ò' }}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Files Page -->
                <div v-if="currentPage === 'files'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">üìÅ Êñá‰ª∂ÁÆ°ÁêÜ</h2>
                        </div>

                        <!-- Device and Path Selection -->
                        <div
                            style="display: flex; gap: 12px; margin-bottom: 16px; align-items: flex-end; flex-wrap: wrap;">
                            <div class="form-group" style="margin-bottom: 0; min-width: 200px;">
                                <label class="form-label">ÈÄâÊã©ËÆæÂ§á</label>
                                <select v-model="fileDevice" class="form-select" @change="loadFiles">
                                    <option value="">ËØ∑ÈÄâÊã©ËÆæÂ§á</option>
                                    <option v-for="d in devices" :key="d.id" :value="d.id">
                                        {{ d.name || d.id.substring(0, 20) }}
                                    </option>
                                </select>
                            </div>
                            <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 250px;">
                                <label class="form-label">ÂΩìÂâçË∑ØÂæÑ</label>
                                <div style="display: flex; gap: 8px;">
                                    <input type="text" v-model="filePath" class="form-input" placeholder="/sdcard"
                                        @keyup.enter="loadFiles">
                                    <button class="btn btn-primary" @click="loadFiles"
                                        :disabled="!fileDevice || fileLoading">
                                        {{ fileLoading ? '*' : 'GO' }}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Quick Navigation -->
                        <div style="margin-bottom: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard')">üì± SDÂç°</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/DCIM')">üì∑ Áõ∏ÂÜå</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/Download')">üì•
                                ‰∏ãËΩΩ</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/Pictures')">üñºÔ∏è
                                ÂõæÁâá</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/Documents')">üìÑ
                                ÊñáÊ°£</button>
                            <button class="btn btn-sm btn-secondary" @click="goUp" :disabled="filePath === '/'">‚¨ÜÔ∏è
                                ‰∏äÁ∫ß</button>
                        </div>

                        <!-- Upload Section -->
                        <div
                            style="margin-bottom: 16px; padding: 12px; background: #f0fdf4; border-radius: 8px; border: 1px solid #86efac;">
                            <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                                <span style="font-size: 14px;">üì§ ‰∏ä‰º†Êñá‰ª∂Âà∞ÂΩìÂâçÁõÆÂΩï:</span>
                                <input type="file" ref="uploadFileInput" @change="onUploadFileSelect"
                                    style="font-size: 12px;">
                                <button class="btn btn-sm btn-success" @click="uploadFile"
                                    :disabled="!uploadSelectedFile || !fileDevice || fileUploading">
                                    {{ fileUploading ? '‰∏ä‰º†‰∏≠...' : '‰∏ä‰º†' }}
                                </button>
                            </div>
                        </div>

                        <!-- File List -->
                        <div v-if="!fileDevice" class="empty-state" style="padding: 40px;">
                            <div style="font-size: 3rem;">üìÅ</div>
                            <p>ËØ∑ÂÖàÈÄâÊã©ËÆæÂ§á</p>
                        </div>

                        <div v-else-if="fileLoading" class="empty-state" style="padding: 40px;">
                            <div class="loading-spinner" style="width: 40px; height: 40px;"></div>
                            <p style="margin-top: 16px;">Âä†ËΩΩ‰∏≠...</p>
                        </div>

                        <div v-else-if="fileList.length === 0" class="empty-state" style="padding: 40px;">
                            <div style="font-size: 3rem;">üìÇ</div>
                            <p>ÁõÆÂΩï‰∏∫Á©∫</p>
                        </div>

                        <div v-else class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th style="width: 40px;"></th>
                                        <th>ÂêçÁß∞</th>
                                        <th style="width: 100px;">Â§ßÂ∞è</th>
                                        <th style="width: 120px;">Êìç‰Ωú</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="file in fileList" :key="file.name"
                                        :style="{ cursor: file.is_dir ? 'pointer' : 'default' }"
                                        @dblclick="file.is_dir && navigateTo(filePath + '/' + file.name)">
                                        <td style="text-align: center;">
                                            <span v-if="file.is_dir">üìÅ</span>
                                            <span v-else-if="file.is_link">üîó</span>
                                            <span v-else-if="isImageFile(file.name)">üñºÔ∏è</span>
                                            <span v-else-if="isVideoFile(file.name)">üé¨</span>
                                            <span v-else-if="isAudioFile(file.name)">üéµ</span>
                                            <span v-else>üìÑ</span>
                                        </td>
                                        <td>
                                            <span @click="file.is_dir && navigateTo(filePath + '/' + file.name)"
                                                :style="{ color: file.is_dir ? '#3b82f6' : 'inherit', cursor: file.is_dir ? 'pointer' : 'default' }">
                                                {{ file.name }}
                                            </span>
                                        </td>
                                        <td style="font-size: 12px; color: #666;">
                                            {{ file.is_dir ? '-' : formatFileSize(file.size) }}
                                        </td>
                                        <td>
                                            <button v-if="!file.is_dir" class="btn btn-sm btn-secondary"
                                                @click="downloadFile(file.name)" title="‰∏ãËΩΩ">
                                                ‚¨áÔ∏è
                                            </button>
                                            <button class="btn btn-sm btn-danger"
                                                @click="deleteFileConfirm(file.name, file.is_dir)"
                                                style="margin-left: 4px;" title="Âà†Èô§">
                                                üóëÔ∏è
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Settings Page -->
                <div v-if="currentPage === 'settings'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">Email Settings</h2>
                        </div>

                        <div class="form-group">
                            <label class="form-label">SMTP Server</label>
                            <input type="text" v-model="emailConfig.smtp_server" class="form-input"
                                placeholder="smtp.example.com">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <div class="form-group">
                                <label class="form-label">Port</label>
                                <input type="number" v-model="emailConfig.smtp_port" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">Security</label>
                                <select v-model="emailConfig.use_ssl" class="form-select">
                                    <option :value="true">SSL</option>
                                    <option :value="false">None/TLS</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Sender Email</label>
                            <input type="email" v-model="emailConfig.sender_email" class="form-input"
                                placeholder="your@email.com">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Password / App Password</label>
                            <input type="password" v-model="emailConfig.sender_password" class="form-input"
                                placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢">
                        </div>

                        <div class="form-group">
                            <label class="form-label">Recipients (comma separated)</label>
                            <input type="text" v-model="emailConfig.recipient_emails" class="form-input"
                                placeholder="user1@email.com, user2@email.com">
                        </div>

                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" v-model="emailConfig.enabled">
                                Enable automatic email reports
                            </label>
                        </div>

                        <div style="display: flex; gap: 12px;">
                            <button class="btn btn-primary" @click="saveEmailConfig">
                                Save Settings
                            </button>
                            <button class="btn btn-secondary" @click="testEmail" :disabled="loading">
                                Send Test Email
                            </button>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">About</h2>
                        </div>
                        <p><strong>AutoGLM Web Server</strong> v0.1.0</p>
                        <p style="margin-top: 8px; color: var(--text-secondary);">
                            AI-powered phone automation tool. Web interface for Open-AutoGLM-GUI.
                        </p>
                        <p style="margin-top: 8px;">
                            <a href="/docs" target="_blank">API Documentation</a>
                        </p>
                    </div>
                </div>
            </main>
        </div>

        <!-- Task Detail Modal -->
        <div v-cloak v-if="showTaskDetail" class="task-detail-modal" @click.self="showTaskDetail = false">
            <div class="task-detail-content">
                <div class="task-detail-header">
                    <h3>üìã ‰ªªÂä°ÊâßË°åËØ¶ÊÉÖ</h3>
                    <button class="task-detail-close" @click="showTaskDetail = false">‚úï</button>
                </div>
                <div class="task-detail-body">
                    <!-- Stats -->
                    <div class="task-detail-section">
                        <div class="task-detail-stats">
                            <div class="task-detail-stat">
                                <div class="task-detail-stat-value"
                                    :style="{ color: taskDetailData.status === 'success' ? '#10b981' : '#ef4444' }">
                                    {{ taskDetailData.status === 'success' ? '‚úì' : '‚úó' }}
                                </div>
                                <div class="task-detail-stat-label">{{ taskDetailData.status === 'success' ? 'ÊâßË°åÊàêÂäü' :
                                    'ÊâßË°åÂ§±Ë¥•' }}</div>
                            </div>
                            <div class="task-detail-stat">
                                <div class="task-detail-stat-value">{{ taskDetailData.logs ? taskDetailData.logs.length
                                    : 0 }}</div>
                                <div class="task-detail-stat-label">Êó•ÂøóÊù°Êï∞</div>
                            </div>
                            <div class="task-detail-stat">
                                <div class="task-detail-stat-value">{{ (taskDetailData.screenshots &&
                                    taskDetailData.screenshots.length > 0) ? '‚úì' : '‚Äî' }}</div>
                                <div class="task-detail-stat-label">Êà™Âõæ</div>
                            </div>
                        </div>
                    </div>

                    <!-- Screenshot -->
                    <div class="task-detail-section">
                        <h4>üì∏ ÊâßË°åÊà™Âõæ</h4>
                        <div class="task-detail-screenshot">
                            <template v-if="taskDetailData.screenshots && taskDetailData.screenshots.length > 0">
                                <img v-for="s in taskDetailData.screenshots" :key="s.id" :src="s.image_url"
                                    alt="Screenshot"
                                    style="max-width: 200px; margin-bottom: 8px; cursor: pointer; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"
                                    @click="window.open(s.image_url, '_blank')">
                            </template>
                            <div v-else class="task-detail-screenshot-placeholder">
                                ÊöÇÊó†Êà™Âõæ
                            </div>
                        </div>
                    </div>

                    <!-- Full Logs -->
                    <div class="task-detail-section">
                        <h4>üìù ÂÆåÊï¥ÊâßË°åÊó•Âøó</h4>
                        <div class="task-detail-logs">
                            <div v-if="taskDetailData.logs && taskDetailData.logs.length > 0">
                                <div v-for="(log, i) in taskDetailData.logs" :key="i">{{ log }}</div>
                            </div>
                            <div v-else>ÊöÇÊó†Êó•Âøó</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Toast Notifications -->
        <div class="toast-container">
            <div v-for="toast in toasts" :key="toast.id" class="toast" :class="toast.type">
                {{ toast.message }}
            </div>
        </div>

        <!-- Floating Phone Preview Window -->
        <div v-if="showPhonePreview" class="phone-preview-window" :style="phonePreviewStyle"
            @mousedown="startDragPreview">
            <div class="phone-preview-header">
                <span class="phone-preview-title">üì± Live Preview</span>
                <div class="phone-preview-controls">
                    <select v-model="previewDeviceId" @change="refreshPreview" class="phone-preview-select"
                        @mousedown.stop>
                        <option value="">Select Device</option>
                        <option v-for="d in devices" :key="d.id" :value="d.id">
                            {{ d.name || d.id.substring(0, 15) }}
                        </option>
                    </select>
                    <button class="phone-preview-btn" @click.stop="refreshPreview" title="Refresh">üîÑ</button>
                    <button class="phone-preview-btn" @click.stop="showPhonePreview = false" title="Close">‚úï</button>
                </div>
            </div>
            <div class="phone-preview-body">
                <div v-if="!previewDeviceId" class="phone-preview-placeholder">
                    Select a device to preview
                </div>
                <img v-else-if="previewImage" :src="'data:image/png;base64,' + previewImage" class="phone-preview-image"
                    @error="previewImage = null">
                <div v-else class="phone-preview-placeholder">
                    Loading...
                </div>
            </div>
        </div>

        <!-- Phone Preview Toggle Button -->
        <button v-if="!showPhonePreview && devices.length > 0" class="phone-preview-toggle" @click="openPhonePreview"
            title="Show Phone Preview">
            üì±
        </button>
    </div>

    <!-- Vue.js 3 CDN with fallback -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script>
        // Wait for Vue to load, with fallback
        function initApp() {
            if (typeof Vue === 'undefined') {
                document.getElementById('app').innerHTML = '<div style="padding: 40px; text-align: center;"><h2>Loading failed</h2><p>Unable to load Vue.js. Please check your internet connection.</p><button onclick="location.reload()">Retry</button></div>';
                return;
            }

            const { createApp, ref, onMounted, onUnmounted, watch } = Vue;

            const app = createApp({
                setup() {
                    // State
                    const currentPage = ref('chat');  // Default to chat page
                    const devices = ref([]);
                    const selectedDevices = ref([]);
                    const taskContent = ref('');
                    const taskRunning = ref(false);
                    const taskProgress = ref(0);
                    const taskLogs = ref([]);
                    const scheduledTasks = ref([]);
                    const modelServices = ref([]);
                    const activeModel = ref(null);
                    const modelPresets = ref([]);
                    const showModelForm = ref(false);
                    const modelFormMode = ref('create');
                    const modelForm = ref(getDefaultModelForm());

                    function getDefaultModelForm() {
                        return {
                            id: '',
                            name: '',
                            base_url: '',
                            api_key: '',
                            model_name: '',
                            max_tokens: 3000,
                            temperature: 0.0,
                            top_p: 0.85,
                            frequency_penalty: 0.2,
                            description: '',
                            is_active: false,
                            protocol: 'openai',
                            category: '',
                        };
                    }
                    const emailConfig = ref({});
                    const wsConnected = ref(false);
                    const loading = ref(false);
                    const toasts = ref([]);
                    const devicePins = ref({});
                    const pinInputValues = ref({});  // Store input values for PIN fields
                    const showPinFor = ref('');  // Device ID for which PIN is visible
                    // Wireless pairing state
                    const pairAddress = ref('');
                    const pairCode = ref('');
                    const connectAddress = ref('');
                    const pairingLoading = ref(false);
                    const connectingLoading = ref(false);
                    const deviceLogs = ref([]);
                    // APK install state
                    const apkTargetDevice = ref('');
                    const apkFile = ref(null);
                    const apkInstalling = ref(false);
                    const apkLogs = ref([]);
                    const apkFileInput = ref(null);
                    // File manager state
                    const fileDevice = ref('');
                    const filePath = ref('/sdcard');
                    const fileList = ref([]);
                    const fileLoading = ref(false);
                    const uploadSelectedFile = ref(null);
                    const fileUploading = ref(false);
                    const uploadFileInput = ref(null);
                    const logContainer = ref(null);
                    const showSchedulerForm = ref(false);
                    const schedulerFormMode = ref('create');
                    const schedulerForm = ref(getDefaultSchedulerForm());
                    // Scheduler logs state
                    const schedulerLogs = ref([]);
                    const showLogDetailModal = ref(false);
                    const logDetailData = ref({});

                    // Phone preview state
                    const showPhonePreview = ref(false);
                    const previewDeviceId = ref('');
                    const previewImage = ref(null);
                    const previewLoading = ref(false);
                    const previewPosition = ref({ x: 100, y: 100 });
                    let previewInterval = null;
                    let isDragging = false;
                    let dragOffset = { x: 0, y: 0 };

                    // Chat state
                    const chatMessages = ref([]);
                    const chatInput = ref('');
                    const chatDeviceId = ref('');
                    const chatRunning = ref(false);
                    const chatMessagesRef = ref(null);
                    const chatAutoEmail = ref(false);  // Default: no auto email in chat mode
                    const complexTaskMode = ref(false);  // Â§çÊùÇ‰ªªÂä°Ê®°ÂºèÔºöÂÖàÊãÜËß£ÊàêtodolistÂÜçÈÄê‰∏™ÊâßË°å
                    let currentChatTaskId = null;
                    let chatScrollPosition = 0;  // ‰øùÂ≠ò Chat ÊªöÂä®‰ΩçÁΩÆ

                    // Chat sessions state
                    const chatSessions = ref([]);
                    const currentSessionId = ref('');
                    const SESSIONS_STORAGE_KEY = 'autoglm_chat_sessions';

                    // Task detail modal state
                    const showTaskDetail = ref(false);
                    const taskDetailData = ref({});

                    // Calculate safe position for preview window
                    function updatePreviewPosition() {
                        const windowWidth = 300;
                        const windowHeight = 580; // 540 + header
                        const margin = 20;
                        previewPosition.value = {
                            x: Math.max(margin, window.innerWidth - windowWidth - margin),
                            y: Math.max(margin, window.innerHeight - windowHeight - margin)
                        };
                    }

                    function getDefaultSchedulerForm() {
                        return {
                            id: '',
                            name: '',
                            task_content: '',
                            enabled: true,
                            schedule_type: 'daily',
                            run_at: '',
                            interval_minutes: 60,
                            daily_time: '09:00',
                            weekly_days: [1],
                            weekly_time: '09:00',
                            monthly_day: 1,
                            monthly_time: '09:00',
                            devices: [],
                        };
                    }

                    // WebSocket
                    let ws = null;
                    let reconnectTimer = null;

                    function showToast(message, type = 'success') {
                        const id = Date.now();
                        toasts.value.push({ id, message, type });
                        setTimeout(() => {
                            toasts.value = toasts.value.filter(t => t.id !== id);
                        }, 3000);
                    }

                    // API calls
                    async function apiCall(url, options = {}) {
                        try {
                            const response = await fetch(url, {
                                ...options,
                                headers: {
                                    'Content-Type': 'application/json',
                                    ...options.headers,
                                },
                            });
                            const data = await response.json();
                            if (!response.ok) {
                                throw new Error(data.detail || 'API Error');
                            }
                            return data;
                        } catch (error) {
                            showToast(error.message, 'error');
                            throw error;
                        }
                    }

                    // WebSocket connection
                    function connectWebSocket() {
                        try {
                            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                            const wsUrl = `${protocol}//${window.location.host}/ws`;
                            ws = new WebSocket(wsUrl);

                            ws.onopen = () => {
                                wsConnected.value = true;
                                console.log('WebSocket connected');
                            };

                            ws.onclose = () => {
                                wsConnected.value = false;
                                console.log('WebSocket disconnected');
                                reconnectTimer = setTimeout(connectWebSocket, 3000);
                            };

                            ws.onmessage = (event) => {
                                try {
                                    const data = JSON.parse(event.data);
                                    handleWebSocketMessage(data);
                                } catch (e) {
                                    console.error('WebSocket message error:', e);
                                }
                            };

                            ws.onerror = (error) => {
                                console.error('WebSocket error:', error);
                            };
                        } catch (e) {
                            console.error('WebSocket connection error:', e);
                        }
                    }

                    function handleWebSocketMessage(data) {
                        switch (data.type) {
                            case 'init':
                                if (data.task_status) {
                                    taskRunning.value = data.task_status.running;
                                    if (data.task_status.task) {
                                        taskProgress.value = data.task_status.task.progress || 0;
                                    }
                                }
                                break;
                            case 'task_log':
                                // 1. Run Task Page Logs (taskLogs) - Only for manual tasks
                                if (!data.task_type || data.task_type === 'manual') {
                                    taskLogs.value.push({
                                        time: new Date().toLocaleTimeString(),
                                        message: data.message,
                                    });
                                }

                                // 2. Scheduler Page Logs (schedulerLogs) - Only for scheduled tasks
                                if (data.task_type === 'scheduled') {
                                    // Add to the beginning of the list (newest first) to match API sort order
                                    schedulerLogs.value.unshift({
                                        timestamp: new Date().toISOString(),
                                        message: data.message,
                                        task_id: data.task_id,
                                        success: null // Log entry doesn't strictly have success status yet
                                    });
                                    // Limit size
                                    if (schedulerLogs.value.length > 50) {
                                        schedulerLogs.value = schedulerLogs.value.slice(0, 50);
                                    }
                                }

                                // 3. Chat Page Logs (chatMessages)
                                if (chatMessages.value.length > 0) {
                                    // ÊâæÂà∞ÂåπÈÖçtaskIdÁöÑÊ∂àÊÅØÔºåÊàñËÄÖÊúÄÂêé‰∏ÄÊù°runningÁä∂ÊÄÅÁöÑassistantÊ∂àÊÅØ
                                    // ÂØπ‰∫éÂ§çÊùÇ‰ªªÂä°Ôºå‰πüÊé•ÂèóÊúâtodoListÁöÑÊ∂àÊÅØ
                                    let targetMsg = null;
                                    for (let i = chatMessages.value.length - 1; i >= 0; i--) {
                                        const msg = chatMessages.value[i];
                                        if (msg.role === 'assistant') {
                                            // Â¶ÇÊûúÊ∂àÊÅØÊ≠£Âú®ËøêË°åÔºåÊàñËÄÖÊòØÊúâtodoListÁöÑÂ§çÊùÇ‰ªªÂä°ÔºàÊ≠£Âú®ÊâßË°å‰∏≠Ôºâ
                                            const isRunning = msg.status === 'running';
                                            const isComplexTaskRunning = msg.todoList && msg.todoList.length > 0 &&
                                                msg.todoList.some(t => t.status === 'running' || t.status === 'pending');

                                            if (isRunning || isComplexTaskRunning) {
                                                // Â¶ÇÊûúÊúâtaskIdÂàôÂøÖÈ°ªÂåπÈÖçÔºåÂê¶Âàô‰ΩøÁî®ÊúÄÂêé‰∏ÄÊù°
                                                if (data.task_id && msg.taskId && msg.taskId !== data.task_id) {
                                                    continue;  // taskId‰∏çÂåπÈÖçÔºåË∑≥Ëøá
                                                }
                                                targetMsg = msg;
                                                break;
                                            }
                                        }
                                    }

                                    if (targetMsg) {
                                        // ‰ΩøÁî®Êï∞ÁªÑÊâ©Â±ïËøêÁÆóÁ¨¶Âº∫Âà∂Ëß¶Âèë Vue Êõ¥Êñ∞ (Reactivity)
                                        const newLogs = targetMsg.logs ? [...targetMsg.logs, data.message] : [data.message];
                                        targetMsg.logs = newLogs;

                                        // Â§çÊùÇ‰ªªÂä°Ê®°ÂºèÔºöÂ∞ÜÊó•Âøó‰πüÊ∑ªÂä†Âà∞ÂΩìÂâçÊâßË°åÁöÑÂ≠ê‰ªªÂä°
                                        // ‰∏çÊ£ÄÊü•Â≠ê‰ªªÂä°Áä∂ÊÄÅÔºåÂõ†‰∏∫Êó•ÂøóÂèØËÉΩÂú®Áä∂ÊÄÅÂèòÊõ¥ÂêéÊâçÂà∞Ëææ
                                        if (targetMsg.todoList && targetMsg.currentTodoIndex !== undefined && targetMsg.currentTodoIndex >= 0) {
                                            const currentTodo = targetMsg.todoList[targetMsg.currentTodoIndex];
                                            if (currentTodo) {
                                                const subNewLogs = currentTodo.logs ? [...currentTodo.logs, data.message] : [data.message];
                                                currentTodo.logs = subNewLogs;
                                            }
                                        }

                                        scrollChatToBottom();
                                    }
                                }
                                break;
                            case 'task_progress':
                                taskProgress.value = data.progress;
                                break;
                            case 'task_finished':
                                taskRunning.value = false;
                                // Ê£ÄÊü•ÊúÄÂêé‰∏ÄÊù°Ê∂àÊÅØÊòØÂê¶ÊòØÂ§çÊùÇ‰ªªÂä°ÔºàÊúâ todoListÔºâ
                                const lastMsgForToast = chatMessages.value.length > 0 ? chatMessages.value[chatMessages.value.length - 1] : null;
                                const isComplexTask = lastMsgForToast && lastMsgForToast.todoList && lastMsgForToast.todoList.length > 0;

                                if (isComplexTask) {
                                    // Â§çÊùÇ‰ªªÂä°Â≠ê‰ªªÂä°ÂÆåÊàêÔºåÊòæÁ§∫ÁÆÄÁü≠ÊèêÁ§∫
                                    const currentIdx = lastMsgForToast.currentTodoIndex;
                                    if (currentIdx !== undefined && currentIdx >= 0 && currentIdx < lastMsgForToast.todoList.length) {
                                        showToast(`Â≠ê‰ªªÂä° ${currentIdx + 1}/${lastMsgForToast.todoList.length} ${data.success ? 'ÂÆåÊàê' : 'Â§±Ë¥•'}`, data.success ? 'success' : 'error');
                                    }
                                } else {
                                    // ÊôÆÈÄö‰ªªÂä°ÔºåÊòæÁ§∫ÂÆåÊï¥ÊèêÁ§∫
                                    showToast(data.message, data.success ? 'success' : 'error');
                                }
                                // Update chat message status and use screenshot from WebSocket
                                // Â§çÊùÇ‰ªªÂä°Ê®°Âºè‰∏ãÔºàÊ∂àÊÅØÊúâtodoListÔºâÔºå‰∏çË¶ÅÂú®ËøôÈáå‰øÆÊîπÁä∂ÊÄÅÔºåËÆ©Âæ™ÁéØËá™Â∑±ÊéßÂà∂
                                // ÊôÆÈÄö‰ªªÂä°ÔºàÊ∂àÊÅØÊ≤°ÊúâtodoListÔºâÊâçÂú®ËøôÈáåÊõ¥Êñ∞Áä∂ÊÄÅ
                                if (chatRunning.value && chatMessages.value.length > 0 && !isComplexTask) {
                                    const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                                    if (lastMsg.role === 'assistant' && lastMsg.status === 'running') {
                                        lastMsg.status = data.success ? 'success' : 'error';
                                        // ÊòæÁ§∫ÂÖ∑‰ΩìÁöÑÈîôËØØ‰ø°ÊÅØ
                                        if (data.success) {
                                            lastMsg.content = '‚úÖ ‰ªªÂä°ÊâßË°åÂÆåÊàêÔºÅ';
                                        } else {
                                            // ÊèêÂèñÂπ∂Ê†ºÂºèÂåñÈîôËØØ‰ø°ÊÅØ
                                            let errorMsg = data.message || '‰ªªÂä°ÊâßË°åÂ§±Ë¥•';
                                            if (errorMsg.includes('Token error') || errorMsg.includes('limited')) {
                                                errorMsg = '‚ùå ' + errorMsg + '\n\nüí° ÊèêÁ§∫ÔºöÊ®°ÂûãÊúçÂä°Ë¢´ÈôêÊµÅÔºåËØ∑Á®çÂêéÂÜçËØï„ÄÇ';
                                            } else if (errorMsg.includes('Task failed:')) {
                                                errorMsg = '‚ùå ' + errorMsg.replace('Task failed:', '‰ªªÂä°Â§±Ë¥•:');
                                            } else {
                                                errorMsg = '‚ùå ‰ªªÂä°ÊâßË°åÂ§±Ë¥•: ' + errorMsg;
                                            }
                                            lastMsg.content = errorMsg;
                                        }
                                        // ‰ΩøÁî® screenshot_id ‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÊà™ÂõæÔºå‰∏çÂÜç‰ΩøÁî® base64
                                        if (data.screenshot_id && currentSessionId.value && lastMsg.id) {
                                            // Á´ãÂç≥Êõ¥Êñ∞Ê∂àÊÅØÁöÑ screenshots Êï∞ÁªÑÔºå‰ΩøÁî® screenshot_id ÊûÑÂª∫ image_url
                                            if (!lastMsg.screenshots) {
                                                lastMsg.screenshots = [];
                                            }
                                            // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®Ëøô‰∏™Êà™ÂõæÔºåÈÅøÂÖçÈáçÂ§çÊ∑ªÂä†
                                            const exists = lastMsg.screenshots.some(s => s.id === data.screenshot_id);
                                            if (!exists) {
                                                lastMsg.screenshots.push({
                                                    id: data.screenshot_id,
                                                    image_url: `/api/chat/screenshots/${data.screenshot_id}`
                                                });
                                            }
                                        }
                                    }
                                    chatRunning.value = false;
                                    // Save session after task completes
                                    saveCurrentSession();
                                }
                                break;
                            case 'task_tokens':
                                // Update chat message tokens
                                if (chatMessages.value.length > 0) {
                                    // Find target message
                                    let targetMsg = null;
                                    for (let i = chatMessages.value.length - 1; i >= 0; i--) {
                                        const msg = chatMessages.value[i];
                                        if (msg.role === 'assistant') {
                                            const isRunning = msg.status === 'running';
                                            const isComplexTaskRunning = msg.todoList && msg.todoList.length > 0 &&
                                                msg.todoList.some(t => t.status === 'running' || t.status === 'pending');

                                            if (isRunning || isComplexTaskRunning) {
                                                if (data.task_id && msg.taskId && msg.taskId !== data.task_id) {
                                                    continue;
                                                }
                                                targetMsg = msg;
                                                break;
                                            }
                                        }
                                    }

                                    if (targetMsg) {
                                        if (!targetMsg.tokens) targetMsg.tokens = 0;
                                        // Á¥ØÂä† token (Âõ†‰∏∫ÊòØ‰∏ÄÊ¨°Ê¨°Êé®ËøáÊù•ÁöÑ)
                                        targetMsg.tokens += data.total_tokens;
                                    }
                                }
                                break;
                            case 'devices':
                                devices.value = data.devices;
                                break;
                            case 'ping':
                                if (ws && ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify({ type: 'pong' }));
                                }
                                break;
                        }
                    }

                    // Device functions

                    // Chat Session Management Functions
                    function loadSessions() {
                        try {
                            const stored = localStorage.getItem(SESSIONS_STORAGE_KEY);
                            if (stored) {
                                chatSessions.value = JSON.parse(stored);
                                // Sort by updatedAt descending
                                chatSessions.value.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                            }
                        } catch (e) {
                            console.error('Failed to load sessions:', e);
                            chatSessions.value = [];
                        }
                    }

                    function saveSessions() {
                        try {
                            // Deep copy sessions to avoid modifying reactive state
                            const sessionsToSave = JSON.parse(JSON.stringify(chatSessions.value));

                            // Remove heavy data (screenshots metadata and large logs) from saved sessions
                            sessionsToSave.forEach(session => {
                                if (session.messages) {
                                    session.messages.forEach(msg => {
                                        // Remove screenshot base64 (if any legacy data exists)
                                        if (msg.screenshot) {
                                            msg.screenshot = null;
                                        }
                                        // Screenshots are stored in database, only keep minimal metadata
                                        // Limit logs size
                                        if (msg.logs && msg.logs.length > 50) {
                                            msg.logs = msg.logs.slice(-50); // Keep only last 50 logs
                                        }
                                        // Clean subtask logs too
                                        if (msg.todoList) {
                                            msg.todoList.forEach(todo => {
                                                if (todo.logs && todo.logs.length > 20) {
                                                    todo.logs = todo.logs.slice(-20);
                                                }
                                            });
                                        }
                                    });
                                }
                            });

                            localStorage.setItem(SESSIONS_STORAGE_KEY, JSON.stringify(sessionsToSave));
                        } catch (e) {
                            console.error('Failed to save sessions:', e);
                            // Fallback: try to save only the current session if full save fails
                            if (e.name === 'QuotaExceededError') {
                                try {
                                    // Try to clean up old sessions
                                    const currentSession = sessionsToSave.find(s => s.id === currentSessionId.value);
                                    if (currentSession) {
                                        localStorage.setItem(SESSIONS_STORAGE_KEY, JSON.stringify([currentSession]));
                                        showToast('Â≠òÂÇ®Á©∫Èó¥‰∏çË∂≥ÔºåÂ∑≤Ê∏ÖÁêÜÊóß‰ºöËØù', 'warning');
                                    }
                                } catch (retryError) {
                                    showToast('Â≠òÂÇ®Á©∫Èó¥Â∑≤Êª°ÔºåÊó†Ê≥ï‰øùÂ≠ò‰ºöËØù', 'error');
                                }
                            }
                        }
                    }

                    function saveCurrentSession() {
                        if (!currentSessionId.value) return;

                        const session = chatSessions.value.find(s => s.id === currentSessionId.value);
                        if (session) {
                            session.messages = chatMessages.value;
                            // ‰ºöËØùÊó∂Èó¥‰ª•ÊúÄÊñ∞Ê∂àÊÅØÊó∂Èó¥‰∏∫ÂáÜ
                            if (chatMessages.value.length > 0) {
                                const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                                if (lastMsg.timestamp) {
                                    session.updatedAt = lastMsg.timestamp;
                                }
                            }
                            // Update title from first user message if not set
                            if (!session.title || session.title === 'Êñ∞‰ºöËØù') {
                                const firstUserMsg = chatMessages.value.find(m => m.role === 'user');
                                if (firstUserMsg) {
                                    session.title = firstUserMsg.content.substring(0, 30) + (firstUserMsg.content.length > 30 ? '...' : '');
                                }
                            }
                            saveSessions();

                            // ÂêåÊ≠• assistant Ê∂àÊÅØÁöÑ status Âíå todoList Âà∞ÊúçÂä°Âô®Êï∞ÊçÆÂ∫ì
                            saveMessageStatusToServer();
                        }
                    }

                    // ‰øùÂ≠òÊ∂àÊÅØÁä∂ÊÄÅÂà∞ÊúçÂä°Âô®ÔºàÈùûÈòªÂ°ûÔºå‰∏çÂΩ±ÂìçÊú¨Âú∞Êìç‰ΩúÔºâ
                    async function saveMessageStatusToServer() {
                        if (!currentSessionId.value) return;

                        // ÊâæÂá∫ÈúÄË¶Å‰øùÂ≠òÁä∂ÊÄÅÁöÑ assistant Ê∂àÊÅØ
                        for (const msg of chatMessages.value) {
                            if (msg.role === 'assistant' && msg.id && (msg.status || msg.todoList)) {
                                try {
                                    await apiCall(`/api/chat/sessions/${currentSessionId.value}/messages/${msg.id}`, {
                                        method: 'PATCH',
                                        body: JSON.stringify({
                                            status: msg.status || null,
                                            content: msg.content || null,
                                            todo_list: msg.todoList || null
                                        })
                                    });
                                } catch (error) {
                                    // ÈùôÈªòÂ§±Ë¥•Ôºå‰∏çÂΩ±ÂìçÁî®Êà∑‰ΩìÈ™å
                                    console.debug('Failed to save message status to server:', error);
                                }
                            }
                        }
                    }

                    async function createNewSession() {
                        // Save current session first
                        saveCurrentSession();

                        // Â∞ùËØï‰ªéÊúçÂä°Âô®ÂàõÂª∫‰ºöËØùÔºåÁ°Æ‰øù ID ÂêåÊ≠•
                        try {
                            const deviceId = chatDeviceId.value || 'default';
                            const serverSession = await apiCall('/api/chat/sessions', {
                                method: 'POST',
                                body: JSON.stringify({
                                    device_id: deviceId,
                                    title: 'Êñ∞‰ºöËØù'
                                })
                            });

                            const newSession = {
                                id: serverSession.id,
                                title: serverSession.title || 'Êñ∞‰ºöËØù',
                                deviceId: serverSession.device_id,
                                messages: [],
                                createdAt: serverSession.created_at,
                                updatedAt: serverSession.updated_at
                            };
                            chatSessions.value.unshift(newSession);
                            currentSessionId.value = newSession.id;
                            chatMessages.value = [];
                            saveSessions();
                        } catch (error) {
                            console.error('Failed to create session on server:', error);
                            // ÈôçÁ∫ßÊñπÊ°àÔºö‰ΩøÁî®Êú¨Âú∞ ID
                            const newSession = {
                                id: Date.now().toString(),
                                title: 'Êñ∞‰ºöËØù',
                                messages: [],
                                createdAt: new Date().toISOString(),
                                updatedAt: new Date().toISOString()
                            };
                            chatSessions.value.unshift(newSession);
                            currentSessionId.value = newSession.id;
                            chatMessages.value = [];
                            saveSessions();
                        }
                    }

                    async function switchSession(sessionId) {
                        if (sessionId === currentSessionId.value) return;

                        // Save current session first
                        saveCurrentSession();

                        const session = chatSessions.value.find(s => s.id === sessionId);
                        if (session) {
                            currentSessionId.value = session.id;
                            chatMessages.value = session.messages || [];

                            // Â∞ùËØï‰ªéÊúçÂä°Âô®Âä†ËΩΩÂÆåÊï¥ÁöÑÊ∂àÊÅØÊï∞ÊçÆÔºàÂåÖÊã¨ screenshotsÔºâ
                            // ËøôÊ†∑ÂèØ‰ª•Á°Æ‰øùÊúçÂä°ÈáçÂêØÂêé‰πüËÉΩÁúãÂà∞Êà™Âõæ
                            try {
                                const detailData = await apiCall(`/api/chat/sessions/${sessionId}/detail`);
                                if (detailData && detailData.messages) {
                                    // Êõ¥Êñ∞Ê∂àÊÅØÊï∞ÊçÆÔºåÁâπÂà´ÊòØ screenshots
                                    detailData.messages.forEach(serverMsg => {
                                        const localMsg = chatMessages.value.find(m => m.id === serverMsg.id);
                                        if (localMsg && serverMsg.screenshots && serverMsg.screenshots.length > 0) {
                                            localMsg.screenshots = serverMsg.screenshots;
                                        }
                                    });
                                }
                            } catch (error) {
                                // Â¶ÇÊûú‰ºöËØù‰∏çÂ≠òÂú®Ôºà404ÔºâÔºå‰ªéÂàóË°®‰∏≠ÁßªÈô§
                                if (error.message && error.message.includes('Session not found')) {
                                    console.warn(`Session ${sessionId} not found, removing from list`);
                                    const index = chatSessions.value.findIndex(s => s.id === sessionId);
                                    if (index !== -1) {
                                        chatSessions.value.splice(index, 1);
                                        saveSessions();

                                        // Â¶ÇÊûúÊúâÂÖ∂‰ªñ‰ºöËØùÔºåÂàáÊç¢Âà∞‰∏ã‰∏Ä‰∏™ÔºåÂê¶ÂàôÂàõÂª∫Êñ∞‰ºöËØù
                                        if (chatSessions.value.length > 0) {
                                            await switchSession(chatSessions.value[0].id);
                                            return;
                                        } else {
                                            createNewSession();
                                            return;
                                        }
                                    }
                                } else {
                                    console.error('Failed to load session detail from server:', error);
                                    // ÂÖ∂‰ªñÈîôËØØÁªßÁª≠‰ΩøÁî®Êú¨Âú∞Êï∞ÊçÆ
                                }
                            }

                            // ‰ΩøÁî® nextTick Á°Æ‰øù DOM Êõ¥Êñ∞ÂêéÂÜçÊªöÂä®
                            Vue.nextTick(() => {
                                scrollChatToBottom();
                            });
                        }
                    }

                    async function deleteSession(sessionId) {
                        if (!confirm('Á°ÆÂÆöË¶ÅÂà†Èô§Ëøô‰∏™‰ºöËØùÂêóÔºü')) return;

                        // ‰ªéÊúçÂä°Âô®Âà†Èô§‰ºöËØù
                        try {
                            await apiCall(`/api/chat/sessions/${sessionId}`, { method: 'DELETE' });
                        } catch (error) {
                            console.error('Failed to delete session from server:', error);
                            // ÁªßÁª≠Âà†Èô§Êú¨Âú∞‰ºöËØùÔºåÂç≥‰ΩøÊúçÂä°Âô®Âà†Èô§Â§±Ë¥•
                        }

                        // ‰ªéÊú¨Âú∞Âà†Èô§‰ºöËØù
                        const index = chatSessions.value.findIndex(s => s.id === sessionId);
                        if (index !== -1) {
                            chatSessions.value.splice(index, 1);
                            saveSessions();

                            // If deleted current session, switch to another or create new
                            if (sessionId === currentSessionId.value) {
                                if (chatSessions.value.length > 0) {
                                    await switchSession(chatSessions.value[0].id);
                                } else {
                                    await createNewSession();
                                }
                            }
                        }
                    }

                    function formatSessionTime(isoString) {
                        if (!isoString) return '';
                        const date = new Date(isoString);
                        const now = new Date();
                        const diffMs = now - date;
                        const diffMins = Math.floor(diffMs / 60000);
                        const diffHours = Math.floor(diffMs / 3600000);
                        const diffDays = Math.floor(diffMs / 86400000);

                        if (diffMins < 1) return 'ÂàöÂàö';
                        if (diffMins < 60) return `${diffMins}ÂàÜÈíüÂâç`;
                        if (diffHours < 24) return `${diffHours}Â∞èÊó∂Ââç`;
                        if (diffDays < 7) return `${diffDays}Â§©Ââç`;
                        return date.toLocaleDateString();
                    }

                    function formatMsgTime(timestamp) {
                        if (!timestamp) return '';
                        const date = new Date(timestamp);
                        return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    }

                    async function initChatSessions() {
                        // ÂÖà‰ªéÊúçÂä°Âô®Âä†ËΩΩ‰ºöËØùÂàóË°®ÔºåÁ°Æ‰øùÊï∞ÊçÆÂêåÊ≠•
                        try {
                            const serverSessions = await apiCall('/api/chat/sessions?limit=50');
                            if (serverSessions && serverSessions.length > 0) {
                                // Â∞ÜÊúçÂä°Âô®‰ºöËØùËΩ¨Êç¢‰∏∫ÂâçÁ´ØÊ†ºÂºè
                                const serverSessionsFormatted = serverSessions.map(s => ({
                                    id: s.id,
                                    title: s.title || 'Êñ∞‰ºöËØù',
                                    deviceId: s.device_id,
                                    status: s.status,
                                    updatedAt: s.updated_at,
                                    totalTokens: s.total_tokens || 0,
                                    messages: []  // Ê∂àÊÅØÁ®çÂêéÂä†ËΩΩ
                                }));

                                // ÂêàÂπ∂ÊúçÂä°Âô®‰ºöËØùÂíåÊú¨Âú∞‰ºöËØùÔºà‰ºòÂÖà‰ΩøÁî®ÊúçÂä°Âô®Êï∞ÊçÆÔºâ
                                const localSessions = [];
                                try {
                                    const stored = localStorage.getItem(SESSIONS_STORAGE_KEY);
                                    if (stored) {
                                        localSessions.push(...JSON.parse(stored));
                                    }
                                } catch (e) {
                                    console.warn('Failed to load local sessions:', e);
                                }

                                // ÂêàÂπ∂ÔºöÊúçÂä°Âô®‰ºöËØù‰ºòÂÖàÔºå‰ΩÜ‰øùÁïôÊú¨Âú∞‰ºöËØùÁöÑÊ∂àÊÅØÊï∞ÊçÆÔºàÂ¶ÇÊûúÊúçÂä°Âô®‰ºöËØùÂ≠òÂú®Ôºâ
                                const mergedSessions = [];
                                const serverSessionIds = new Set(serverSessionsFormatted.map(s => s.id));

                                // ÂÖàÊ∑ªÂä†ÊúçÂä°Âô®‰ºöËØù
                                for (const serverSession of serverSessionsFormatted) {
                                    const localSession = localSessions.find(s => s.id === serverSession.id);
                                    if (localSession && localSession.messages) {
                                        // ‰øùÁïôÊú¨Âú∞Ê∂àÊÅØÊï∞ÊçÆ
                                        serverSession.messages = localSession.messages;
                                    }
                                    mergedSessions.push(serverSession);
                                }

                                // Ê∑ªÂä†Êú¨Âú∞Â≠òÂú®‰ΩÜÊúçÂä°Âô®‰∏çÂ≠òÂú®ÁöÑ‰ºöËØùÔºàÂèØËÉΩÊòØÊú™ÂêåÊ≠•ÁöÑÔºâ
                                for (const localSession of localSessions) {
                                    if (!serverSessionIds.has(localSession.id)) {
                                        mergedSessions.push(localSession);
                                    }
                                }

                                // ÊåâÊõ¥Êñ∞Êó∂Èó¥ÊéíÂ∫è
                                mergedSessions.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                                chatSessions.value = mergedSessions;
                                saveSessions();
                            } else {
                                // ÊúçÂä°Âô®Ê≤°Êúâ‰ºöËØùÔºå‰ΩøÁî®Êú¨Âú∞‰ºöËØù
                                loadSessions();
                            }
                        } catch (error) {
                            console.error('Failed to load sessions from server:', error);
                            // ÊúçÂä°Âô®Âä†ËΩΩÂ§±Ë¥•Ôºå‰ΩøÁî®Êú¨Âú∞‰ºöËØù
                            loadSessions();
                        }

                        // Auto-enter most recent session or create new one
                        if (chatSessions.value.length > 0) {
                            const mostRecent = chatSessions.value[0];
                            currentSessionId.value = mostRecent.id;

                            // Â¶ÇÊûúÊú¨Âú∞ÊúâÊ∂àÊÅØÊï∞ÊçÆÔºåÂÖà‰ΩøÁî®Êú¨Âú∞Êï∞ÊçÆ
                            if (mostRecent.messages && mostRecent.messages.length > 0) {
                                chatMessages.value = mostRecent.messages;
                            } else {
                                chatMessages.value = [];
                            }

                            // Â∞ùËØï‰ªéÊúçÂä°Âô®Âä†ËΩΩÂÆåÊï¥ÁöÑÊ∂àÊÅØÊï∞ÊçÆÔºàÂåÖÊã¨ screenshotsÔºâ
                            // ËøôÊ†∑ÂèØ‰ª•Á°Æ‰øùÊúçÂä°ÈáçÂêØÂêé‰πüËÉΩÁúãÂà∞Êà™Âõæ
                            try {
                                // Âú®Âä†ËΩΩÊúçÂä°Âô®Êï∞ÊçÆÂâçÔºåÂÖà‰øùÂ≠òÊú¨Âú∞Ê∂àÊÅØÁöÑÁä∂ÊÄÅÂíå todoListÔºàÊúçÂä°Âô®‰∏ç‰øùÂ≠òËøô‰∫õÂ≠óÊÆµÔºâ
                                const localDataMap = {};
                                if (chatMessages.value && chatMessages.value.length > 0) {
                                    chatMessages.value.forEach(msg => {
                                        if (msg.id) {
                                            localDataMap[msg.id] = {
                                                status: msg.status,
                                                todoList: msg.todoList,
                                                currentTodoIndex: msg.currentTodoIndex,
                                                logs: msg.logs || []  // ‰πü‰øùÂ≠òÊú¨Âú∞Êó•Âøó‰Ωú‰∏∫ÂêéÂ§á
                                            };
                                        }
                                    });
                                }

                                const detailData = await apiCall(`/api/chat/sessions/${mostRecent.id}/detail`);
                                if (detailData && detailData.messages) {
                                    // ‰ΩøÁî®ÊúçÂä°Âô®ÁöÑÊ∂àÊÅØÊï∞ÊçÆÔºàÊõ¥ÂÆåÊï¥ÔºåÂåÖÂê´ screenshotsÔºâ
                                    chatMessages.value = detailData.messages.map(msg => {
                                        const localData = localDataMap[msg.id] || {};
                                        // ‰ºòÂÖà‰ΩøÁî®ÊúçÂä°Âô®Áä∂ÊÄÅÔºåÂÖ∂Ê¨°‰ΩøÁî®Êú¨Âú∞‰øùÂ≠òÁöÑÁä∂ÊÄÅÔºåÊúÄÂêéÈªòËÆ§ success
                                        let status = null;
                                        let todoList = null;
                                        if (msg.role === 'assistant') {
                                            // ÊúçÂä°Âô®Áé∞Âú®ÂèØËÉΩËøîÂõû status Âíå todo_list
                                            status = msg.status || localData.status || 'success';
                                            // todo_list ‰ªéÊúçÂä°Âô®ËøîÂõûÔºàÂ¶ÇÊûúÊúâÔºâÔºåÂê¶Âàô‰ΩøÁî®Êú¨Âú∞
                                            todoList = msg.todo_list || localData.todoList || null;
                                        }

                                        // Êó•ÂøóÔºö‰ºòÂÖà‰ΩøÁî®ÊúçÂä°Âô®Êó•ÂøóÔºàÊõ¥ÂÆåÊï¥ÔºâÔºåÂ¶ÇÊûúÊúçÂä°Âô®Ê≤°ÊúâÂàôÁî®Êú¨Âú∞
                                        let logs = [];
                                        if (msg.logs && msg.logs.length > 0) {
                                            logs = msg.logs.map(l => l.content || l);
                                        } else if (localData.logs && localData.logs.length > 0) {
                                            logs = localData.logs;
                                        }

                                        return {
                                            id: msg.id,
                                            role: msg.role,
                                            content: msg.content,
                                            timestamp: msg.created_at,
                                            logs: logs,
                                            screenshots: msg.screenshots || [],
                                            status: status,
                                            // ‰ºòÂÖà‰ΩøÁî®ÊúçÂä°Âô®ÁöÑ todoListÔºåÂÖ∂Ê¨°ÊòØÊú¨Âú∞Êï∞ÊçÆ
                                            todoList: todoList,
                                            currentTodoIndex: localData.currentTodoIndex
                                        };
                                    });

                                    // Êõ¥Êñ∞‰ºöËØù‰∏≠ÁöÑÊ∂àÊÅØÊï∞ÊçÆ
                                    mostRecent.messages = chatMessages.value;
                                    saveSessions();
                                }
                            } catch (error) {
                                // Â¶ÇÊûú‰ºöËØù‰∏çÂ≠òÂú®Ôºà404ÔºâÔºå‰ªéÂàóË°®‰∏≠ÁßªÈô§
                                if (error.message && error.message.includes('Session not found')) {
                                    console.warn(`Session ${mostRecent.id} not found, removing from list`);
                                    const index = chatSessions.value.findIndex(s => s.id === mostRecent.id);
                                    if (index !== -1) {
                                        chatSessions.value.splice(index, 1);
                                        saveSessions();

                                        // Â¶ÇÊûúÊúâÂÖ∂‰ªñ‰ºöËØùÔºåÂàáÊç¢Âà∞‰∏ã‰∏Ä‰∏™
                                        if (chatSessions.value.length > 0) {
                                            await switchSession(chatSessions.value[0].id);
                                            return;
                                        } else {
                                            createNewSession();
                                            return;
                                        }
                                    }
                                } else {
                                    console.error('Failed to load session detail from server:', error);
                                    // ÁªßÁª≠‰ΩøÁî®Êú¨Âú∞Êï∞ÊçÆ
                                }
                            }

                            // ‰øÆÂ§çÂà∑Êñ∞Âêé running Áä∂ÊÄÅÁöÑÊ∂àÊÅØÔºöÂÖàÊ£ÄÊü•ÊúçÂä°Âô®‰ªªÂä°Áä∂ÊÄÅ
                            // Â¶ÇÊûú‰ªªÂä°Á°ÆÂÆûËøòÂú®ËøêË°åÔºå‰øùÊåÅ running Áä∂ÊÄÅÔºõÂê¶ÂàôÊîπ‰∏∫Â∑≤ÂÆåÊàêÁä∂ÊÄÅ
                            try {
                                const taskStatus = await apiCall('/api/tasks/status');
                                const isServerTaskRunning = taskStatus && taskStatus.running;

                                chatMessages.value.forEach(msg => {
                                    if (msg.role === 'assistant' && msg.status === 'running') {
                                        if (isServerTaskRunning) {
                                            // ÊúçÂä°Âô®‰ªªÂä°ËøòÂú®ËøêË°åÔºå‰øùÊåÅ running Áä∂ÊÄÅ
                                            // ÊÅ¢Â§ç chatRunning Áä∂ÊÄÅ‰ª•‰æøÁªßÁª≠Êé•Êî∂Êó•ÂøóÊõ¥Êñ∞
                                            chatRunning.value = true;
                                            console.log('[Âà∑Êñ∞ÊÅ¢Â§ç] Ê£ÄÊµãÂà∞‰ªªÂä°‰ªçÂú®ËøêË°åÔºå‰øùÊåÅ running Áä∂ÊÄÅ');
                                        } else {
                                            // ÊúçÂä°Âô®‰ªªÂä°Â∑≤ÁªìÊùüÔºåÂ∞ÜÁä∂ÊÄÅÊîπ‰∏∫Â∑≤ÂÆåÊàê
                                            msg.status = 'success';
                                            msg.content = msg.content || '‰ªªÂä°ÊâßË°åÂÆåÊàêÔºÅ';
                                        }
                                    }

                                    // ‰øÆÂ§ç todoList Â≠ê‰ªªÂä°ÁöÑËøáÊúü running/pending Áä∂ÊÄÅ
                                    if (msg.todoList && msg.todoList.length > 0 && !isServerTaskRunning) {
                                        msg.todoList.forEach(todo => {
                                            if (todo.status === 'running' || todo.status === 'pending') {
                                                todo.status = 'failed';
                                                console.log('[Âà∑Êñ∞ÊÅ¢Â§ç] Â∞ÜËøáÊúüÁöÑÂ≠ê‰ªªÂä°Áä∂ÊÄÅÊîπ‰∏∫ failed:', todo.content);
                                            }
                                        });
                                    }
                                });
                            } catch (statusError) {
                                console.error('Failed to check task status:', statusError);
                                // Ê£ÄÊü•Â§±Ë¥•Êó∂Ôºå‰øùÂÆàÂ§ÑÁêÜÔºöÂÅáËÆæ‰ªªÂä°Â∑≤ÂÆåÊàê
                                chatMessages.value.forEach(msg => {
                                    if (msg.role === 'assistant' && msg.status === 'running') {
                                        msg.status = 'success';
                                        msg.content = msg.content || '‰ªªÂä°ÊâßË°åÂÆåÊàêÔºÅ';
                                    }
                                    // ÂêåÊ†∑‰øÆÂ§ç todoList Â≠ê‰ªªÂä°Áä∂ÊÄÅ
                                    if (msg.todoList && msg.todoList.length > 0) {
                                        msg.todoList.forEach(todo => {
                                            if (todo.status === 'running' || todo.status === 'pending') {
                                                todo.status = 'failed';
                                            }
                                        });
                                    }
                                });
                            }
                            // ‰øùÂ≠ò‰øÆÂ§çÂêéÁöÑÁä∂ÊÄÅ
                            saveCurrentSession();
                            // È°µÈù¢Âä†ËΩΩÂêéËá™Âä®ÊªöÂä®Âà∞ÊúÄÊñ∞Ê∂àÊÅØ
                            Vue.nextTick(() => {
                                scrollChatToBottom();
                            });
                        } else {
                            createNewSession();
                        }
                    }

                    // Chat functions
                    function scrollChatToBottom() {
                        setTimeout(() => {
                            if (chatMessagesRef.value) {
                                chatMessagesRef.value.scrollTop = chatMessagesRef.value.scrollHeight;
                            }
                        }, 50);
                    }

                    function onChatDeviceChange() {
                        // Auto-select device for preview too
                        if (chatDeviceId.value && !previewDeviceId.value) {
                            previewDeviceId.value = chatDeviceId.value;
                        }
                    }

                    function adjustChatInputHeight(e) {
                        const el = e.target;
                        el.style.height = 'auto';
                        el.style.height = Math.min(el.scrollHeight, 100) + 'px';
                    }

                    async function sendChatMessage() {
                        const content = chatInput.value.trim();
                        if (!content || !chatDeviceId.value || chatRunning.value) return;

                        // Á°Æ‰øùÊúâ‰ºöËØùÂ≠òÂú®ÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÂàõÂª∫
                        if (!currentSessionId.value) {
                            await createNewSession();
                        }

                        // ÂêåÊ≠•‰ºöËØùÂà∞ÊúçÂä°Âô®ÔºàÂ¶ÇÊûú‰ºöËØùIDÊòØÊú¨Âú∞ÁîüÊàêÁöÑÔºåÈúÄË¶ÅÂú®ÊúçÂä°Âô®ÂàõÂª∫Ôºâ
                        let serverSessionId = currentSessionId.value;
                        let serverMessageId = null;

                        // Â∞ùËØïÂ∞ÜÊ∂àÊÅØ‰øùÂ≠òÂà∞ÊúçÂä°Âô®
                        try {
                            // Ê£ÄÊü•‰ºöËØùÊòØÂê¶Â≠òÂú®‰∫éÊúçÂä°Âô®
                            const sessionCheck = await apiCall(`/api/chat/sessions/${currentSessionId.value}`).catch(() => null);

                            if (!sessionCheck) {
                                // ‰ºöËØù‰∏çÂ≠òÂú®ÔºåÂú®ÊúçÂä°Âô®ÂàõÂª∫
                                const newSession = await apiCall('/api/chat/sessions', {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        device_id: chatDeviceId.value,
                                        title: content.substring(0, 30) + (content.length > 30 ? '...' : '')
                                    })
                                });
                                serverSessionId = newSession.id;

                                // Êõ¥Êñ∞Êú¨Âú∞‰ºöËØùID
                                const oldSessionId = currentSessionId.value;
                                currentSessionId.value = serverSessionId;
                                const localSession = chatSessions.value.find(s => s.id === oldSessionId);
                                if (localSession) {
                                    localSession.id = serverSessionId;
                                }
                                saveSessions();
                            }

                            // Âú®ÊúçÂä°Âô®Ê∑ªÂä†Áî®Êà∑Ê∂àÊÅØ
                            const userMsgResult = await apiCall(`/api/chat/sessions/${serverSessionId}/messages`, {
                                method: 'POST',
                                body: JSON.stringify({
                                    role: 'user',
                                    content: content
                                })
                            });

                            // Âú®ÊúçÂä°Âô®Ê∑ªÂä†Âä©ÊâãÊ∂àÊÅØÂç†‰ΩçÁ¨¶
                            const assistantMsgResult = await apiCall(`/api/chat/sessions/${serverSessionId}/messages`, {
                                method: 'POST',
                                body: JSON.stringify({
                                    role: 'assistant',
                                    content: 'ÊâßË°å‰∏≠...'
                                })
                            });
                            serverMessageId = assistantMsgResult.id;
                        } catch (error) {
                            console.error('Failed to sync messages to server:', error);
                            // ÁªßÁª≠ÊâßË°åÔºå‰ΩÜÊó†Ê≥ï‰øùÂ≠òÊà™ÂõæÂà∞Êï∞ÊçÆÂ∫ì
                        }

                        // Add user message to local state
                        chatMessages.value.push({
                            role: 'user',
                            content: content,
                            timestamp: new Date().toISOString()
                        });

                        // Clear input
                        chatInput.value = '';

                        // Add assistant message (running state)
                        const assistantMsg = {
                            id: serverMessageId,  // ÊúçÂä°Âô®Ê∂àÊÅØIDÔºåÁî®‰∫éÁªëÂÆöÊà™Âõæ
                            role: 'assistant',
                            content: '',
                            status: 'running',
                            logs: [],
                            screenshots: [],  // ‰ΩøÁî® screenshots Êï∞ÁªÑËÄå‰∏çÊòØ screenshot
                            timestamp: new Date().toISOString(),
                            todoList: null,  // Â§çÊùÇ‰ªªÂä°Ê®°Âºè‰∏ãÁöÑtodoList
                            tokens: 0,
                            taskId: null  // ÂÖ≥ËÅîÁöÑ‰ªªÂä°IDÔºåÁî®‰∫éÂåπÈÖçWebSocket‰∫ã‰ª∂
                        };
                        chatMessages.value.push(assistantMsg);

                        scrollChatToBottom();
                        chatRunning.value = true;

                        try {
                            // Â§çÊùÇ‰ªªÂä°Ê®°ÂºèÔºöÂÖàÊãÜËß£‰ªªÂä°
                            if (complexTaskMode.value) {
                                assistantMsg.content = 'üß© Ê≠£Âú®ÂàÜÊûê‰ªªÂä°...';
                                saveCurrentSession();

                                // Ë∞ÉÁî®‰ªªÂä°ÊãÜËß£API
                                const decomposeResult = await apiCall('/api/tasks/decompose', {
                                    method: 'POST',
                                    body: JSON.stringify({ task_content: content }),
                                });

                                if (decomposeResult.success && decomposeResult.todoList) {
                                    // ÂàùÂßãÂåñtodoListÔºåÊâÄÊúâ‰ªªÂä°Áä∂ÊÄÅ‰∏∫pendingÔºåÊØè‰∏™Â≠ê‰ªªÂä°ÊúâÁã¨Á´ãÁöÑlogsÊï∞ÁªÑ
                                    assistantMsg.todoList = decomposeResult.todoList.map(item => ({
                                        content: item.content,
                                        status: 'pending',
                                        logs: []  // ÊØè‰∏™Â≠ê‰ªªÂä°Áã¨Á´ãÁöÑÊó•ÂøóÊï∞ÁªÑ
                                    }));
                                    assistantMsg.tokens = decomposeResult.tokens || 0;
                                    assistantMsg.content = 'üìã ‰ªªÂä°Â∑≤ÊãÜËß£ÔºåÂáÜÂ§áÊâßË°å...';
                                    assistantMsg.currentTodoIndex = -1;  // Áî®‰∫éË∑üË∏™ÂΩìÂâçÊâßË°åÁöÑÂ≠ê‰ªªÂä°Á¥¢Âºï
                                    saveCurrentSession();
                                    scrollChatToBottom();

                                    // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖ∂‰ªñ‰ªªÂä°Âú®ËøêË°å
                                    const status = await apiCall('/api/tasks/status');
                                    if (status.running && status.task) {
                                        // Êúâ‰ªªÂä°Âú®ËøêË°åÔºåChat‰ªªÂä°‰ºòÂÖàÁ∫ßÊúÄÈ´òÔºåÁõ¥Êé•ÊâìÊñ≠
                                        const currentTaskType = status.task.task_type || 'manual';
                                        const currentTaskContent = status.task.task_content || 'Êú™Áü•‰ªªÂä°';
                                        const typeNames = { 'manual': 'ÊâãÂä®‰ªªÂä°', 'scheduled': 'ÂÆöÊó∂‰ªªÂä°', 'chat': 'Chat‰ªªÂä°' };
                                        const typeName = typeNames[currentTaskType] || 'Êú™Áü•‰ªªÂä°';

                                        // Chat‰ªªÂä°ÂèØ‰ª•ÊâìÊñ≠ÂÖ∂‰ªñÁ±ªÂûãÁöÑ‰ªªÂä°
                                        if (currentTaskType !== 'chat') {
                                            assistantMsg.content = `‚ö†Ô∏è Ê≠£Âú®ÊâìÊñ≠${typeName}: ${currentTaskContent.substring(0, 30)}...`;
                                            saveCurrentSession();
                                            // Âº∫Âà∂ÂÅúÊ≠¢ÂΩìÂâç‰ªªÂä°
                                            await apiCall('/api/tasks/stop', { method: 'POST' });
                                            // Á≠âÂæÖ‰ªªÂä°ÂÅúÊ≠¢
                                            await new Promise(resolve => setTimeout(resolve, 1500));
                                        } else {
                                            // Âè¶‰∏Ä‰∏™Chat‰ªªÂä°Ê≠£Âú®ËøêË°åÔºåÈúÄË¶ÅÁ≠âÂæÖ
                                            let waitAttempts = 0;
                                            const maxWaitAttempts = 60;
                                            while (waitAttempts < maxWaitAttempts) {
                                                const checkStatus = await apiCall('/api/tasks/status');
                                                if (!checkStatus.running) break;
                                                assistantMsg.content = `‚è≥ Á≠âÂæÖÂÖ∂‰ªñChat‰ªªÂä°ÂÆåÊàê... (${waitAttempts + 1}s)`;
                                                saveCurrentSession();
                                                await new Promise(resolve => setTimeout(resolve, 1000));
                                                waitAttempts++;
                                                if (!chatRunning.value) throw new Error('Áî®Êà∑ÂèñÊ∂à‰∫Ü‰ªªÂä°');
                                            }
                                            if (waitAttempts >= maxWaitAttempts) {
                                                throw new Error('Á≠âÂæÖË∂ÖÊó∂ÔºåÂÖ∂‰ªñ‰ªªÂä°‰ªçÂú®ËøêË°å');
                                            }
                                        }
                                    }

                                    assistantMsg.content = 'üìã ÂºÄÂßãÈÄê‰∏™ÊâßË°åÂ≠ê‰ªªÂä°...';
                                    saveCurrentSession();

                                    // ÈÄê‰∏™ÊâßË°åÂ≠ê‰ªªÂä°
                                    let allSuccess = true;
                                    const totalTasks = assistantMsg.todoList.length;

                                    for (let i = 0; i < totalTasks; i++) {
                                        // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶ÂÅúÊ≠¢‰∫Ü‰ªªÂä°
                                        if (!chatRunning.value) {
                                            console.log(`[Â≠ê‰ªªÂä° ${i + 1}/${totalTasks}] Áî®Êà∑ÂÅúÊ≠¢‰∫Ü‰ªªÂä°`);
                                            // Â∞ÜÂΩìÂâçÂíåÂâ©‰Ωô‰ªªÂä°Ê†áËÆ∞‰∏∫Â§±Ë¥•
                                            for (let j = i; j < totalTasks; j++) {
                                                if (assistantMsg.todoList[j].status === 'pending' || assistantMsg.todoList[j].status === 'running') {
                                                    assistantMsg.todoList[j].status = 'failed';
                                                }
                                            }
                                            allSuccess = false;
                                            break;
                                        }

                                        const todoItem = assistantMsg.todoList[i];
                                        const maxRetries = 2;  // ÊúÄÂ§öÈáçËØï2Ê¨°
                                        let retryCount = 0;
                                        let subtaskSuccess = false;

                                        // ÈáçËØïÂæ™ÁéØ
                                        while (retryCount <= maxRetries && !subtaskSuccess) {
                                            if (retryCount > 0) {
                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}/${totalTasks}] ÈáçËØïÁ¨¨ ${retryCount} Ê¨°...`);
                                                assistantMsg.content = `üîÑ ÈáçËØïÂ≠ê‰ªªÂä° (${retryCount}/${maxRetries}): ${todoItem.content} (${i + 1}/${totalTasks})`;
                                                saveCurrentSession();
                                                // ÈáçËØïÂâçÁ≠âÂæÖ‰∏Ä‰∏ã
                                                await new Promise(resolve => setTimeout(resolve, 2000));
                                            }

                                            todoItem.status = 'running';
                                            assistantMsg.currentTodoIndex = i;  // ËÆæÁΩÆÂΩìÂâçÊâßË°åÁöÑÂ≠ê‰ªªÂä°Á¥¢Âºï
                                            if (retryCount === 0) {
                                                assistantMsg.content = `üîÑ Ê≠£Âú®ÊâßË°å: ${todoItem.content} (${i + 1}/${totalTasks})`;
                                            }
                                            saveCurrentSession();
                                            scrollChatToBottom();

                                            try {
                                                // ÊâßË°åÂçï‰∏™Â≠ê‰ªªÂä°
                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}/${totalTasks}] ÂºÄÂßãÊâßË°å (Â∞ùËØï ${retryCount + 1}):`, todoItem.content);

                                                // ÂÖàÁ≠âÂæÖ‰∏Ä‰∏ãÁ°Æ‰øùÂâç‰∏Ä‰∏™‰ªªÂä°ÂÆåÂÖ®Ê∏ÖÁêÜ
                                                if (i > 0 || retryCount > 0) {
                                                    console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Á≠âÂæÖ‰ªªÂä°Ê∏ÖÁêÜ...`);
                                                    await new Promise(resolve => setTimeout(resolve, 1500));
                                                }

                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Ë∞ÉÁî® /api/tasks/run...`);
                                                const runResult = await apiCall('/api/tasks/run', {
                                                    method: 'POST',
                                                    body: JSON.stringify({
                                                        task_content: todoItem.content,
                                                        device_ids: [chatDeviceId.value],
                                                        send_email: false,  // Â≠ê‰ªªÂä°‰∏çÂèëÈÇÆ‰ª∂
                                                        no_auto_lock: true,  // ÊâÄÊúâÂ≠ê‰ªªÂä°ÈÉΩ‰∏çËá™Âä®ÈîÅÂ±èÔºåÊúÄÂêéÁªü‰∏ÄÂ§ÑÁêÜ
                                                        task_type: "chat",  // Ê†áËÆ∞‰∏∫ chat ‰ªªÂä°ÔºåÈÅøÂÖçÊó•ÂøóÂá∫Áé∞Âú® Run Task È°µÈù¢
                                                        session_id: serverSessionId,  // ‰º†ÈÄí‰ºöËØùID
                                                        message_id: serverMessageId,  // ‰º†ÈÄíÊ∂àÊÅØID
                                                    }),
                                                });
                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}] run Ë∞ÉÁî®ÊàêÂäü:`, runResult);

                                                // Á≠âÂæÖ‰ªªÂä°ÂÆåÊàêÔºàÈÄöËøáËΩÆËØ¢Áä∂ÊÄÅÔºâ
                                                let taskCompleted = false;
                                                let attempts = 0;
                                                const maxAttempts = 300;  // ÊúÄÂ§öÁ≠â5ÂàÜÈíü (300 * 1000ms)

                                                while (!taskCompleted && attempts < maxAttempts) {
                                                    // ÊØèÊ¨°ËΩÆËØ¢ÂâçÊ£ÄÊü•Áî®Êà∑ÊòØÂê¶ÂÅúÊ≠¢‰∫Ü‰ªªÂä°
                                                    if (!chatRunning.value) {
                                                        console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ËΩÆËØ¢‰∏≠Ê£ÄÊµãÂà∞Áî®Êà∑ÂÅúÊ≠¢`);
                                                        todoItem.status = 'failed';
                                                        break;
                                                    }

                                                    await new Promise(resolve => setTimeout(resolve, 1000));
                                                    const status = await apiCall('/api/tasks/status');
                                                    console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ËΩÆËØ¢Áä∂ÊÄÅ #${attempts + 1}:`, status);
                                                    if (!status.running) {
                                                        taskCompleted = true;
                                                        // Ê£ÄÊü•‰ªªÂä°ÊòØÂê¶ÊàêÂäü
                                                        if (status.task) {
                                                            if (status.task.status === 'completed') {
                                                                todoItem.status = 'completed';
                                                                subtaskSuccess = true;
                                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ÂÆåÊàê (status=completed)`);
                                                            } else if (status.task.status === 'stopped') {
                                                                todoItem.status = 'failed';
                                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Â∑≤ÂÅúÊ≠¢`);
                                                            } else {
                                                                todoItem.status = 'failed';
                                                                console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Â§±Ë¥• (status=${status.task.status})`);
                                                            }
                                                        } else {
                                                            // task ‰∏∫ null ‰∏î running ‰∏∫ falseÔºåËØ¥Êòé‰ªªÂä°Â∑≤Ê≠£Â∏∏ÂÆåÊàêÂπ∂Ë¢´Ê∏ÖÁêÜ
                                                            todoItem.status = 'completed';
                                                            subtaskSuccess = true;
                                                            console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ÂÆåÊàê (task cleared)`);
                                                        }
                                                    }
                                                    attempts++;
                                                }

                                                // Ê£ÄÊü•ÊòØÂê¶Ë¢´ÂÅúÊ≠¢ÊàñË∂ÖÊó∂
                                                if (!chatRunning.value && todoItem.status === 'running') {
                                                    todoItem.status = 'failed';
                                                    console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ÊâßË°åÊúüÈó¥Ë¢´ÂÅúÊ≠¢`);
                                                }

                                                if (!taskCompleted && todoItem.status === 'running') {
                                                    todoItem.status = 'failed';
                                                    console.log(`[Â≠ê‰ªªÂä° ${i + 1}] Ë∂ÖÊó∂Â§±Ë¥•`);
                                                }
                                            } catch (error) {
                                                todoItem.status = 'failed';
                                                console.error(`[Â≠ê‰ªªÂä° ${i + 1}] ÂºÇÂ∏∏Â§±Ë¥• (Â∞ùËØï ${retryCount + 1}):`, error);
                                                console.error(`[Â≠ê‰ªªÂä° ${i + 1}] ÈîôËØØËØ¶ÊÉÖ:`, error.message);
                                            }

                                            // Â¶ÇÊûúÂ≠ê‰ªªÂä°Â§±Ë¥•ÔºåÂ¢ûÂä†ÈáçËØïËÆ°Êï∞
                                            if (!subtaskSuccess && todoItem.status === 'failed') {
                                                retryCount++;
                                                if (retryCount <= maxRetries) {
                                                    todoItem.logs = todoItem.logs || [];
                                                    todoItem.logs.push(`‚ö†Ô∏è Â≠ê‰ªªÂä°Â§±Ë¥•ÔºåÊ≠£Âú®ÈáçËØï (${retryCount}/${maxRetries})...`);
                                                }
                                            }
                                        }

                                        // ÈáçËØïÂêé‰ªçÁÑ∂Â§±Ë¥•Ôºå‰∏≠Ê≠¢Êï¥‰∏™‰ªªÂä°
                                        if (!subtaskSuccess) {
                                            allSuccess = false;
                                            todoItem.logs = todoItem.logs || [];
                                            todoItem.logs.push(`‚ùå Â≠ê‰ªªÂä°Âú®ÈáçËØï ${maxRetries} Ê¨°Âêé‰ªçÁÑ∂Â§±Ë¥•Ôºå‰∏≠Ê≠¢‰ªªÂä°ÊâßË°å`);
                                            console.log(`[Â≠ê‰ªªÂä° ${i + 1}] ÈáçËØï ${maxRetries} Ê¨°Âêé‰ªçÁÑ∂Â§±Ë¥•Ôºå‰∏≠Ê≠¢Êï¥‰∏™‰ªªÂä°`);

                                            // Â∞ÜÂâ©‰Ωô‰ªªÂä°Ê†áËÆ∞‰∏∫Êú™ÊâßË°åÔºàpendingÔºâ
                                            for (let j = i + 1; j < totalTasks; j++) {
                                                if (assistantMsg.todoList[j].status === 'pending') {
                                                    // ‰øùÊåÅ pending Áä∂ÊÄÅÔºåË°®Á§∫Êú™ÊâßË°å
                                                }
                                            }
                                            break;  // ‰∏≠Ê≠¢Êï¥‰∏™‰ªªÂä°Âæ™ÁéØ
                                        }

                                        saveCurrentSession();
                                        scrollChatToBottom();
                                    }

                                    // Ê∏ÖÈô§ÂΩìÂâçÊâßË°åÁ¥¢Âºï
                                    assistantMsg.currentTodoIndex = undefined;

                                    // Âú®ÈîÅÂ±èÂâçÊà™ÂèñÊúÄÁªàÊà™ÂõæÂπ∂‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì
                                    try {
                                        console.log('[Â§çÊùÇ‰ªªÂä°] Êà™ÂèñÊúÄÁªàÊà™Âõæ...');
                                        const screenshotResponse = await fetch(`/api/devices/${chatDeviceId.value}/screenshot/base64`);
                                        if (screenshotResponse.ok) {
                                            const screenshotData = await screenshotResponse.json();
                                            // API ËøîÂõûÁöÑÊòØ {"image": "base64..."} Ê†ºÂºè
                                            if (screenshotData.image && currentSessionId.value && assistantMsg.id) {
                                                // ‰øùÂ≠òÊà™ÂõæÂà∞Êï∞ÊçÆÂ∫ìÔºå‰∏çÂÜç‰øùÂ≠ò base64 Âà∞Ê∂àÊÅØÂØπË±°
                                                try {
                                                    const saveResult = await apiCall(
                                                        `/api/chat/sessions/${currentSessionId.value}/messages/${assistantMsg.id}/screenshots`,
                                                        {
                                                            method: 'POST',
                                                            body: JSON.stringify({
                                                                image: screenshotData.image,
                                                                description: 'Â§çÊùÇ‰ªªÂä°ÂÆåÊàêÊà™Âõæ'
                                                            })
                                                        }
                                                    );
                                                    if (saveResult && saveResult.id) {
                                                        // Êõ¥Êñ∞Ê∂àÊÅØÁöÑ screenshots Êï∞ÁªÑ
                                                        if (!assistantMsg.screenshots) {
                                                            assistantMsg.screenshots = [];
                                                        }
                                                        assistantMsg.screenshots.push({
                                                            id: saveResult.id,
                                                            image_url: `/api/chat/screenshots/${saveResult.id}`
                                                        });
                                                        console.log('[Â§çÊùÇ‰ªªÂä°] Êà™ÂõæÂ∑≤‰øùÂ≠òÂà∞Êï∞ÊçÆÂ∫ì:', saveResult.id);
                                                    }
                                                } catch (saveError) {
                                                    console.error('[Â§çÊùÇ‰ªªÂä°] ‰øùÂ≠òÊà™ÂõæÂà∞Êï∞ÊçÆÂ∫ìÂ§±Ë¥•:', saveError);
                                                }
                                            }
                                        }
                                    } catch (screenshotError) {
                                        console.error('[Â§çÊùÇ‰ªªÂä°] Êà™ÂõæÂ§±Ë¥•:', screenshotError);
                                    }

                                    // Êà™ÂõæÂÆåÊàêÂêéÈîÅÂ±è
                                    try {
                                        console.log('[Â§çÊùÇ‰ªªÂä°] ÈîÅÂÆöËÆæÂ§á...');
                                        await apiCall(`/api/devices/${chatDeviceId.value}/lock`, { method: 'POST' });
                                        console.log('[Â§çÊùÇ‰ªªÂä°] ËÆæÂ§áÂ∑≤ÈîÅÂÆö');
                                    } catch (lockError) {
                                        console.error('[Â§çÊùÇ‰ªªÂä°] ÈîÅÂ±èÂ§±Ë¥•:', lockError);
                                    }

                                    // ÊâÄÊúâÂ≠ê‰ªªÂä°ÊâßË°åÂÆåÊàê
                                    assistantMsg.status = allSuccess ? 'success' : 'error';
                                    assistantMsg.content = allSuccess
                                        ? `‚úÖ Â§çÊùÇ‰ªªÂä°ÊâßË°åÂÆåÊàêÔºÅÂÖ± ${totalTasks} ‰∏™Â≠ê‰ªªÂä°ÂÖ®ÈÉ®ÊàêÂäü„ÄÇ`
                                        : `‚ö†Ô∏è Â§çÊùÇ‰ªªÂä°ÊâßË°åÂÆåÊàêÔºåÈÉ®ÂàÜÂ≠ê‰ªªÂä°Â§±Ë¥•„ÄÇ`;
                                    assistantMsg.timestamp = new Date().toISOString();

                                    // ÂèëÈÄÅÊ±áÊÄªÈÇÆ‰ª∂ÔºàÂ¶ÇÊûúÂºÄÂêØÔºâ
                                    if (chatAutoEmail.value) {
                                        try {
                                            console.log('[Â§çÊùÇ‰ªªÂä°] ÂèëÈÄÅÊ±áÊÄªÈÇÆ‰ª∂...');
                                            // Ëé∑ÂèñÊúÄÊñ∞ÁöÑÊà™Âõæ IDÔºàÂ¶ÇÊûúÊúâÔºâ
                                            const latestScreenshotId = assistantMsg.screenshots && assistantMsg.screenshots.length > 0
                                                ? assistantMsg.screenshots[assistantMsg.screenshots.length - 1].id
                                                : null;
                                            const emailResult = await apiCall('/api/tasks/send-complex-email', {
                                                method: 'POST',
                                                body: JSON.stringify({
                                                    task_name: content,
                                                    subtasks: assistantMsg.todoList.map(t => ({
                                                        content: t.content,
                                                        status: t.status,
                                                        logs: t.logs || []
                                                    })),
                                                    total_tokens: assistantMsg.tokens || 0,
                                                    screenshot_id: latestScreenshotId  // ‰ΩøÁî® screenshot_id ËÄå‰∏çÊòØ base64
                                                }),
                                            });
                                            if (emailResult.success) {
                                                console.log('[Â§çÊùÇ‰ªªÂä°] ÈÇÆ‰ª∂ÂèëÈÄÅÊàêÂäü');
                                            } else {
                                                console.log('[Â§çÊùÇ‰ªªÂä°] ÈÇÆ‰ª∂ÂèëÈÄÅÂ§±Ë¥•:', emailResult.message);
                                            }
                                        } catch (emailError) {
                                            console.error('[Â§çÊùÇ‰ªªÂä°] ÈÇÆ‰ª∂ÂèëÈÄÅÂ§±Ë¥•:', emailError);
                                        }
                                    }
                                } else {
                                    throw new Error('‰ªªÂä°ÊãÜËß£Â§±Ë¥•');
                                }
                            } else {
                                // ÊôÆÈÄöÊ®°ÂºèÔºöÁõ¥Êé•ÊâßË°å‰ªªÂä°
                                const runResult = await apiCall('/api/tasks/run', {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        task_content: content,
                                        device_ids: [chatDeviceId.value],
                                        send_email: chatAutoEmail.value,
                                        task_type: "chat",  // Ê†áËÆ∞‰∏∫ chat ‰ªªÂä°ÔºåÈÅøÂÖçÊó•ÂøóÂá∫Áé∞Âú® Run Task È°µÈù¢
                                        session_id: serverSessionId,  // ‰º†ÈÄí‰ºöËØùID
                                        message_id: serverMessageId,  // ‰º†ÈÄíÊ∂àÊÅØID
                                    }),
                                });
                                // ‰øùÂ≠ò‰ªªÂä°IDÁî®‰∫éÂåπÈÖçWebSocket‰∫ã‰ª∂
                                if (runResult && runResult.task_id) {
                                    assistantMsg.taskId = runResult.task_id;
                                }
                                // Task started, WebSocket will handle updates
                            }
                        } catch (error) {
                            // Update last message to error
                            const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                            if (lastMsg.role === 'assistant') {
                                lastMsg.status = 'error';
                                let errorMsg = error.message || 'Êú™Áü•ÈîôËØØ';

                                // Êèê‰æõÊõ¥ÂèãÂ•ΩÁöÑÈîôËØØÊèêÁ§∫
                                if (errorMsg.includes('Token error') || errorMsg.includes('limited')) {
                                    errorMsg = '‚ùå ' + errorMsg + '\n\nüí° ÊèêÁ§∫ÔºöÊ®°ÂûãÊúçÂä°Ë¢´ÈôêÊµÅÔºåËØ∑Á®çÂêéÂÜçËØïÔºåÊàñÊ£ÄÊü•Ê®°ÂûãÈÖçÁΩÆ‰∏≠ÁöÑAPIÈ¢ùÂ∫¶„ÄÇ';
                                } else if (errorMsg.includes('Failed to parse todoList')) {
                                    errorMsg = '‚ùå ‰ªªÂä°ÊãÜËß£Â§±Ë¥•ÔºöÊ®°ÂûãËøîÂõûÁöÑÊ†ºÂºè‰∏çÊ≠£Á°Æ„ÄÇ\n\nüí° ÊèêÁ§∫ÔºöËØ∑Â∞ùËØïÂ∞Ü‰ªªÂä°ÊèèËø∞ÂæóÊõ¥Ê∏ÖÊô∞ÔºåÊàñÂàáÊç¢Âà∞ÊôÆÈÄö‰ªªÂä°Ê®°ÂºèÊâßË°å„ÄÇ';
                                }

                                lastMsg.content = 'ÂêØÂä®‰ªªÂä°Â§±Ë¥•: ' + errorMsg;
                            }
                            chatRunning.value = false;
                        }

                        // Â§çÊùÇ‰ªªÂä°Ê®°Âºè‰∏ãÔºåÊâßË°åÂÆåÊàêÂêéÈáçÁΩÆÁä∂ÊÄÅ
                        if (complexTaskMode.value) {
                            chatRunning.value = false;
                        }

                        // Save session after sending message
                        saveCurrentSession();
                    }

                    // Stop chat task
                    async function stopChatTask() {
                        try {
                            await apiCall('/api/tasks/stop', { method: 'POST' });
                            showToast('Ê≠£Âú®ÂÅúÊ≠¢‰ªªÂä°...');

                            // Update chat message status
                            if (chatMessages.value.length > 0) {
                                const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                                if (lastMsg.role === 'assistant' && lastMsg.status === 'running') {
                                    lastMsg.status = 'error';
                                    lastMsg.content = '‰ªªÂä°Â∑≤ÂÅúÊ≠¢';
                                }
                            }
                            chatRunning.value = false;
                            saveCurrentSession();
                        } catch (error) {
                            showToast('ÂÅúÊ≠¢‰ªªÂä°Â§±Ë¥•', 'error');
                        }
                    }

                    // Open task detail modal
                    async function openTaskDetail(msg) {
                        // Âè™‰ªéÊï∞ÊçÆÂ∫ìÂä†ËΩΩÊà™ÂõæÔºå‰∏çÂÜç‰ΩøÁî® base64
                        let screenshots = msg.screenshots || [];

                        // Â¶ÇÊûúÊ∂àÊÅØÊ≤°Êúâ screenshots Êï∞ÊçÆÔºå‰∏îÂ≠òÂú® session_id Âíå message_idÔºåÂàô‰ªéÊúçÂä°Âô®Ëé∑Âèñ
                        if (screenshots.length === 0 && currentSessionId.value && msg.id) {
                            try {
                                const screenshotData = await apiCall(
                                    `/api/chat/sessions/${currentSessionId.value}/screenshots?message_id=${msg.id}`
                                );
                                if (screenshotData && screenshotData.length > 0) {
                                    screenshots = screenshotData;
                                    // Êõ¥Êñ∞Ê∂àÊÅØÂØπË±°‰∏≠ÁöÑ screenshotsÔºå‰ª•‰æø‰∏ãÊ¨°ÊâìÂºÄÊó∂‰∏çÈúÄË¶ÅÂÜçÊ¨°Ëé∑Âèñ
                                    msg.screenshots = screenshots;
                                }
                            } catch (error) {
                                console.error('Failed to load screenshots:', error);
                                // ÁªßÁª≠ÊòæÁ§∫ÔºåÂç≥‰ΩøËé∑ÂèñÂ§±Ë¥•
                            }
                        }

                        taskDetailData.value = {
                            status: msg.status,
                            logs: msg.logs || [],
                            screenshots: screenshots  // Âè™‰ΩøÁî® screenshotsÔºå‰∏çÂÜç‰ΩøÁî® base64 screenshot
                        };
                        showTaskDetail.value = true;
                    }

                    // Device functions (original)
                    async function refreshDevices() {
                        loading.value = true;
                        try {
                            const data = await apiCall('/api/devices/refresh', { method: 'POST' });
                            devices.value = data;
                            showToast(`Found ${data.length} device(s)`);
                        } catch (e) {
                            console.error('Failed to refresh devices:', e);
                        } finally {
                            loading.value = false;
                        }
                    }

                    function toggleDeviceSelection(deviceId) {
                        const index = selectedDevices.value.indexOf(deviceId);
                        if (index === -1) {
                            selectedDevices.value.push(deviceId);
                        } else {
                            selectedDevices.value.splice(index, 1);
                        }
                    }

                    function selectAllDevices() {
                        if (selectedDevices.value.length === devices.value.length) {
                            selectedDevices.value = [];
                        } else {
                            selectedDevices.value = devices.value.map(d => d.id);
                        }
                    }

                    function getDeviceName(id) {
                        const device = devices.value.find(d => d.id === id);
                        return device ? (device.name || device.id.substring(0, 20)) : id.substring(0, 20);
                    }

                    async function unlockDevice(deviceId) {
                        try {
                            const pin = pinInputValues.value[deviceId] || '';
                            await apiCall(`/api/devices/${deviceId}/unlock`, {
                                method: 'POST',
                                body: JSON.stringify({ pin: pin }),
                            });
                            showToast('ËÆæÂ§áÂ∑≤Ëß£ÈîÅ');
                        } catch (error) {
                            showToast('Ëß£ÈîÅÂ§±Ë¥•', 'error');
                        }
                    }

                    // Wireless pairing functions
                    async function wirelessPair() {
                        if (!pairAddress.value) {
                            showToast('ËØ∑ËæìÂÖ•ÈÖçÂØπÂú∞ÂùÄ', 'error');
                            return;
                        }
                        if (!pairCode.value || pairCode.value.length !== 6) {
                            showToast('ËØ∑ËæìÂÖ•6‰ΩçÈÖçÂØπÁ†Å', 'error');
                            return;
                        }
                        pairingLoading.value = true;
                        deviceLogs.value = [];
                        try {
                            const data = await apiCall('/api/devices/pair', {
                                method: 'POST',
                                body: JSON.stringify({
                                    pair_address: pairAddress.value,
                                    pair_code: pairCode.value,
                                }),
                            });
                            deviceLogs.value = data.logs || [];
                            if (data.success) {
                                showToast(data.message, 'success');
                                pairCode.value = '';
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('ÈÖçÂØπÂ§±Ë¥•: ' + error.message, 'error');
                        } finally {
                            pairingLoading.value = false;
                        }
                    }

                    async function tcpConnect() {
                        if (!connectAddress.value) {
                            showToast('ËØ∑ËæìÂÖ•ËøûÊé•Âú∞ÂùÄ', 'error');
                            return;
                        }
                        connectingLoading.value = true;
                        deviceLogs.value = [];
                        try {
                            const data = await apiCall('/api/devices/connect', {
                                method: 'POST',
                                body: JSON.stringify({
                                    connect_address: connectAddress.value,
                                }),
                            });
                            deviceLogs.value = data.logs || [];
                            if (data.success) {
                                showToast(data.message, 'success');
                                await refreshDevices();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('ËøûÊé•Â§±Ë¥•: ' + error.message, 'error');
                        } finally {
                            connectingLoading.value = false;
                        }
                    }

                    async function disconnectDevice(deviceId) {
                        try {
                            const data = await apiCall(`/api/devices/disconnect/${deviceId}`, {
                                method: 'POST',
                            });
                            if (data.success) {
                                showToast('ËÆæÂ§áÂ∑≤Êñ≠ÂºÄ');
                                await refreshDevices();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('Êñ≠ÂºÄÂ§±Ë¥•', 'error');
                        }
                    }

                    // APK install functions
                    function onApkFileSelect(event) {
                        const file = event.target.files[0];
                        if (file && file.name.toLowerCase().endsWith('.apk')) {
                            apkFile.value = file;
                            apkLogs.value = [];
                        } else {
                            apkFile.value = null;
                            showToast('ËØ∑ÈÄâÊã© APK Êñá‰ª∂', 'error');
                        }
                    }

                    async function installApk() {
                        if (!apkTargetDevice.value) {
                            showToast('ËØ∑ÈÄâÊã©ÁõÆÊ†áËÆæÂ§á', 'error');
                            return;
                        }
                        if (!apkFile.value) {
                            showToast('ËØ∑ÈÄâÊã© APK Êñá‰ª∂', 'error');
                            return;
                        }

                        apkInstalling.value = true;
                        apkLogs.value = ['ÂáÜÂ§á‰∏ä‰º† APK Êñá‰ª∂...'];

                        try {
                            const formData = new FormData();
                            formData.append('file', apkFile.value);

                            apkLogs.value.push(`‰∏ä‰º†‰∏≠: ${apkFile.value.name}`);

                            const response = await fetch(`/api/devices/${apkTargetDevice.value}/install-apk`, {
                                method: 'POST',
                                body: formData,
                            });

                            const data = await response.json();
                            apkLogs.value = data.logs || [];

                            if (data.success) {
                                showToast(data.message, 'success');
                                // Clear file input
                                apkFile.value = null;
                                if (apkFileInput.value) {
                                    apkFileInput.value.value = '';
                                }
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            apkLogs.value.push(`‚ùå ÂÆâË£ÖÂ§±Ë¥•: ${error.message}`);
                            showToast('APK ÂÆâË£ÖÂ§±Ë¥•', 'error');
                        } finally {
                            apkInstalling.value = false;
                        }
                    }

                    // File manager functions
                    async function loadFiles() {
                        if (!fileDevice.value) return;
                        fileLoading.value = true;
                        try {
                            const data = await apiCall(`/api/devices/${fileDevice.value}/files?path=${encodeURIComponent(filePath.value)}`);
                            fileList.value = data.files || [];
                        } catch (error) {
                            showToast('Âä†ËΩΩÊñá‰ª∂ÂàóË°®Â§±Ë¥•: ' + error.message, 'error');
                            fileList.value = [];
                        } finally {
                            fileLoading.value = false;
                        }
                    }

                    function navigateTo(path) {
                        // Normalize path
                        path = path.replace(/\/+/g, '/');
                        if (path !== '/' && path.endsWith('/')) {
                            path = path.slice(0, -1);
                        }
                        filePath.value = path;
                        loadFiles();
                    }

                    function goUp() {
                        const parts = filePath.value.split('/').filter(p => p);
                        if (parts.length > 0) {
                            parts.pop();
                            filePath.value = '/' + parts.join('/');
                            loadFiles();
                        }
                    }

                    function formatFileSize(size) {
                        const num = parseInt(size);
                        if (isNaN(num)) return size;
                        if (num < 1024) return num + ' B';
                        if (num < 1024 * 1024) return (num / 1024).toFixed(1) + ' KB';
                        if (num < 1024 * 1024 * 1024) return (num / 1024 / 1024).toFixed(1) + ' MB';
                        return (num / 1024 / 1024 / 1024).toFixed(1) + ' GB';
                    }

                    function isImageFile(name) {
                        return /\.(jpg|jpeg|png|gif|bmp|webp)$/i.test(name);
                    }

                    function isVideoFile(name) {
                        return /\.(mp4|mkv|avi|mov|wmv|flv|webm)$/i.test(name);
                    }

                    function isAudioFile(name) {
                        return /\.(mp3|wav|flac|aac|ogg|m4a)$/i.test(name);
                    }

                    async function downloadFile(filename) {
                        const fullPath = filePath.value + '/' + filename;
                        try {
                            const response = await fetch(`/api/devices/${fileDevice.value}/files/download?path=${encodeURIComponent(fullPath)}`);
                            if (!response.ok) throw new Error('‰∏ãËΩΩÂ§±Ë¥•');
                            const blob = await response.blob();
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = filename;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            showToast('‰∏ãËΩΩÊàêÂäü');
                        } catch (error) {
                            showToast('‰∏ãËΩΩÂ§±Ë¥•: ' + error.message, 'error');
                        }
                    }

                    function onUploadFileSelect(event) {
                        uploadSelectedFile.value = event.target.files[0] || null;
                    }

                    async function uploadFile() {
                        if (!uploadSelectedFile.value || !fileDevice.value) return;
                        fileUploading.value = true;
                        try {
                            const formData = new FormData();
                            formData.append('file', uploadSelectedFile.value);
                            formData.append('path', filePath.value);

                            const response = await fetch(`/api/devices/${fileDevice.value}/files/upload`, {
                                method: 'POST',
                                body: formData,
                            });
                            const data = await response.json();

                            if (data.success) {
                                showToast('‰∏ä‰º†ÊàêÂäü');
                                uploadSelectedFile.value = null;
                                if (uploadFileInput.value) uploadFileInput.value.value = '';
                                await loadFiles();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('‰∏ä‰º†Â§±Ë¥•: ' + error.message, 'error');
                        } finally {
                            fileUploading.value = false;
                        }
                    }

                    async function deleteFileConfirm(filename, isDir) {
                        const type = isDir ? 'Êñá‰ª∂Â§π' : 'Êñá‰ª∂';
                        if (!confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§${type} "${filename}" ÂêóÔºü`)) return;

                        const fullPath = filePath.value + '/' + filename;
                        try {
                            const data = await apiCall(`/api/devices/${fileDevice.value}/files?path=${encodeURIComponent(fullPath)}`, {
                                method: 'DELETE',
                            });
                            if (data.success) {
                                showToast('Âà†Èô§ÊàêÂäü');
                                await loadFiles();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('Âà†Èô§Â§±Ë¥•: ' + error.message, 'error');
                        }
                    }

                    // PIN management functions
                    async function loadDevicePins() {
                        try {
                            const data = await apiCall('/api/devices/pins');
                            devicePins.value = data.pins || {};
                            // Load actual PIN values for display
                            for (const deviceId of Object.keys(devicePins.value)) {
                                try {
                                    const pinData = await apiCall(`/api/devices/${deviceId}/pin`);
                                    if (pinData.pin) {
                                        pinInputValues.value[deviceId] = pinData.pin;
                                    }
                                } catch (e) {
                                    // Ignore errors for individual PIN fetch
                                }
                            }
                        } catch (error) {
                            console.error('Failed to load device PINs:', error);
                        }
                    }

                    function updateDevicePin(deviceId, pin) {
                        pinInputValues.value[deviceId] = pin;
                        devicePins.value[deviceId] = pin ? true : false;
                    }

                    function toggleShowPin(deviceId) {
                        if (showPinFor.value === deviceId) {
                            showPinFor.value = '';
                        } else {
                            showPinFor.value = deviceId;
                        }
                    }

                    async function saveDevicePin(deviceId, pin) {
                        if (!pin) return;
                        try {
                            await apiCall(`/api/devices/${deviceId}/pin`, {
                                method: 'PUT',
                                body: JSON.stringify({ pin: pin }),
                            });
                            showToast('PIN saved');
                        } catch (error) {
                            showToast('Failed to save PIN', 'error');
                        }
                    }

                    // Auto-scroll log container
                    function scrollLogsToBottom() {
                        if (logContainer.value) {
                            logContainer.value.scrollTop = logContainer.value.scrollHeight;
                        }
                    }

                    // Task functions
                    async function runTask() {
                        if (!taskContent.value.trim()) {
                            showToast('Please enter a task', 'warning');
                            return;
                        }
                        if (selectedDevices.value.length === 0) {
                            showToast('Please select at least one device', 'warning');
                            return;
                        }

                        taskLogs.value = [];
                        taskProgress.value = 0;

                        try {
                            await apiCall('/api/tasks/run', {
                                method: 'POST',
                                body: JSON.stringify({
                                    task_content: taskContent.value,
                                    device_ids: selectedDevices.value,
                                }),
                            });
                            taskRunning.value = true;
                            showToast('Task started');
                        } catch (error) {
                            showToast('Failed to start task', 'error');
                        }
                    }

                    async function stopTask() {
                        try {
                            await apiCall('/api/tasks/stop', { method: 'POST' });
                            showToast('Stop signal sent');
                        } catch (error) {
                            showToast('Failed to stop task', 'error');
                        }
                    }

                    // Scheduler functions
                    async function loadScheduledTasks() {
                        try {
                            const data = await apiCall('/api/scheduler/tasks');
                            scheduledTasks.value = data.tasks;
                        } catch (error) {
                            console.error('Failed to load scheduled tasks:', error);
                        }
                    }

                    async function toggleScheduledTask(taskId, enabled) {
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}/toggle`, {
                                method: 'PATCH',
                                body: JSON.stringify({ enabled }),
                            });
                            await loadScheduledTasks();
                        } catch (error) {
                            showToast('Failed to toggle task', 'error');
                        }
                    }

                    async function runScheduledTaskNow(taskId) {
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}/run`, { method: 'POST' });
                            showToast('Task triggered');
                        } catch (error) {
                            showToast('Failed to run task', 'error');
                        }
                    }

                    async function deleteScheduledTask(taskId) {
                        if (!confirm('Are you sure you want to delete this task?')) return;
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}`, { method: 'DELETE' });
                            await loadScheduledTasks();
                            showToast('Task deleted');
                        } catch (error) {
                            showToast('Failed to delete task', 'error');
                        }
                    }

                    // Scheduler form functions
                    function showCreateScheduledTask() {
                        schedulerForm.value = getDefaultSchedulerForm();
                        schedulerFormMode.value = 'create';
                        showSchedulerForm.value = true;
                    }

                    function editScheduledTask(task) {
                        schedulerForm.value = {
                            id: task.id,
                            name: task.name,
                            task_content: task.task_content,
                            enabled: task.enabled,
                            schedule_type: task.schedule_type,
                            run_at: task.run_at || '',
                            interval_minutes: task.interval_minutes || 60,
                            daily_time: task.daily_time || '09:00',
                            weekly_days: task.weekly_days || [1],
                            weekly_time: task.weekly_time || '09:00',
                            monthly_day: task.monthly_day || 1,
                            monthly_time: task.monthly_time || '09:00',
                            devices: task.devices || [],
                        };
                        schedulerFormMode.value = 'edit';
                        showSchedulerForm.value = true;
                    }

                    function cancelSchedulerForm() {
                        showSchedulerForm.value = false;
                        schedulerForm.value = getDefaultSchedulerForm();
                    }

                    async function saveScheduledTask() {
                        if (!schedulerForm.value.name.trim()) {
                            showToast('Please enter a task name', 'warning');
                            return;
                        }
                        if (!schedulerForm.value.task_content.trim()) {
                            showToast('Please enter task content', 'warning');
                            return;
                        }

                        loading.value = true;
                        try {
                            if (schedulerFormMode.value === 'create') {
                                await apiCall('/api/scheduler/tasks', {
                                    method: 'POST',
                                    body: JSON.stringify(schedulerForm.value),
                                });
                                showToast('Task created');
                            } else {
                                await apiCall(`/api/scheduler/tasks/${schedulerForm.value.id}`, {
                                    method: 'PUT',
                                    body: JSON.stringify(schedulerForm.value),
                                });
                                showToast('Task updated');
                            }
                            await loadScheduledTasks();
                            cancelSchedulerForm();
                        } catch (error) {
                            showToast('Failed to save task', 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    function formatScheduleType(task) {
                        switch (task.schedule_type) {
                            case 'once': return `Once: ${task.run_at}`;
                            case 'interval': return `Every ${task.interval_minutes} min`;
                            case 'daily': return `Daily @ ${task.daily_time}`;
                            case 'weekly': return `Weekly @ ${task.weekly_time}`;
                            case 'monthly': return `Monthly day ${task.monthly_day} @ ${task.monthly_time}`;
                            default: return task.schedule_type;
                        }
                    }

                    // Scheduler logs functions
                    async function loadSchedulerLogs() {
                        try {
                            const data = await apiCall('/api/scheduler/logs?limit=50');
                            schedulerLogs.value = data.logs || [];
                        } catch (error) {
                            console.error('Failed to load scheduler logs:', error);
                        }
                    }

                    async function clearAllSchedulerLogs() {
                        if (!confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÁ©∫ÊâÄÊúâÂÆöÊó∂‰ªªÂä°ÁöÑÊâßË°åÊó•ÂøóÂêóÔºü')) return;
                        try {
                            await apiCall('/api/scheduler/logs', { method: 'DELETE' });
                            showToast('ÊâÄÊúâÊó•ÂøóÂ∑≤Ê∏ÖÁ©∫');
                            schedulerLogs.value = [];
                        } catch (error) {
                            showToast('Ê∏ÖÁ©∫Êó•ÂøóÂ§±Ë¥•: ' + error.message, 'error');
                        }
                    }

                    function formatLogTime(timestamp) {
                        if (!timestamp) return '-';
                        const date = new Date(timestamp);
                        const now = new Date();
                        const isToday = date.toDateString() === now.toDateString();
                        if (isToday) {
                            return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                        }
                        return date.toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
                    }

                    function showLogDetails(log) {
                        logDetailData.value = log;
                        showLogDetailModal.value = true;
                    }

                    async function clearTaskLogs(taskId) {
                        if (!confirm('Á°ÆÂÆöË¶ÅÊ∏ÖÈô§ËØ•‰ªªÂä°ÁöÑÊâÄÊúâÊó•ÂøóÂêóÔºü')) return;
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}/logs`, { method: 'DELETE' });
                            showToast('Êó•ÂøóÂ∑≤Ê∏ÖÈô§');
                            await loadSchedulerLogs();
                        } catch (error) {
                            showToast('Ê∏ÖÈô§Êó•ÂøóÂ§±Ë¥•', 'error');
                        }
                    }

                    // Model functions
                    async function loadModels() {
                        try {
                            const data = await apiCall('/api/models');
                            modelServices.value = data.services;
                            const active = modelServices.value.find(s => s.is_active);
                            activeModel.value = active || null;
                        } catch (error) {
                            console.error('Failed to load models:', error);
                        }
                    }

                    async function activateModel(serviceId) {
                        try {
                            await apiCall(`/api/models/${serviceId}/activate`, { method: 'POST' });
                            await loadModels();
                            showToast('Model activated');
                        } catch (error) {
                            showToast('Failed to activate model', 'error');
                        }
                    }

                    async function testModel(serviceId) {
                        loading.value = true;
                        try {
                            const data = await apiCall(`/api/models/${serviceId}/test`, { method: 'POST' });
                            showToast(data.message, data.success ? 'success' : 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    // Model CRUD functions
                    async function loadModelPresets() {
                        try {
                            const data = await apiCall('/api/models/presets');
                            modelPresets.value = data.presets || [];
                        } catch (error) {
                            console.error('Failed to load model presets:', error);
                        }
                    }

                    function openModelForm(mode, service = null) {
                        modelFormMode.value = mode;
                        if (mode === 'edit' && service) {
                            modelForm.value = { ...service };
                        } else {
                            modelForm.value = getDefaultModelForm();
                        }
                        showModelForm.value = true;
                    }

                    async function saveModel() {
                        if (!modelForm.value.name || !modelForm.value.base_url || !modelForm.value.model_name) {
                            showToast('ËØ∑Â°´ÂÜôÂøÖÂ°´Â≠óÊÆµÔºàÂêçÁß∞„ÄÅBase URL„ÄÅÊ®°ÂûãÂêçÁß∞Ôºâ', 'error');
                            return;
                        }
                        loading.value = true;
                        try {
                            if (modelFormMode.value === 'create') {
                                await apiCall('/api/models', {
                                    method: 'POST',
                                    body: JSON.stringify(modelForm.value),
                                });
                                showToast('Ê®°ÂûãÊúçÂä°ÂàõÂª∫ÊàêÂäü');
                            } else {
                                await apiCall(`/api/models/${modelForm.value.id}`, {
                                    method: 'PUT',
                                    body: JSON.stringify(modelForm.value),
                                });
                                showToast('Ê®°ÂûãÊúçÂä°Êõ¥Êñ∞ÊàêÂäü');
                            }
                            showModelForm.value = false;
                            await loadModels();
                        } catch (error) {
                            showToast('‰øùÂ≠òÂ§±Ë¥•: ' + error.message, 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    async function deleteModel(serviceId, serviceName) {
                        if (!confirm(`Á°ÆÂÆöË¶ÅÂà†Èô§Ê®°ÂûãÊúçÂä° "${serviceName}" ÂêóÔºü`)) {
                            return;
                        }
                        try {
                            await apiCall(`/api/models/${serviceId}`, { method: 'DELETE' });
                            showToast('Ê®°ÂûãÊúçÂä°Â∑≤Âà†Èô§');
                            await loadModels();
                        } catch (error) {
                            showToast('Âà†Èô§Â§±Ë¥•: ' + error.message, 'error');
                        }
                    }

                    async function testModelConfig() {
                        if (!modelForm.value.base_url || !modelForm.value.model_name) {
                            showToast('ËØ∑Â°´ÂÜô Base URL ÂíåÊ®°ÂûãÂêçÁß∞', 'error');
                            return;
                        }
                        loading.value = true;
                        try {
                            const data = await apiCall('/api/models/test', {
                                method: 'POST',
                                body: JSON.stringify({
                                    base_url: modelForm.value.base_url,
                                    api_key: modelForm.value.api_key,
                                    model_name: modelForm.value.model_name,
                                }),
                            });
                            showToast(data.message, data.success ? 'success' : 'error');
                        } catch (error) {
                            showToast('ÊµãËØïÂ§±Ë¥•: ' + error.message, 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    function addFromPreset(preset) {
                        modelForm.value = {
                            ...getDefaultModelForm(),
                            name: preset.name,
                            base_url: preset.base_url,
                            model_name: preset.model_name,
                            description: preset.description || '',
                            max_tokens: preset.max_tokens || 3000,
                            temperature: preset.temperature || 0.0,
                            protocol: preset.protocol || 'openai',
                            category: preset.category || '',
                        };
                        modelFormMode.value = 'create';
                        showModelForm.value = true;
                    }

                    // ÊåâÂàÜÁ±ªËé∑ÂèñÈ¢ÑËÆæÊ®°Êùø
                    function getPresetsByCategory(category) {
                        return modelPresets.value.filter(p => p.category === category);
                    }

                    // Settings functions
                    async function loadEmailConfig() {
                        try {
                            emailConfig.value = await apiCall('/api/settings/email');
                        } catch (error) {
                            console.error('Failed to load email config:', error);
                        }
                    }

                    async function saveEmailConfig() {
                        try {
                            await apiCall('/api/settings/email', {
                                method: 'PUT',
                                body: JSON.stringify(emailConfig.value),
                            });
                            showToast('Email settings saved');
                        } catch (error) {
                            showToast('Failed to save email settings', 'error');
                        }
                    }

                    async function testEmail() {
                        loading.value = true;
                        try {
                            const data = await apiCall('/api/settings/email/test', { method: 'POST' });
                            showToast(data.message, data.success ? 'success' : 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    // Phone Preview Functions
                    const phonePreviewStyle = Vue.computed(() => ({
                        left: previewPosition.value.x + 'px',
                        top: previewPosition.value.y + 'px',
                    }));

                    async function refreshPreview() {
                        if (!previewDeviceId.value) return;
                        // Don't set loading state - keep showing old image for smooth transition
                        try {
                            const response = await fetch(`/api/devices/${previewDeviceId.value}/screenshot/base64`);
                            if (response.ok) {
                                const data = await response.json();
                                if (data.image) {
                                    previewImage.value = data.image;
                                }
                            }
                        } catch (e) {
                            // Silently fail, keep old image
                        }
                    }

                    function openPhonePreview() {
                        updatePreviewPosition();
                        showPhonePreview.value = true;
                        if (!previewDeviceId.value && devices.value.length) {
                            previewDeviceId.value = devices.value[0].id;
                        }
                        refreshPreview();
                    }

                    function startDragPreview(e) {
                        if (e.target.closest('.phone-preview-controls') || e.target.closest('.phone-preview-body')) return;
                        isDragging = true;
                        dragOffset.x = e.clientX - previewPosition.value.x;
                        dragOffset.y = e.clientY - previewPosition.value.y;
                        document.addEventListener('mousemove', onDragPreview);
                        document.addEventListener('mouseup', stopDragPreview);
                    }

                    function onDragPreview(e) {
                        if (!isDragging) return;
                        const maxX = window.innerWidth - 320;
                        const maxY = window.innerHeight - 600;
                        previewPosition.value.x = Math.max(0, Math.min(maxX, e.clientX - dragOffset.x));
                        previewPosition.value.y = Math.max(0, Math.min(maxY, e.clientY - dragOffset.y));
                    }

                    function stopDragPreview() {
                        isDragging = false;
                        document.removeEventListener('mousemove', onDragPreview);
                        document.removeEventListener('mouseup', stopDragPreview);
                    }

                    function startPreviewAutoRefresh() {
                        stopPreviewAutoRefresh();
                        previewInterval = setInterval(() => {
                            if (showPhonePreview.value && previewDeviceId.value) {
                                refreshPreview();
                            }
                        }, 2000); // Refresh every 2 seconds
                    }

                    function stopPreviewAutoRefresh() {
                        if (previewInterval) {
                            clearInterval(previewInterval);
                            previewInterval = null;
                        }
                    }

                    // Watch showPhonePreview to start/stop auto refresh
                    watch(showPhonePreview, (show) => {
                        if (show) {
                            startPreviewAutoRefresh();
                        } else {
                            stopPreviewAutoRefresh();
                        }
                    });

                    // Lifecycle
                    onMounted(() => {
                        console.log('App mounted, initializing...');
                        connectWebSocket();
                        refreshDevices();
                        loadModels();
                        loadDevicePins();
                        initChatSessions();  // Initialize chat sessions from localStorage
                    });

                    onUnmounted(() => {
                        if (ws) ws.close();
                        if (reconnectTimer) clearTimeout(reconnectTimer);
                    });

                    // Watch page changes to load data
                    watch(currentPage, (page, oldPage) => {
                        // Á¶ªÂºÄ Chat È°µÈù¢Êó∂‰øùÂ≠òÊªöÂä®‰ΩçÁΩÆ
                        if (oldPage === 'chat' && chatMessagesRef.value) {
                            chatScrollPosition = chatMessagesRef.value.scrollTop;
                        }

                        // ËøõÂÖ• Chat È°µÈù¢Êó∂ÊÅ¢Â§çÊªöÂä®‰ΩçÁΩÆ
                        if (page === 'chat') {
                            Vue.nextTick(() => {
                                if (chatMessagesRef.value && chatScrollPosition > 0) {
                                    chatMessagesRef.value.scrollTop = chatScrollPosition;
                                }
                            });
                        }

                        if (page === 'scheduler') {
                            loadScheduledTasks();
                            loadSchedulerLogs();
                        }
                        if (page === 'models') {
                            loadModels();
                            loadModelPresets();
                        }
                        if (page === 'settings') loadEmailConfig();
                    });

                    // Watch taskLogs for auto-scroll
                    watch(taskLogs, () => {
                        // Use nextTick equivalent with setTimeout
                        setTimeout(scrollLogsToBottom, 50);
                    }, { deep: true });

                    return {
                        currentPage,
                        devices,
                        selectedDevices,
                        taskContent,
                        taskRunning,
                        taskProgress,
                        taskLogs,
                        scheduledTasks,
                        modelServices,
                        activeModel,
                        modelPresets,
                        showModelForm,
                        modelFormMode,
                        modelForm,
                        openModelForm,
                        saveModel,
                        deleteModel,
                        testModelConfig,
                        addFromPreset,
                        loadModelPresets,
                        getPresetsByCategory,
                        emailConfig,
                        wsConnected,
                        loading,
                        toasts,
                        devicePins,
                        logContainer,
                        showSchedulerForm,
                        schedulerFormMode,
                        schedulerForm,
                        // Scheduler logs
                        schedulerLogs,
                        showLogDetailModal,
                        logDetailData,
                        loadSchedulerLogs,
                        clearAllSchedulerLogs,
                        formatLogTime,
                        showLogDetails,
                        clearTaskLogs,
                        // Chat
                        chatMessages,
                        chatInput,
                        chatDeviceId,
                        chatRunning,
                        chatMessagesRef,
                        chatAutoEmail,
                        complexTaskMode,
                        sendChatMessage,
                        stopChatTask,
                        onChatDeviceChange,
                        adjustChatInputHeight,
                        openTaskDetail,
                        showTaskDetail,
                        taskDetailData,
                        // Chat sessions
                        chatSessions,
                        currentSessionId,
                        createNewSession,
                        switchSession,
                        deleteSession,
                        formatSessionTime,
                        formatMsgTime,
                        // Phone preview
                        showPhonePreview,
                        previewDeviceId,
                        previewImage,
                        previewLoading,
                        phonePreviewStyle,
                        refreshPreview,
                        openPhonePreview,
                        startDragPreview,
                        // Functions
                        showToast,
                        refreshDevices,
                        toggleDeviceSelection,
                        selectAllDevices,
                        getDeviceName,
                        unlockDevice,
                        updateDevicePin,
                        saveDevicePin,
                        loadDevicePins,
                        pinInputValues,
                        showPinFor,
                        toggleShowPin,
                        // Wireless pairing
                        pairAddress,
                        pairCode,
                        connectAddress,
                        pairingLoading,
                        connectingLoading,
                        deviceLogs,
                        wirelessPair,
                        tcpConnect,
                        disconnectDevice,
                        // APK install
                        apkTargetDevice,
                        apkFile,
                        apkInstalling,
                        apkLogs,
                        apkFileInput,
                        onApkFileSelect,
                        installApk,
                        // File manager
                        fileDevice,
                        filePath,
                        fileList,
                        fileLoading,
                        uploadSelectedFile,
                        fileUploading,
                        uploadFileInput,
                        loadFiles,
                        navigateTo,
                        goUp,
                        formatFileSize,
                        isImageFile,
                        isVideoFile,
                        isAudioFile,
                        downloadFile,
                        onUploadFileSelect,
                        uploadFile,
                        deleteFileConfirm,
                        runTask,
                        stopTask,
                        loadScheduledTasks,
                        toggleScheduledTask,
                        runScheduledTaskNow,
                        deleteScheduledTask,
                        showCreateScheduledTask,
                        editScheduledTask,
                        cancelSchedulerForm,
                        saveScheduledTask,
                        formatScheduleType,
                        loadModels,
                        activateModel,
                        testModel,
                        loadEmailConfig,
                        saveEmailConfig,
                        testEmail,
                    };
                },
            });

            app.mount('#app');
            console.log('Vue app mounted successfully');
        }

        // Initialize after page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initApp, 100);
            });
        } else {
            setTimeout(initApp, 100);
        }
    </script>
</body>

</html>