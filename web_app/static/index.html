<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutoGLM Web Server</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <style>
        [v-cloak] {
            display: none;
        }

        /* Chat Page Styles */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 48px);
            max-height: calc(100vh - 48px);
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .chat-message {
            display: flex;
            gap: 10px;
            max-width: 90%;
        }

        .chat-message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
        }

        .chat-message.assistant {
            align-self: flex-start;
        }

        .chat-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }

        .chat-message.user .chat-avatar {
            background: #3b82f6;
        }

        .chat-message.assistant .chat-avatar {
            background: #10b981;
        }

        .chat-bubble {
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.5;
            word-break: break-word;
            width: 480px;
            min-width: 200px;
            max-width: 480px;
            overflow: hidden;
        }

        .chat-message.user .chat-bubble {
            background: #3b82f6;
            color: white;
            border-bottom-right-radius: 4px;
        }

        .chat-message.assistant .chat-bubble {
            background: #f3f4f6;
            color: #18181b;
            border-bottom-left-radius: 4px;
        }

        .chat-bubble.running {
            background: #fef3c7;
            border: 1px solid #f59e0b;
        }

        .chat-bubble.error {
            background: #fee2e2;
            border: 1px solid #ef4444;
        }

        .chat-bubble.success {
            background: #d1fae5;
            border: 1px solid #10b981;
        }

        /* Compact task result */
        .task-result {
            font-size: 12px;
            margin-top: 6px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 6px;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            word-break: break-all;
        }

        .task-result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .task-log-item {
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            color: #666;
            padding: 2px 0;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            word-break: break-all;
            overflow-wrap: break-word;
            white-space: pre-wrap;
        }

        .task-log-item:last-child {
            border-bottom: none;
        }

        .subtask-log-section {
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px dashed rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .subtask-log-section:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .subtask-log-header {
            font-size: 11px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 4px;
            word-break: break-all;
            overflow-wrap: break-word;
        }

        .task-log-more {
            font-size: 10px;
            color: #9ca3af;
            font-style: italic;
        }

        .chat-meta {
            font-size: 10px;
            color: #999;
            margin-top: 4px;
            text-align: right;
        }

        /* TodoList æ ·å¼ (å¤æ‚ä»»åŠ¡æ¨¡å¼) */
        .todo-list-card {
            margin-top: 10px;
            padding: 10px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .todo-list-header {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 8px;
            color: #334155;
        }

        .todo-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 12px;
            margin-bottom: 4px;
        }

        .todo-item:last-child {
            margin-bottom: 0;
        }

        .todo-item.pending {
            background: #fff;
            color: #64748b;
        }

        .todo-item.running {
            background: #fef3c7;
            color: #92400e;
        }

        .todo-item.completed {
            background: #d1fae5;
            color: #065f46;
        }

        .todo-item.failed {
            background: #fee2e2;
            color: #991b1b;
        }

        .todo-status {
            flex-shrink: 0;
            width: 18px;
            text-align: center;
        }

        .todo-content {
            flex: 1;
            word-break: break-all;
            overflow-wrap: break-word;
            min-width: 0;
        }

        .chat-input-container {
            padding: 12px 16px;
            border-top: 1px solid #e5e5e5;
            background: white;
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid #e5e5e5;
            border-radius: 20px;
            font-size: 14px;
            resize: none;
            max-height: 100px;
            line-height: 1.4;
        }

        .chat-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .chat-send-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #3b82f6;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0;
        }

        .chat-send-btn:disabled {
            background: #d1d5db;
            cursor: not-allowed;
        }

        .chat-send-btn:hover:not(:disabled) {
            background: #2563eb;
        }

        .chat-stop-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #ef4444;
            color: white;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
            animation: pulse-red 1.5s infinite;
        }

        .chat-stop-btn:hover {
            background: #dc2626;
        }

        @keyframes pulse-red {

            0%,
            100% {
                box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4);
            }

            50% {
                box-shadow: 0 0 0 8px rgba(239, 68, 68, 0);
            }
        }

        .chat-device-selector {
            padding: 8px 16px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .chat-device-selector select {
            padding: 4px 8px;
            border: 1px solid #e5e5e5;
            border-radius: 6px;
            font-size: 12px;
            max-width: 200px;
        }

        .mini-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid #f59e0b;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 6px;
        }

        /* Chat header with email toggle */
        .chat-header {
            padding: 8px 16px;
            background: #f9fafb;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
        }

        .chat-header-right {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #666;
        }

        .email-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .toggle-switch {
            position: relative;
            width: 36px;
            height: 20px;
            background: #d1d5db;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle-switch.active {
            background: #3b82f6;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: left 0.2s;
        }

        .toggle-switch.active::after {
            left: 18px;
        }

        /* Clickable task result */
        .task-result {
            font-size: 12px;
            margin-top: 6px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.03);
            border-radius: 6px;
            max-height: 150px;
            overflow-y: auto;
            overflow-x: hidden;
            word-break: break-all;
            cursor: pointer;
            transition: background 0.2s;
        }

        .task-result:hover {
            background: rgba(0, 0, 0, 0.06);
        }

        .task-result-hint {
            font-size: 10px;
            color: #999;
            text-align: center;
            margin-top: 4px;
        }

        /* Task Detail Modal */
        .task-detail-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .task-detail-content {
            background: white;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            max-height: 85vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .task-detail-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .task-detail-header h3 {
            margin: 0;
            font-size: 16px;
        }

        .task-detail-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #999;
        }

        .task-detail-close:hover {
            color: #333;
        }

        .task-detail-body {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .task-detail-section {
            margin-bottom: 20px;
        }

        .task-detail-section h4 {
            font-size: 14px;
            margin: 0 0 10px 0;
            color: #333;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .task-detail-logs {
            background: #18181b;
            color: #a1a1aa;
            padding: 12px;
            border-radius: 8px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 11px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .task-detail-screenshot {
            text-align: center;
        }

        .task-detail-screenshot img {
            max-width: 280px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        .task-detail-screenshot-placeholder {
            padding: 40px;
            background: #f5f5f5;
            border-radius: 8px;
            color: #999;
        }

        .task-detail-stats {
            display: flex;
            gap: 20px;
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .task-detail-stat {
            text-align: center;
        }

        .task-detail-stat-value {
            font-size: 24px;
            font-weight: 600;
        }

        .task-detail-stat-label {
            font-size: 11px;
            color: #666;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Phone Preview Window Styles */
        .phone-preview-window {
            position: fixed;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            overflow: hidden;
            min-width: 180px;
            min-height: 200px;
        }

        .phone-preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #18181b;
            color: white;
            cursor: move;
            user-select: none;
        }

        .phone-preview-title {
            font-size: 13px;
            font-weight: 500;
        }

        .phone-preview-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .phone-preview-select {
            background: #27272a;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 11px;
            max-width: 100px;
            cursor: pointer;
        }

        .phone-preview-btn {
            background: #27272a;
            border: none;
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .phone-preview-btn:hover {
            background: #3f3f46;
        }

        .phone-preview-body {
            width: 300px;
            height: 540px;
            background: #f4f4f5;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .phone-preview-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .phone-preview-placeholder {
            color: #a1a1aa;
            font-size: 12px;
            text-align: center;
            padding: 20px;
        }

        .phone-preview-toggle {
            position: fixed;
            bottom: 120px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: #18181b;
            color: white;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .phone-preview-toggle:hover {
            background: #27272a;
            transform: scale(1.1);
        }

        /* Chat Sessions Sidebar */
        .chat-sessions-sidebar {
            width: 220px;
            background: #f9fafb;
            border-right: 1px solid #e5e5e5;
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .chat-sessions-header {
            padding: 12px;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-sessions-header h3 {
            font-size: 13px;
            margin: 0;
            color: #333;
        }

        .chat-new-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 4px 10px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .chat-new-btn:hover {
            background: #2563eb;
        }

        .chat-sessions-list {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
        }

        .chat-session-item {
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            margin-bottom: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }

        .chat-session-item:hover {
            background: #e5e7eb;
        }

        .chat-session-item.active {
            background: #dbeafe;
        }

        .chat-session-info {
            flex: 1;
            min-width: 0;
        }

        .chat-session-title {
            font-size: 13px;
            font-weight: 500;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .chat-session-time {
            font-size: 11px;
            color: #999;
            margin-top: 2px;
        }

        .chat-session-delete {
            background: none;
            border: none;
            color: #999;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .chat-session-item:hover .chat-session-delete {
            opacity: 1;
        }

        .chat-session-delete:hover {
            background: #fee2e2;
            color: #ef4444;
        }

        .chat-main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .chat-with-sidebar {
            display: flex;
            height: calc(100vh - 48px);
        }
    </style>
</head>

<body>
    <div id="app" v-cloak>
        <div class="app-container">
            <!-- Sidebar -->
            <aside class="sidebar">
                <div class="sidebar-header">
                    <h1>é±¼å¡˜ç®¡ç†å™¨</h1>
                    <div class="subtitle">AI æ‰‹æœºè‡ªåŠ¨åŒ–ä¸“å®¶</div>
                </div>

                <ul class="nav-menu">
                    <li class="nav-item" :class="{ active: currentPage === 'chat' }" @click="currentPage = 'chat'">
                        <span>ğŸ’¬</span>
                        <span>å¯¹è¯</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'devices' }"
                        @click="currentPage = 'devices'">
                        <span>ğŸ“±</span>
                        <span>è®¾å¤‡</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'tasks' }" @click="currentPage = 'tasks'">
                        <span>â–¶ï¸</span>
                        <span>ä»»åŠ¡æ‰§è¡Œ</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'scheduler' }"
                        @click="currentPage = 'scheduler'">
                        <span>â°</span>
                        <span>å®šæ—¶ä»»åŠ¡</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'models' }" @click="currentPage = 'models'">
                        <span>ğŸ¤–</span>
                        <span>æ¨¡å‹é…ç½®</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'files' }" @click="currentPage = 'files'">
                        <span>ğŸ“</span>
                        <span>æ–‡ä»¶ç®¡ç†</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'rules' }" @click="currentPage = 'rules'">
                        <span>ğŸ“‹</span>
                        <span>è§„åˆ™é…ç½®</span>
                    </li>
                    <li class="nav-item" :class="{ active: currentPage === 'settings' }"
                        @click="currentPage = 'settings'">
                        <span>âš™ï¸</span>
                        <span>è®¾ç½®</span>
                    </li>
                </ul>

                <!-- Connection Status -->
                <div style="position: absolute; bottom: 20px; left: 20px; right: 20px;">
                    <div class="connection-status" :class="wsConnected ? 'connected' : 'disconnected'">
                        <span class="status-dot"></span>
                        <span>{{ wsConnected ? 'å·²è¿æ¥' : 'æœªè¿æ¥' }}</span>
                    </div>
                </div>
            </aside>

            <!-- Main Content -->
            <main class="main-content">
                <!-- Chat Page (Default) -->
                <div v-if="currentPage === 'chat'" class="fade-in chat-with-sidebar">
                    <!-- Sessions Sidebar -->
                    <div class="chat-sessions-sidebar">
                        <div class="chat-sessions-header">
                            <h3>ğŸ’¬ ä¼šè¯å†å²</h3>
                            <button class="chat-new-btn" @click="createNewSession">
                                <span>+</span> æ–°å»º
                            </button>
                        </div>
                        <div class="chat-sessions-list">
                            <div v-if="chatSessions.length === 0"
                                style="text-align: center; color: #999; padding: 20px; font-size: 12px;">
                                æš‚æ— ä¼šè¯è®°å½•
                            </div>
                            <div v-for="session in chatSessions" :key="session.id" class="chat-session-item"
                                :class="{ active: currentSessionId === session.id }" @click="switchSession(session.id)">
                                <div class="chat-session-info">
                                    <div class="chat-session-title">{{ session.title || 'æ–°ä¼šè¯' }}</div>
                                    <div class="chat-session-time">{{ formatSessionTime(session.updatedAt) }}</div>
                                </div>
                                <button class="chat-session-delete" @click.stop="deleteSession(session.id)"
                                    title="åˆ é™¤ä¼šè¯">
                                    ğŸ—‘ï¸
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Main Chat Area -->
                    <div class="chat-main-area">
                        <!-- Chat Header with Device Selector and Email Toggle -->
                        <div class="chat-header">
                            <div class="chat-header-left">
                                <span>ğŸ“± è®¾å¤‡:</span>
                                <select v-model="chatDeviceId" @change="onChatDeviceChange">
                                    <option value="">é€‰æ‹©è®¾å¤‡</option>
                                    <option v-for="d in devices" :key="d.id" :value="d.id">
                                        {{ d.name || d.id.substring(0, 20) }}
                                    </option>
                                </select>
                                <span v-if="chatDeviceId" style="color: #10b981;">âœ“ å·²è¿æ¥</span>
                                <span v-else style="color: #f59e0b;">è¯·å…ˆé€‰æ‹©è®¾å¤‡</span>
                            </div>
                            <div class="chat-header-right">
                                <div class="email-toggle" v-if="complexTaskMode" style="margin-right: 12px;">
                                    <span>â±ï¸ è¶…æ—¶</span>
                                    <select v-model="subtaskTimeoutSeconds"
                                        style="padding: 4px 8px; border-radius: 6px; border: 1px solid #ddd; font-size: 12px; background: white;">
                                        <option :value="60">1åˆ†é’Ÿ</option>
                                        <option :value="120">2åˆ†é’Ÿ</option>
                                        <option :value="180">3åˆ†é’Ÿ</option>
                                        <option :value="300">5åˆ†é’Ÿ</option>
                                        <option :value="600">10åˆ†é’Ÿ</option>
                                    </select>
                                </div>
                                <div class="email-toggle">
                                    <span>ğŸ§© å¤æ‚ä»»åŠ¡</span>
                                    <div class="toggle-switch" :class="{ active: complexTaskMode }"
                                        @click="complexTaskMode = !complexTaskMode"></div>
                                </div>
                                <div class="email-toggle">
                                    <span>ğŸ“§ è‡ªåŠ¨å‘é€é‚®ä»¶</span>
                                    <div class="toggle-switch" :class="{ active: chatAutoEmail }"
                                        @click="chatAutoEmail = !chatAutoEmail"></div>
                                </div>
                            </div>
                        </div>

                        <!-- Messages Area -->
                        <div class="chat-messages" ref="chatMessagesRef">
                            <div v-if="chatMessages.length === 0"
                                style="text-align: center; color: #999; padding: 40px;">
                                <div style="font-size: 48px; margin-bottom: 16px;">ğŸ¤–</div>
                                <div>ä½ å¥½ï¼è¯·è¾“å…¥ä»»åŠ¡æŒ‡ä»¤ï¼Œæˆ‘ä¼šå¸®ä½ åœ¨æ‰‹æœºä¸Šæ‰§è¡Œã€‚</div>
                                <div style="font-size: 12px; margin-top: 8px; color: #bbb;">ä¾‹å¦‚ï¼šæ‰“å¼€å¾®ä¿¡ï¼Œå‘é€æ¶ˆæ¯ç»™æŸäºº...</div>
                            </div>
                            <div v-for="(msg, idx) in chatMessages" :key="idx" class="chat-message" :class="msg.role">
                                <div class="chat-avatar">{{ msg.role === 'user' ? 'ğŸ‘¤' : 'ğŸ¤–' }}</div>
                                <div class="chat-bubble" :class="msg.status || ''">
                                    <div v-if="msg.role === 'user'">{{ msg.content }}</div>
                                    <div v-else>
                                        <div v-if="msg.status === 'running'">
                                            <span class="mini-spinner"></span>æ­£åœ¨æ‰§è¡Œä»»åŠ¡...
                                        </div>
                                        <div v-else>{{ msg.content }}</div>
                                        <!-- TodoList æ˜¾ç¤º (å¤æ‚ä»»åŠ¡æ¨¡å¼) -->
                                        <div v-if="msg.todoList && msg.todoList.length > 0" class="todo-list-card">
                                            <div class="todo-list-header">ğŸ“‹ ä»»åŠ¡æ¸…å•</div>
                                            <div v-for="(item, ti) in msg.todoList" :key="ti" class="todo-item"
                                                :class="item.status">
                                                <div class="todo-item-header">
                                                    <span class="todo-status">
                                                        <span v-if="item.status === 'completed'">âœ…</span>
                                                        <span v-else-if="item.status === 'running'"
                                                            class="mini-spinner"></span>
                                                        <span v-else-if="item.status === 'failed'">âŒ</span>
                                                        <span v-else-if="item.status === 'skipped'">â­ï¸</span>
                                                        <span v-else>â¬œ</span>
                                                    </span>
                                                    <span class="todo-content">{{ item.content }}</span>
                                                    <span
                                                        v-if="chatRunning && item.status === 'running' && subtaskCountdown > 0"
                                                        style="margin-left: auto; padding: 2px 8px; border-radius: 4px; 
                                                               background: rgba(59, 130, 246, 0.1); color: #3b82f6; 
                                                               font-size: 11px; font-family: monospace;">
                                                        â±ï¸ {{ Math.floor(subtaskCountdown / 60) }}:{{
                                                        String(subtaskCountdown % 60).padStart(2, '0') }}
                                                    </span>
                                                    <button v-if="chatRunning && item.status === 'running'"
                                                        @click.stop="skipSubtask(msg)" title="è·³è¿‡æ­¤æ­¥éª¤"
                                                        style="margin-left: 8px; padding: 2px 8px; border-radius: 4px; 
                                                               background: rgba(251, 191, 36, 0.1); color: #d97706; border: 1px solid rgba(251, 191, 36, 0.3);
                                                               cursor: pointer; font-size: 11px; display: flex; align-items: center; gap: 4px; transition: all 0.2s;"
                                                        @mouseenter="$event.target.style.background='rgba(251, 191, 36, 0.2)'"
                                                        @mouseleave="$event.target.style.background='rgba(251, 191, 36, 0.1)'">
                                                        â­ï¸ è·³è¿‡
                                                    </button>
                                                </div>
                                            </div>
                                        </div>
                                        <!-- Compact Task Result (Clickable) - é›†ä¸­æ˜¾ç¤ºæ‰€æœ‰å­ä»»åŠ¡æ—¥å¿— -->
                                        <div v-if="(msg.logs && msg.logs.length > 0) || (msg.todoList && msg.todoList.some(t => t.logs && t.logs.length > 0))"
                                            class="task-result" @click="openTaskDetail(msg)">
                                            <div class="task-result-header">
                                                <span>æ‰§è¡Œæ—¥å¿—</span>
                                                <span v-if="msg.status === 'success'" style="color: #10b981;">âœ“
                                                    å®Œæˆ</span>
                                                <span v-else-if="msg.status === 'error'" style="color: #ef4444;">âœ—
                                                    å¤±è´¥</span>
                                            </div>
                                            <!-- æŒ‰å­ä»»åŠ¡åˆ†ç»„æ˜¾ç¤ºæ—¥å¿— -->
                                            <template
                                                v-if="msg.todoList && msg.todoList.some(t => t.logs && t.logs.length > 0)">
                                                <template v-for="(item, ti) in msg.todoList" :key="'todo-log-'+ti">
                                                    <div v-if="item.logs && item.logs.length > 0"
                                                        class="subtask-log-section">
                                                        <div class="subtask-log-header">
                                                            <span v-if="item.status === 'completed'">âœ…</span>
                                                            <span v-else-if="item.status === 'running'"
                                                                class="mini-spinner"></span>
                                                            <span v-else-if="item.status === 'failed'">âŒ</span>
                                                            <span v-else>â¬œ</span>
                                                            {{ item.content }}
                                                        </div>
                                                        <div v-for="(log, li) in item.logs.slice(-3)" :key="li"
                                                            class="task-log-item">{{ log }}</div>
                                                        <div v-if="item.logs.length > 3" class="task-log-more">... å…± {{
                                                            item.logs.length }} æ¡</div>
                                                    </div>
                                                </template>
                                            </template>
                                            <!-- æ™®é€šæ—¥å¿—ï¼ˆéå­ä»»åŠ¡æ¨¡å¼ï¼‰ -->
                                            <template v-else-if="msg.logs && msg.logs.length > 0">
                                                <div v-for="(log, i) in msg.logs.slice(-3)" :key="i"
                                                    class="task-log-item">
                                                    {{ log }}
                                                </div>
                                            </template>
                                            <div class="task-result-hint">ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…å’Œæˆªå›¾ â†’</div>
                                        </div>
                                    </div>
                                    <!-- æ—¶é—´æˆ³å’Œtokenæ˜¾ç¤º -->
                                    <div class="chat-meta" v-if="msg.timestamp">
                                        <button v-if="msg.role === 'user' && !chatRunning" class="retry-icon-btn"
                                            @click.stop="retryMessage(msg.content)" title="é‡æ–°å‘é€" style="background: none; border: none; cursor: pointer; font-size: 12px; margin-right: 6px; 
                                                   opacity: 0.6; transition: opacity 0.2s; padding: 0;"
                                            @mouseenter="$event.target.style.opacity='1'"
                                            @mouseleave="$event.target.style.opacity='0.6'">
                                            ğŸ”„
                                        </button>
                                        <span>{{ formatMsgTime(msg.timestamp) }}</span>
                                        <span v-if="msg.tokens" style="margin-left: 8px;">{{ msg.tokens }} tokens</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Input Area -->
                        <div class="chat-input-container">
                            <textarea v-model="chatInput" class="chat-input" placeholder="è¾“å…¥ä»»åŠ¡æŒ‡ä»¤..." rows="1"
                                @keydown.enter.exact.prevent="sendChatMessage" @input="adjustChatInputHeight"
                                :disabled="chatRunning"></textarea>
                            <button v-if="chatRunning" class="chat-stop-btn" @click="stopChatTask" title="åœæ­¢ä»»åŠ¡">
                                â¹
                            </button>
                            <button v-else class="chat-send-btn" @click="sendChatMessage"
                                :disabled="!chatInput.trim() || !chatDeviceId">
                                â¤
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Devices Page -->
                <div v-if="currentPage === 'devices'" class="fade-in">
                    <!-- Wireless Pairing Card -->
                    <div class="card" style="margin-bottom: 16px;">
                        <div class="card-header">
                            <h2 class="card-title">ğŸ“¶ æ— çº¿è¿æ¥</h2>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <!-- Wireless Pairing -->
                            <div style="padding: 12px; background: #f8fafc; border-radius: 8px;">
                                <h4 style="margin-bottom: 12px; font-size: 14px;">æ— çº¿é…å¯¹ (é¦–æ¬¡è¿æ¥)</h4>
                                <div class="form-group" style="margin-bottom: 8px;">
                                    <input type="text" v-model="pairAddress" class="form-input"
                                        placeholder="é…å¯¹åœ°å€ (å¦‚: 192.168.1.100:37000)">
                                </div>
                                <div class="form-group" style="margin-bottom: 8px;">
                                    <input type="text" v-model="pairCode" class="form-input" placeholder="6ä½é…å¯¹ç "
                                        maxlength="6">
                                </div>
                                <button class="btn btn-primary" @click="wirelessPair" :disabled="pairingLoading">
                                    {{ pairingLoading ? 'é…å¯¹ä¸­...' : 'ğŸ”— é…å¯¹' }}
                                </button>
                            </div>
                            <!-- TCP Connect -->
                            <div style="padding: 12px; background: #f8fafc; border-radius: 8px;">
                                <h4 style="margin-bottom: 12px; font-size: 14px;">TCP è¿æ¥ (å·²é…å¯¹è®¾å¤‡)</h4>
                                <div class="form-group" style="margin-bottom: 8px;">
                                    <input type="text" v-model="connectAddress" class="form-input"
                                        placeholder="è¿æ¥åœ°å€ (å¦‚: 192.168.1.100:5555)">
                                </div>
                                <button class="btn btn-success" @click="tcpConnect" :disabled="connectingLoading">
                                    {{ connectingLoading ? 'è¿æ¥ä¸­...' : 'ğŸ“± è¿æ¥' }}
                                </button>
                            </div>
                        </div>
                        <!-- Connection Logs -->
                        <div v-if="deviceLogs.length > 0" style="margin-top: 12px;">
                            <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">è¿æ¥æ—¥å¿—:</div>
                            <div
                                style="background: #18181b; color: #a1a1aa; padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 11px; max-height: 100px; overflow-y: auto;">
                                <div v-for="(log, i) in deviceLogs" :key="i">{{ log }}</div>
                            </div>
                        </div>
                    </div>

                    <!-- Devices List Card -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">å·²è¿æ¥è®¾å¤‡</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-primary" @click="refreshDevices" :disabled="loading">
                                    <span v-if="loading" class="loading-spinner"></span>
                                    <span v-else>ğŸ”„</span>
                                    åˆ·æ–°
                                </button>
                            </div>
                        </div>

                        <!-- APK Install Section -->
                        <div v-if="devices.length > 0"
                            style="margin-bottom: 16px; padding: 12px; background: #f0fdf4; border-radius: 8px; border: 1px solid #86efac;">
                            <h4 style="margin-bottom: 12px; font-size: 14px;">ğŸ“¦ APK å®‰è£…</h4>
                            <div style="display: flex; gap: 12px; align-items: flex-end; flex-wrap: wrap;">
                                <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 200px;">
                                    <label class="form-label" style="font-size: 12px;">é€‰æ‹©è®¾å¤‡</label>
                                    <select v-model="apkTargetDevice" class="form-select">
                                        <option value="">è¯·é€‰æ‹©è®¾å¤‡</option>
                                        <option v-for="d in devices" :key="d.id" :value="d.id">
                                            {{ d.name || d.id.substring(0, 20) }}
                                        </option>
                                    </select>
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label class="form-label" style="font-size: 12px;">APK æ–‡ä»¶</label>
                                    <input type="file" ref="apkFileInput" accept=".apk" @change="onApkFileSelect"
                                        style="font-size: 12px;">
                                </div>
                                <button class="btn btn-success" @click="installApk"
                                    :disabled="apkInstalling || !apkTargetDevice || !apkFile">
                                    {{ apkInstalling ? 'å®‰è£…ä¸­...' : 'ğŸ“² å®‰è£…' }}
                                </button>
                            </div>
                            <div v-if="apkFile" style="margin-top: 8px; font-size: 12px; color: #666;">
                                å·²é€‰æ‹©: {{ apkFile.name }} ({{ (apkFile.size / 1024 / 1024).toFixed(2) }} MB)
                            </div>
                            <!-- APK Install Logs -->
                            <div v-if="apkLogs.length > 0" style="margin-top: 12px;">
                                <div
                                    style="background: #18181b; color: #a1a1aa; padding: 8px 12px; border-radius: 6px; font-family: monospace; font-size: 11px; max-height: 100px; overflow-y: auto;">
                                    <div v-for="(log, i) in apkLogs" :key="i">{{ log }}</div>
                                </div>
                            </div>
                        </div>

                        <div v-if="loading && devices.length === 0" class="empty-state" style="padding: 40px;">
                            <div class="loading-spinner" style="width: 40px; height: 40px;"></div>
                            <p style="margin-top: 16px;">åŠ è½½è®¾å¤‡ä¸­...</p>
                        </div>

                        <div v-else-if="devices.length === 0" class="empty-state">
                            <div style="font-size: 3rem; margin-bottom: 16px;">ğŸ“±</div>
                            <h3>æœªå‘ç°è®¾å¤‡</h3>
                            <p>é€šè¿‡USBè¿æ¥è®¾å¤‡æˆ–ä½¿ç”¨ä¸Šæ–¹æ— çº¿é…å¯¹ï¼Œç„¶åç‚¹å‡»åˆ·æ–°</p>
                        </div>

                        <div v-else class="device-grid">
                            <div v-for="device in devices" :key="device.id" class="device-card"
                                :class="{ selected: selectedDevices.includes(device.id) }"
                                @click="toggleDeviceSelection(device.id)">
                                <div class="device-header">
                                    <div class="device-icon">ğŸ“±</div>
                                    <div>
                                        <div class="device-name">{{ device.name || device.id }}</div>
                                        <div class="device-id">{{ device.id.substring(0, 30) }}...</div>
                                    </div>
                                </div>
                                <div>
                                    <span class="device-status" :class="'status-' + device.status">
                                        {{ device.status }}
                                    </span>
                                    <span v-if="device.model"
                                        style="margin-left: 8px; font-size: 0.75rem; color: var(--text-secondary);">
                                        {{ device.model }}
                                    </span>
                                </div>
                                <div
                                    style="margin-top: 12px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;">
                                    <button class="btn btn-sm btn-secondary" @click.stop="unlockDevice(device.id)">
                                        ğŸ”“ è§£é”
                                    </button>
                                    <button v-if="device.id.includes(':')" class="btn btn-sm btn-danger"
                                        @click.stop="disconnectDevice(device.id)" title="æ–­å¼€æ— çº¿è¿æ¥">
                                        âŒ æ–­å¼€
                                    </button>
                                    <div style="position: relative; display: flex; align-items: center;">
                                        <input :type="showPinFor === device.id ? 'text' : 'password'" class="form-input"
                                            style="width: 100px; height: 28px; font-size: 12px; padding: 4px 28px 4px 8px;"
                                            :placeholder="devicePins[device.id] ? 'â€¢â€¢â€¢â€¢' : 'PIN'" @click.stop
                                            :value="pinInputValues[device.id] || ''"
                                            @input="updateDevicePin(device.id, $event.target.value)"
                                            @blur="saveDevicePin(device.id, $event.target.value)">
                                        <button v-if="devicePins[device.id] || pinInputValues[device.id]"
                                            style="position: absolute; right: 4px; background: none; border: none; cursor: pointer; font-size: 14px; padding: 2px;"
                                            @click.stop="toggleShowPin(device.id)"
                                            :title="showPinFor === device.id ? 'éšè—PIN' : 'æ˜¾ç¤ºPIN'">
                                            {{ showPinFor === device.id ? 'ğŸ™ˆ' : 'ğŸ‘ï¸' }}
                                        </button>
                                    </div>
                                    <span v-if="devicePins[device.id]" style="color: #22c55e; font-size: 12px;">âœ“</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Tasks Page -->
                <div v-if="currentPage === 'tasks'" class="fade-in">
                    <!-- Select Devices -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">é€‰æ‹©è®¾å¤‡ ({{ selectedDevices.length }}/{{ devices.length }})</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-secondary btn-sm" @click="selectAllDevices">
                                    {{ selectedDevices.length === devices.length ? 'å–æ¶ˆå…¨é€‰' : 'å…¨é€‰' }}
                                </button>
                                <button class="btn btn-secondary btn-sm" @click="refreshDevices" :disabled="loading">
                                    ğŸ”„ åˆ·æ–°
                                </button>
                            </div>
                        </div>
                        <div v-if="devices.length === 0" class="empty-state" style="padding: 20px;">
                            <p>æš‚æ— å·²è¿æ¥è®¾å¤‡ï¼Œè¯·å…ˆè¿æ¥è®¾å¤‡</p>
                        </div>
                        <div v-else style="display: flex; flex-wrap: wrap; gap: 12px; padding: 8px 0;">
                            <label v-for="device in devices" :key="device.id" class="device-select-item"
                                :class="{ selected: selectedDevices.includes(device.id) }" style="display: flex; align-items: center; gap: 8px; padding: 10px 14px; 
                                       background: var(--bg-secondary); border-radius: 8px; cursor: pointer;
                                       border: 2px solid transparent; transition: all 0.2s;"
                                :style="{ borderColor: selectedDevices.includes(device.id) ? 'var(--primary)' : 'transparent' }">
                                <input type="checkbox" :value="device.id" v-model="selectedDevices"
                                    style="width: 18px; height: 18px; cursor: pointer;">
                                <div>
                                    <div style="font-weight: 500;">{{ device.name || device.id.substring(0, 20) }}</div>
                                    <div style="font-size: 12px; color: var(--text-secondary);">
                                        {{ device.status === 'connected' ? 'ğŸŸ¢ åœ¨çº¿' : 'ğŸ”´ ç¦»çº¿' }}
                                    </div>
                                </div>
                            </label>
                        </div>
                    </div>

                    <!-- Task Input -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ä»»åŠ¡</h2>
                        </div>
                        <div class="form-group">
                            <textarea v-model="taskContent" class="form-textarea"
                                placeholder="Enter task instructions... (e.g., Open WeChat and send a message to...)"
                                rows="4" :disabled="taskRunning"></textarea>
                        </div>
                        <div style="display: flex; gap: 12px;">
                            <button class="btn btn-primary" @click="runTask"
                                :disabled="taskRunning || selectedDevices.length === 0">
                                â–¶ï¸ æ‰§è¡Œä»»åŠ¡
                            </button>
                            <button class="btn btn-danger" @click="stopTask" :disabled="!taskRunning">
                                â¹ï¸ åœæ­¢
                            </button>
                        </div>

                        <!-- Progress -->
                        <div v-if="taskRunning" style="margin-top: 16px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                                <span>Progress</span>
                                <span>{{ taskProgress }}%</span>
                            </div>
                            <div class="progress-bar">
                                <div class="progress-fill" :style="{ width: taskProgress + '%' }"></div>
                            </div>
                        </div>
                    </div>

                    <!-- Logs -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">æ‰§è¡Œæ—¥å¿—</h2>
                            <button class="btn btn-secondary btn-sm" @click="taskLogs = []">
                                æ¸…ç©º
                            </button>
                        </div>
                        <div class="log-output" ref="logContainer">
                            <div v-if="taskLogs.length === 0" style="color: #666;">
                                Logs will appear here...
                            </div>
                            <div v-for="(log, index) in taskLogs" :key="index">
                                <span style="color: #888;">[{{ log.time }}]</span> {{ log.message }}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Scheduler Page -->
                <div v-if="currentPage === 'scheduler'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">å®šæ—¶ä»»åŠ¡åˆ—è¡¨</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-primary" @click="showCreateScheduledTask">
                                    â• æ–°å»ºä»»åŠ¡
                                </button>
                                <button class="btn btn-secondary" @click="loadScheduledTasks">
                                    ğŸ”„ åˆ·æ–°
                                </button>
                            </div>
                        </div>

                        <div v-if="scheduledTasks.length === 0 && !showSchedulerForm" class="empty-state">
                            <div style="font-size: 3rem; margin-bottom: 16px;">â°</div>
                            <h3>æš‚æ— å®šæ—¶ä»»åŠ¡</h3>
                            <p>ç‚¹å‡»"æ–°å»ºä»»åŠ¡"åˆ›å»ºå®šæ—¶ä»»åŠ¡</p>
                        </div>

                        <div v-else-if="!showSchedulerForm" class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Name</th>
                                        <th>Schedule</th>
                                        <th>Next Run</th>
                                        <th>Status</th>
                                        <th>Actions</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="task in scheduledTasks" :key="task.id">
                                        <td>
                                            <strong>{{ task.name }}</strong>
                                            <div style="font-size: 0.75rem; color: var(--text-secondary);">
                                                {{ task.task_content.substring(0, 50) }}...
                                            </div>
                                        </td>
                                        <td>{{ formatScheduleType(task) }}</td>
                                        <td>{{ task.next_run ? new Date(task.next_run).toLocaleString() : '-' }}</td>
                                        <td>
                                            <span class="badge"
                                                :class="task.enabled ? 'badge-success' : 'badge-warning'">
                                                {{ task.enabled ? 'Enabled' : 'Disabled' }}
                                            </span>
                                        </td>
                                        <td>
                                            <button class="btn btn-sm btn-secondary" @click="editScheduledTask(task)">
                                                âœï¸ Edit
                                            </button>
                                            <button class="btn btn-sm btn-secondary"
                                                @click="toggleScheduledTask(task.id, !task.enabled)"
                                                style="margin-left: 4px;">
                                                {{ task.enabled ? 'â¸ï¸' : 'â–¶ï¸' }}
                                            </button>
                                            <button class="btn btn-sm btn-primary" @click="runScheduledTaskNow(task.id)"
                                                style="margin-left: 4px;">
                                                âš¡ Run
                                            </button>
                                            <button class="btn btn-sm btn-danger" @click="deleteScheduledTask(task.id)"
                                                style="margin-left: 4px;">
                                                ğŸ—‘ï¸
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- Scheduler Form -->
                        <div v-if="showSchedulerForm" style="padding: 16px;">
                            <h3 style="margin-bottom: 16px;">{{ schedulerFormMode === 'create' ? 'åˆ›å»ºå®šæ—¶ä»»åŠ¡' :
                                'ç¼–è¾‘ä»»åŠ¡' }}</h3>

                            <div class="form-group">
                                <label class="form-label">ä»»åŠ¡åç§°</label>
                                <input type="text" v-model="schedulerForm.name" class="form-input" placeholder="æˆ‘çš„å®šæ—¶ä»»åŠ¡">
                            </div>

                            <div class="form-group">
                                <label class="form-label">ä»»åŠ¡å†…å®¹</label>
                                <textarea v-model="schedulerForm.task_content" class="form-textarea" rows="3"
                                    placeholder="è¾“å…¥ä»»åŠ¡æŒ‡ä»¤..."></textarea>
                            </div>

                            <div class="form-group">
                                <label class="form-label">ä»»åŠ¡ç±»å‹</label>
                                <select v-model="schedulerForm.schedule_type" class="form-select">
                                    <option value="once">å•æ¬¡</option>
                                    <option value="interval">é—´éš”</option>
                                    <option value="daily">æ¯å¤©</option>
                                    <option value="weekly">æ¯å‘¨</option>
                                    <option value="monthly">æ¯æœˆ</option>
                                </select>
                            </div>

                            <!-- Once -->
                            <div v-if="schedulerForm.schedule_type === 'once'" class="form-group">
                                <label class="form-label">æ‰§è¡Œæ—¶é—´</label>
                                <input type="datetime-local" v-model="schedulerForm.run_at" class="form-input">
                            </div>

                            <!-- Interval -->
                            <div v-if="schedulerForm.schedule_type === 'interval'" class="form-group">
                                <label class="form-label">é—´éš”æ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰</label>
                                <input type="number" v-model.number="schedulerForm.interval_minutes" class="form-input"
                                    min="1">
                            </div>

                            <!-- Daily -->
                            <div v-if="schedulerForm.schedule_type === 'daily'" class="form-group">
                                <label class="form-label">æ¯å¤©æ—¶é—´</label>
                                <input type="time" v-model="schedulerForm.daily_time" class="form-input">
                            </div>

                            <!-- Weekly -->
                            <div v-if="schedulerForm.schedule_type === 'weekly'">
                                <div class="form-group">
                                    <label class="form-label">æ¯å‘¨å“ªå‡ å¤©</label>
                                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                                        <label v-for="(day, index) in ['æ—¥', 'ä¸€', 'äºŒ', 'ä¸‰', 'å››', 'äº”', 'å…­']" :key="index"
                                            style="display: flex; align-items: center; gap: 4px;">
                                            <input type="checkbox" :value="index" v-model="schedulerForm.weekly_days">
                                            {{ day }}
                                        </label>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">æ—¶é—´</label>
                                    <input type="time" v-model="schedulerForm.weekly_time" class="form-input">
                                </div>
                            </div>

                            <!-- Monthly -->
                            <div v-if="schedulerForm.schedule_type === 'monthly'">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                                    <div class="form-group">
                                        <label class="form-label">æ¯æœˆç¬¬å‡ å¤©</label>
                                        <input type="number" v-model.number="schedulerForm.monthly_day"
                                            class="form-input" min="1" max="31">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">æ—¶é—´</label>
                                        <input type="time" v-model="schedulerForm.monthly_time" class="form-input">
                                    </div>
                                </div>
                            </div>

                            <!-- Target Devices -->
                            <div class="form-group">
                                <label class="form-label">ç›®æ ‡è®¾å¤‡ï¼ˆç•™ç©ºè¡¨ç¤ºæ‰€æœ‰è®¾å¤‡ï¼‰</label>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <label v-for="device in devices" :key="device.id"
                                        style="display: flex; align-items: center; gap: 4px; padding: 4px 8px; background: #f3f4f6; border-radius: 4px;">
                                        <input type="checkbox" :value="device.id" v-model="schedulerForm.devices">
                                        {{ device.name || device.id.substring(0, 15) }}
                                    </label>
                                </div>
                            </div>

                            <div class="form-group">
                                <label style="display: flex; align-items: center; gap: 8px;">
                                    <input type="checkbox" v-model="schedulerForm.enabled">
                                    ç«‹å³å¯ç”¨ä»»åŠ¡
                                </label>
                            </div>

                            <div style="display: flex; gap: 12px; margin-top: 16px;">
                                <button class="btn btn-primary" @click="saveScheduledTask" :disabled="loading">
                                    {{ schedulerFormMode === 'create' ? 'âœ… åˆ›å»º' : 'ğŸ’¾ ä¿å­˜' }}
                                </button>
                                <button class="btn btn-secondary" @click="cancelSchedulerForm">
                                    å–æ¶ˆ
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Scheduler Logs Card -->
                    <div class="card" style="margin-top: 16px;">
                        <div class="card-header">
                            <h2 class="card-title">ğŸ“‹ æ‰§è¡Œæ—¥å¿—</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-secondary btn-sm" @click="clearAllSchedulerLogs">
                                    ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰
                                </button>
                                <button class="btn btn-secondary btn-sm" @click="loadSchedulerLogs">
                                    ğŸ”„ åˆ·æ–°æ—¥å¿—
                                </button>
                            </div>
                        </div>

                        <div v-if="schedulerLogs.length === 0" class="empty-state" style="padding: 30px;">
                            <div style="font-size: 2rem; margin-bottom: 12px;">ğŸ“</div>
                            <p>æš‚æ— æ‰§è¡Œæ—¥å¿—</p>
                        </div>

                        <div v-else class="table-container" style="max-height: 300px; overflow-y: auto;">
                            <table>
                                <thead>
                                    <tr>
                                        <th style="width: 60px;">çŠ¶æ€</th>
                                        <th>ä»»åŠ¡åç§°</th>
                                        <th>æ‰§è¡Œæ—¶é—´</th>
                                        <th>ç»“æœ</th>
                                        <th style="width: 80px;">è¯¦æƒ…</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="(log, i) in schedulerLogs" :key="i">
                                        <td style="text-align: center;">
                                            <span v-if="log.success" style="color: #22c55e;">âœ…</span>
                                            <span v-else style="color: #ef4444;">âŒ</span>
                                        </td>
                                        <td>{{ log.task_name }}</td>
                                        <td style="font-size: 12px;">{{ formatLogTime(log.timestamp) }}</td>
                                        <td>{{ log.message }}</td>
                                        <td>
                                            <button v-if="log.details" class="btn btn-sm btn-secondary"
                                                @click="showLogDetails(log)">
                                                ğŸ‘ï¸
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Log Details Modal -->
                    <div v-if="showLogDetailModal" class="modal-overlay" @click.self="showLogDetailModal = false">
                        <div class="modal-content" style="max-width: 700px;">
                            <div class="modal-header">
                                <h3>ğŸ“‹ æ‰§è¡Œæ—¥å¿—è¯¦æƒ…</h3>
                                <button class="btn btn-sm" @click="showLogDetailModal = false">âœ•</button>
                            </div>
                            <div class="modal-body">
                                <div style="margin-bottom: 12px;">
                                    <strong>ä»»åŠ¡:</strong> {{ logDetailData.task_name }}<br>
                                    <strong>æ—¶é—´:</strong> {{ formatLogTime(logDetailData.timestamp) }}<br>
                                    <strong>çŠ¶æ€:</strong>
                                    <span :style="{ color: logDetailData.success ? '#22c55e' : '#ef4444' }">
                                        {{ logDetailData.success ? 'æˆåŠŸ' : 'å¤±è´¥' }}
                                    </span>
                                </div>
                                <div
                                    style="background: #18181b; color: #a1a1aa; padding: 12px; border-radius: 8px; font-family: monospace; font-size: 11px; max-height: 400px; overflow-y: auto; white-space: pre-wrap;">
                                    {{ logDetailData.details || 'æ— è¯¦ç»†æ—¥å¿—' }}</div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" @click="showLogDetailModal = false">å…³é—­</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Models Page -->
                <div v-if="currentPage === 'models'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">æ¨¡å‹æœåŠ¡ç®¡ç†</h2>
                            <div style="display: flex; gap: 8px;">
                                <button class="btn btn-success" @click="openModelForm('create')">
                                    â• æ–°å¢æ¨¡å‹
                                </button>
                                <button class="btn btn-primary" @click="loadModels">
                                    ğŸ”„ åˆ·æ–°
                                </button>
                            </div>
                        </div>

                        <div v-if="activeModel"
                            style="margin-bottom: 16px; padding: 12px; background: #eff6ff; border-radius: 8px;">
                            <strong>å½“å‰æ¿€æ´»:</strong> {{ activeModel.name }} ({{ activeModel.model_name }})
                        </div>

                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>åç§°</th>
                                        <th>åè®®</th>
                                        <th>æ¨¡å‹</th>
                                        <th>Base URL</th>
                                        <th>çŠ¶æ€</th>
                                        <th>æ“ä½œ</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="service in modelServices" :key="service.id">
                                        <td>
                                            <strong>{{ service.name }}</strong>
                                            <div style="font-size: 0.75rem; color: var(--text-secondary);">
                                                {{ service.description }}
                                            </div>
                                        </td>
                                        <td>
                                            <span class="badge" :style="{
                                                background: service.protocol === 'openai' ? '#10a37f' :
                                                           service.protocol === 'anthropic' ? '#d97706' :
                                                           service.protocol === 'gemini' ? '#4285f4' : '#666',
                                                color: 'white'
                                            }">
                                                {{ service.protocol === 'openai' ? 'OpenAI' :
                                                service.protocol === 'anthropic' ? 'Anthropic' :
                                                service.protocol === 'gemini' ? 'Gemini' : 'Unknown' }}
                                            </span>
                                        </td>
                                        <td>{{ service.model_name }}</td>
                                        <td
                                            style="font-size: 0.75rem; max-width: 200px; overflow: hidden; text-overflow: ellipsis;">
                                            {{ service.base_url }}</td>
                                        <td>
                                            <span class="badge"
                                                :class="service.is_active ? 'badge-success' : 'badge-info'">
                                                {{ service.is_active ? 'å·²æ¿€æ´»' : 'æœªæ¿€æ´»' }}
                                            </span>
                                        </td>
                                        <td>
                                            <button class="btn btn-sm btn-primary" @click="activateModel(service.id)"
                                                :disabled="service.is_active" title="æ¿€æ´»æ­¤æ¨¡å‹">
                                                æ¿€æ´»
                                            </button>
                                            <button class="btn btn-sm btn-secondary" @click="testModel(service.id)"
                                                :disabled="loading" style="margin-left: 4px;" title="æµ‹è¯•è¿æ¥">
                                                æµ‹è¯•
                                            </button>
                                            <button class="btn btn-sm btn-secondary"
                                                @click="openModelForm('edit', service)" style="margin-left: 4px;"
                                                title="ç¼–è¾‘">
                                                âœï¸
                                            </button>
                                            <button class="btn btn-sm btn-danger"
                                                @click="deleteModel(service.id, service.name)"
                                                :disabled="service.is_active" style="margin-left: 4px;" title="åˆ é™¤">
                                                ğŸ—‘ï¸
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>

                        <!-- é¢„è®¾æ¨¡æ¿ - æŒ‰åè®®åˆ†ç±» -->
                        <div style="margin-top: 20px;">
                            <h3 style="font-size: 1rem; margin-bottom: 12px;">ğŸš€ å¿«é€Ÿæ·»åŠ é¢„è®¾æ¨¡æ¿</h3>

                            <!-- OpenAI åè®® -->
                            <div v-if="getPresetsByCategory('OpenAI åè®®').length > 0" style="margin-bottom: 16px;">
                                <div
                                    style="font-size: 0.85rem; color: #666; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                    <span
                                        style="background: #10a37f; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem;">OpenAI</span>
                                    <span>å…¼å®¹åè®® (/v1/chat/completions)</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <button v-for="preset in getPresetsByCategory('OpenAI åè®®')" :key="preset.id"
                                        class="btn btn-sm btn-secondary" @click="addFromPreset(preset)"
                                        :title="preset.description">
                                        {{ preset.name }}
                                    </button>
                                </div>
                            </div>

                            <!-- Anthropic åè®® -->
                            <div v-if="getPresetsByCategory('Anthropic åè®®').length > 0" style="margin-bottom: 16px;">
                                <div
                                    style="font-size: 0.85rem; color: #666; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                    <span
                                        style="background: #d97706; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem;">Anthropic</span>
                                    <span>åè®® (/v1/messages)</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <button v-for="preset in getPresetsByCategory('Anthropic åè®®')" :key="preset.id"
                                        class="btn btn-sm btn-secondary" @click="addFromPreset(preset)"
                                        :title="preset.description" style="border-color: #d97706;">
                                        {{ preset.name }}
                                    </button>
                                </div>
                            </div>

                            <!-- Gemini åè®® -->
                            <div v-if="getPresetsByCategory('Gemini åè®®').length > 0" style="margin-bottom: 16px;">
                                <div
                                    style="font-size: 0.85rem; color: #666; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                    <span
                                        style="background: #4285f4; color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem;">Gemini</span>
                                    <span>åè®® (Google AI)</span>
                                </div>
                                <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                    <button v-for="preset in getPresetsByCategory('Gemini åè®®')" :key="preset.id"
                                        class="btn btn-sm btn-secondary" @click="addFromPreset(preset)"
                                        :title="preset.description" style="border-color: #4285f4;">
                                        {{ preset.name }}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- æ¨¡å‹ç¼–è¾‘å¼¹çª— -->
                    <div v-if="showModelForm" class="modal-overlay" @click.self="showModelForm = false">
                        <div class="modal-content" style="max-width: 500px;">
                            <div class="modal-header">
                                <h3>{{ modelFormMode === 'create' ? 'æ–°å¢æ¨¡å‹æœåŠ¡' : 'ç¼–è¾‘æ¨¡å‹æœåŠ¡' }}</h3>
                                <button class="btn btn-sm" @click="showModelForm = false">âœ•</button>
                            </div>
                            <div class="modal-body">
                                <div class="form-group">
                                    <label class="form-label">æœåŠ¡åç§° *</label>
                                    <input type="text" v-model="modelForm.name" class="form-input"
                                        placeholder="ä¾‹å¦‚: OpenAI GPT-4">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">åè®®ç±»å‹ *</label>
                                    <select v-model="modelForm.protocol" class="form-select">
                                        <option value="openai">OpenAI åè®® (/v1/chat/completions)</option>
                                        <option value="anthropic">Anthropic åè®® (/v1/messages)</option>
                                        <option value="gemini">Gemini åè®® (Google AI)</option>
                                    </select>
                                    <div style="font-size: 0.75rem; color: #666; margin-top: 4px;">
                                        <span v-if="modelForm.protocol === 'openai'">é€‚ç”¨äºå¤§å¤šæ•°å…¼å®¹OpenAI APIçš„æœåŠ¡</span>
                                        <span v-else-if="modelForm.protocol === 'anthropic'">é€‚ç”¨äºAnthropic Claude
                                            API</span>
                                        <span v-else-if="modelForm.protocol === 'gemini'">é€‚ç”¨äºGoogle Gemini API</span>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">Base URL *</label>
                                    <input type="text" v-model="modelForm.base_url" class="form-input"
                                        :placeholder="modelForm.protocol === 'openai' ? 'https://api.openai.com/v1' : modelForm.protocol === 'anthropic' ? 'https://api.anthropic.com/v1/messages' : 'https://generativelanguage.googleapis.com/v1beta'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">æ¨¡å‹åç§° *</label>
                                    <input type="text" v-model="modelForm.model_name" class="form-input"
                                        :placeholder="modelForm.protocol === 'openai' ? 'gpt-4o' : modelForm.protocol === 'anthropic' ? 'claude-sonnet-4-20250514' : 'gemini-2.0-flash'">
                                </div>
                                <div class="form-group">
                                    <label class="form-label">API Key</label>
                                    <input type="password" v-model="modelForm.api_key" class="form-input"
                                        placeholder="sk-...">
                                </div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                                    <div class="form-group">
                                        <label class="form-label">Max Tokens</label>
                                        <input type="number" v-model="modelForm.max_tokens" class="form-input">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label">Temperature</label>
                                        <input type="number" step="0.1" v-model="modelForm.temperature"
                                            class="form-input">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label">æè¿°</label>
                                    <input type="text" v-model="modelForm.description" class="form-input"
                                        placeholder="å¯é€‰æè¿°">
                                </div>
                            </div>
                            <div class="modal-footer">
                                <button class="btn btn-secondary" @click="showModelForm = false">å–æ¶ˆ</button>
                                <button class="btn btn-primary" @click="testModelConfig" :disabled="loading">
                                    {{ loading ? 'æµ‹è¯•ä¸­...' : 'æµ‹è¯•è¿æ¥' }}
                                </button>
                                <button class="btn btn-success" @click="saveModel" :disabled="loading">
                                    {{ modelFormMode === 'create' ? 'åˆ›å»º' : 'ä¿å­˜' }}
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Files Page -->
                <div v-if="currentPage === 'files'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ğŸ“ æ–‡ä»¶ç®¡ç†</h2>
                        </div>

                        <!-- Device and Path Selection -->
                        <div
                            style="display: flex; gap: 12px; margin-bottom: 16px; align-items: flex-end; flex-wrap: wrap;">
                            <div class="form-group" style="margin-bottom: 0; min-width: 200px;">
                                <label class="form-label">é€‰æ‹©è®¾å¤‡</label>
                                <select v-model="fileDevice" class="form-select" @change="loadFiles">
                                    <option value="">è¯·é€‰æ‹©è®¾å¤‡</option>
                                    <option v-for="d in devices" :key="d.id" :value="d.id">
                                        {{ d.name || d.id.substring(0, 20) }}
                                    </option>
                                </select>
                            </div>
                            <div class="form-group" style="margin-bottom: 0; flex: 1; min-width: 250px;">
                                <label class="form-label">å½“å‰è·¯å¾„</label>
                                <div style="display: flex; gap: 8px;">
                                    <input type="text" v-model="filePath" class="form-input" placeholder="/sdcard"
                                        @keyup.enter="loadFiles">
                                    <button class="btn btn-primary" @click="loadFiles"
                                        :disabled="!fileDevice || fileLoading">
                                        {{ fileLoading ? '*' : 'GO' }}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Quick Navigation -->
                        <div style="margin-bottom: 12px; display: flex; gap: 8px; flex-wrap: wrap;">
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard')">ğŸ“± SDå¡</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/DCIM')">ğŸ“· ç›¸å†Œ</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/Download')">ğŸ“¥
                                ä¸‹è½½</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/Pictures')">ğŸ–¼ï¸
                                å›¾ç‰‡</button>
                            <button class="btn btn-sm btn-secondary" @click="navigateTo('/sdcard/Documents')">ğŸ“„
                                æ–‡æ¡£</button>
                            <button class="btn btn-sm btn-secondary" @click="goUp" :disabled="filePath === '/'">â¬†ï¸
                                ä¸Šçº§</button>
                        </div>

                        <!-- Upload Section -->
                        <div
                            style="margin-bottom: 16px; padding: 12px; background: #f0fdf4; border-radius: 8px; border: 1px solid #86efac;">
                            <div style="display: flex; gap: 12px; align-items: center; flex-wrap: wrap;">
                                <span style="font-size: 14px;">ğŸ“¤ ä¸Šä¼ æ–‡ä»¶åˆ°å½“å‰ç›®å½•:</span>
                                <input type="file" ref="uploadFileInput" @change="onUploadFileSelect"
                                    style="font-size: 12px;">
                                <button class="btn btn-sm btn-success" @click="uploadFile"
                                    :disabled="!uploadSelectedFile || !fileDevice || fileUploading">
                                    {{ fileUploading ? 'ä¸Šä¼ ä¸­...' : 'ä¸Šä¼ ' }}
                                </button>
                            </div>
                        </div>

                        <!-- File List -->
                        <div v-if="!fileDevice" class="empty-state" style="padding: 40px;">
                            <div style="font-size: 3rem;">ğŸ“</div>
                            <p>è¯·å…ˆé€‰æ‹©è®¾å¤‡</p>
                        </div>

                        <div v-else-if="fileLoading" class="empty-state" style="padding: 40px;">
                            <div class="loading-spinner" style="width: 40px; height: 40px;"></div>
                            <p style="margin-top: 16px;">åŠ è½½ä¸­...</p>
                        </div>

                        <div v-else-if="fileList.length === 0" class="empty-state" style="padding: 40px;">
                            <div style="font-size: 3rem;">ğŸ“‚</div>
                            <p>ç›®å½•ä¸ºç©º</p>
                        </div>

                        <div v-else class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th style="width: 40px;"></th>
                                        <th>åç§°</th>
                                        <th style="width: 100px;">å¤§å°</th>
                                        <th style="width: 120px;">æ“ä½œ</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="file in fileList" :key="file.name"
                                        :style="{ cursor: file.is_dir ? 'pointer' : 'default' }"
                                        @dblclick="file.is_dir && navigateTo(filePath + '/' + file.name)">
                                        <td style="text-align: center;">
                                            <span v-if="file.is_dir">ğŸ“</span>
                                            <span v-else-if="file.is_link">ğŸ”—</span>
                                            <span v-else-if="isImageFile(file.name)">ğŸ–¼ï¸</span>
                                            <span v-else-if="isVideoFile(file.name)">ğŸ¬</span>
                                            <span v-else-if="isAudioFile(file.name)">ğŸµ</span>
                                            <span v-else>ğŸ“„</span>
                                        </td>
                                        <td>
                                            <span @click="file.is_dir && navigateTo(filePath + '/' + file.name)"
                                                :style="{ color: file.is_dir ? '#3b82f6' : 'inherit', cursor: file.is_dir ? 'pointer' : 'default' }">
                                                {{ file.name }}
                                            </span>
                                        </td>
                                        <td style="font-size: 12px; color: #666;">
                                            {{ file.is_dir ? '-' : formatFileSize(file.size) }}
                                        </td>
                                        <td>
                                            <button v-if="!file.is_dir" class="btn btn-sm btn-secondary"
                                                @click="downloadFile(file.name)" title="ä¸‹è½½">
                                                â¬‡ï¸
                                            </button>
                                            <button class="btn btn-sm btn-danger"
                                                @click="deleteFileConfirm(file.name, file.is_dir)"
                                                style="margin-left: 4px;" title="åˆ é™¤">
                                                ğŸ—‘ï¸
                                            </button>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <!-- Settings Page -->
                <div v-if="currentPage === 'settings'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">é‚®ä»¶è®¾ç½®</h2>
                        </div>

                        <div class="form-group">
                            <label class="form-label">SMTP æœåŠ¡å™¨</label>
                            <input type="text" v-model="emailConfig.smtp_server" class="form-input"
                                placeholder="smtp.example.com">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <div class="form-group">
                                <label class="form-label">ç«¯å£</label>
                                <input type="number" v-model="emailConfig.smtp_port" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">åŠ å¯†</label>
                                <select v-model="emailConfig.use_ssl" class="form-select">
                                    <option :value="true">SSL</option>
                                    <option :value="false">None/TLS</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">å‘é€é‚®ç®±</label>
                            <input type="email" v-model="emailConfig.sender_email" class="form-input"
                                placeholder="your@email.com">
                        </div>

                        <div class="form-group">
                            <label class="form-label">å¯†ç  / æˆæƒç </label>
                            <input type="password" v-model="emailConfig.sender_password" class="form-input"
                                placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢">
                        </div>

                        <div class="form-group">
                            <label class="form-label">æ”¶ä»¶äººï¼ˆé€—å·åˆ†éš”ï¼‰</label>
                            <input type="text" v-model="emailConfig.recipient_emails" class="form-input"
                                placeholder="user1@email.com, user2@email.com">
                        </div>

                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" v-model="emailConfig.enabled">
                                å¯ç”¨è‡ªåŠ¨é‚®ä»¶æŠ¥å‘Š
                            </label>
                        </div>

                        <div style="display: flex; gap: 12px;">
                            <button class="btn btn-primary" @click="saveEmailConfig">
                                ä¿å­˜è®¾ç½®
                            </button>
                            <button class="btn btn-secondary" @click="testEmail" :disabled="loading">
                                å‘é€æµ‹è¯•é‚®ä»¶
                            </button>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">å…³äº</h2>
                        </div>
                        <p><strong>AutoGLM Web Server</strong> v0.1.0</p>
                        <p style="margin-top: 8px; color: var(--text-secondary);">
                            AI-powered phone automation tool. Web interface for Open-AutoGLM-GUI.
                        </p>
                        <p style="margin-top: 8px;">
                            <a href="/docs" target="_blank">API Documentation</a>
                        </p>
                    </div>
                </div>

                <!-- Rules Page -->
                <div v-if="currentPage === 'rules'" class="fade-in">
                    <!-- App Mappings Card -->
                    <div class="card">
                        <div class="card-header"
                            style="display: flex; justify-content: space-between; align-items: center;">
                            <h2 class="card-title">ğŸ“± åº”ç”¨æ˜ å°„</h2>
                            <button class="btn btn-sm btn-primary" @click="showAddAppModal = true">+ æ·»åŠ </button>
                        </div>
                        <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                            é…ç½®åº”ç”¨åç§°åˆ°åŒ…åçš„æ˜ å°„ï¼Œç”¨äº Launch åŠ¨ä½œ
                        </p>
                        <div v-if="appMappings.length === 0" class="empty-state" style="padding: 20px;">
                            <p>æš‚æ— åº”ç”¨æ˜ å°„é…ç½®</p>
                        </div>
                        <div v-else style="max-height: 300px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="border-bottom: 1px solid var(--border);">
                                        <th style="text-align: left; padding: 8px; font-weight: 500;">
                                            åº”ç”¨åç§°</th>
                                        <th style="text-align: left; padding: 8px; font-weight: 500;">åŒ…å
                                        </th>
                                        <th style="text-align: right; padding: 8px; font-weight: 500; width: 100px;">
                                            æ“ä½œ
                                        </th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr v-for="app in appMappings" :key="app.app_name"
                                        style="border-bottom: 1px solid var(--border);">
                                        <td style="padding: 8px;">
                                            {{ app.app_name }}
                                            <span v-if="app.is_custom"
                                                style="font-size: 12px; color: var(--primary); margin-left: 4px;">è‡ªå®šä¹‰</span>
                                        </td>
                                        <td
                                            style="padding: 8px; color: var(--text-secondary); font-family: monospace; font-size: 13px;">
                                            {{ app.package_name }}
                                        </td>
                                        <td style="padding: 8px; text-align: right;">
                                            <template v-if="app.is_custom">
                                                <button class="btn btn-sm btn-secondary" @click="editAppMapping(app)"
                                                    style="margin-right: 4px;">ç¼–è¾‘</button>
                                                <button class="btn btn-sm btn-danger"
                                                    @click="deleteAppMapping(app.app_name)">åˆ é™¤</button>
                                            </template>
                                            <span v-else
                                                style="color: var(--text-secondary); font-size: 12px;">å†…ç½®</span>
                                        </td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <!-- Timing Config Card -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">â±ï¸ æ—¶é—´å»¶è¿Ÿé…ç½®</h2>
                        </div>
                        <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                            é…ç½®å„ç§æ“ä½œçš„å»¶è¿Ÿæ—¶é—´ï¼ˆå•ä½ï¼šç§’ï¼‰
                        </p>
                        <div v-if="timingConfig">
                            <!-- Action Timing -->
                            <div style="margin-bottom: 16px;">
                                <h4 style="margin-bottom: 8px; font-size: 14px; color: var(--text-secondary);">
                                    åŠ¨ä½œå»¶è¿Ÿ</h4>
                                <div
                                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px;">
                                    <div v-for="(value, key) in timingConfig.action" :key="'action-'+key"
                                        class="form-group" style="margin-bottom: 0;">
                                        <label class="form-label" style="font-size: 12px;">{{
                                            formatTimingKey(key)
                                            }}</label>
                                        <input type="number" step="0.1" min="0" :value="value"
                                            @change="updateTiming('action', key, $event.target.value)"
                                            class="form-input" style="font-size: 13px;">
                                    </div>
                                </div>
                            </div>
                            <!-- Device Timing -->
                            <div style="margin-bottom: 16px;">
                                <h4 style="margin-bottom: 8px; font-size: 14px; color: var(--text-secondary);">
                                    è®¾å¤‡å»¶è¿Ÿ</h4>
                                <div
                                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px;">
                                    <div v-for="(value, key) in timingConfig.device" :key="'device-'+key"
                                        class="form-group" style="margin-bottom: 0;">
                                        <label class="form-label" style="font-size: 12px;">{{
                                            formatTimingKey(key)
                                            }}</label>
                                        <input type="number" step="0.1" min="0" :value="value"
                                            @change="updateTiming('device', key, $event.target.value)"
                                            class="form-input" style="font-size: 13px;">
                                    </div>
                                </div>
                            </div>
                            <!-- Connection Timing -->
                            <div>
                                <h4 style="margin-bottom: 8px; font-size: 14px; color: var(--text-secondary);">
                                    è¿æ¥å»¶è¿Ÿ</h4>
                                <div
                                    style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 12px;">
                                    <div v-for="(value, key) in timingConfig.connection" :key="'conn-'+key"
                                        class="form-group" style="margin-bottom: 0;">
                                        <label class="form-label" style="font-size: 12px;">{{
                                            formatTimingKey(key)
                                            }}</label>
                                        <input type="number" step="0.1" min="0" :value="value"
                                            @change="updateTiming('connection', key, $event.target.value)"
                                            class="form-input" style="font-size: 13px;">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Action Rules Card -->
                    <div class="card">
                        <div class="card-header"
                            style="display: flex; justify-content: space-between; align-items: center;">
                            <h2 class="card-title">ğŸ¯ åŠ¨ä½œè§„åˆ™</h2>
                            <button class="btn btn-sm btn-secondary" @click="resetActionRules">é‡ç½®ä¸ºé»˜è®¤</button>
                        </div>
                        <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                            é…ç½®å„ç§åŠ¨ä½œçš„æ‰§è¡Œè§„åˆ™å’Œæ¡ä»¶
                        </p>
                        <div v-if="actionRules.length === 0" class="empty-state" style="padding: 20px;">
                            <p>åŠ è½½ä¸­...</p>
                        </div>
                        <div v-else>
                            <div v-for="action in actionRules" :key="action.name" class="action-rule-item"
                                style="border: 1px solid var(--border); border-radius: 8px; margin-bottom: 12px; overflow: hidden;">
                                <div @click="toggleActionExpand(action.name)"
                                    style="padding: 12px 16px; background: var(--bg-secondary); cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <strong>{{ action.name }}</strong>
                                        <span v-if="action.is_custom"
                                            style="font-size: 12px; color: var(--primary); margin-left: 8px;">è‡ªå®šä¹‰</span>
                                        <p style="font-size: 13px; color: var(--text-secondary); margin: 4px 0 0 0;">
                                            {{ action.description }}</p>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 12px; color: var(--text-secondary);">{{
                                            action.rules ? action.rules.length : 0 }} æ¡è§„åˆ™</span>
                                        <span style="transition: transform 0.2s;"
                                            :style="{ transform: expandedActions[action.name] ? 'rotate(90deg)' : '' }">â–¶</span>
                                    </div>
                                </div>
                                <div v-if="expandedActions[action.name]"
                                    style="padding: 16px; border-top: 1px solid var(--border);">
                                    <div
                                        style="margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center;">
                                        <span style="font-size: 13px; color: var(--text-secondary);">è§„åˆ™åˆ—è¡¨</span>
                                        <button class="btn btn-sm btn-primary" @click="showAddRuleModal(action.name)">+
                                            æ·»åŠ è§„åˆ™</button>
                                    </div>
                                    <div v-if="!action.rules || action.rules.length === 0"
                                        style="padding: 20px; text-align: center; color: var(--text-secondary);">
                                        æš‚æ— è§„åˆ™
                                    </div>
                                    <div v-else>
                                        <div v-for="rule in action.rules" :key="rule.id"
                                            style="padding: 10px; background: var(--bg-secondary); border-radius: 6px; margin-bottom: 8px;">
                                            <div
                                                style="display: flex; justify-content: space-between; align-items: flex-start;">
                                                <div style="flex: 1;">
                                                    <div
                                                        style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                                        <label
                                                            style="display: flex; align-items: center; cursor: pointer;">
                                                            <input type="checkbox" :checked="rule.enabled"
                                                                @change="toggleRuleEnabled(action.name, rule.id)"
                                                                style="margin-right: 6px;">
                                                        </label>
                                                        <strong style="font-size: 13px;"
                                                            :style="{ opacity: rule.enabled ? 1 : 0.5 }">
                                                            {{ rule.condition }}
                                                        </strong>
                                                    </div>
                                                    <p style="font-size: 12px; color: var(--text-secondary); margin: 0;"
                                                        :style="{ opacity: rule.enabled ? 1 : 0.5 }">
                                                        â†’ {{ rule.action }}
                                                    </p>
                                                </div>
                                                <div style="display: flex; gap: 4px;">
                                                    <button class="btn btn-sm btn-secondary"
                                                        @click="editRuleItem(action.name, rule)">ç¼–è¾‘</button>
                                                    <button class="btn btn-sm btn-danger"
                                                        @click="deleteRuleItem(action.name, rule.id)">åˆ é™¤</button>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- System Prompts Card -->
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">ğŸ“ ç³»ç»Ÿæç¤ºè¯</h2>
                        </div>
                        <p style="color: var(--text-secondary); margin-bottom: 16px; font-size: 14px;">
                            è‡ªå®šä¹‰ AI æ¨¡å‹çš„ç³»ç»Ÿæç¤ºè¯
                        </p>
                        <div v-if="systemPrompts">
                            <div v-for="(prompt, key) in systemPrompts" :key="key" style="margin-bottom: 16px;">
                                <div
                                    style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                    <label class="form-label" style="margin-bottom: 0;">
                                        {{ prompt.name }}
                                        <span v-if="prompt.is_customized"
                                            style="font-size: 12px; color: var(--primary); margin-left: 4px;">(å·²è‡ªå®šä¹‰)</span>
                                    </label>
                                    <button v-if="prompt.is_customized" class="btn btn-sm btn-secondary"
                                        @click="resetPrompt(key)">
                                        é‡ç½®
                                    </button>
                                </div>
                                <textarea v-model="prompt.content" class="form-input"
                                    style="min-height: 150px; font-family: monospace; font-size: 13px;"
                                    @blur="savePrompt(key, prompt.content)"></textarea>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Settings Page -->
                <div v-if="currentPage === 'settings'" class="fade-in">
                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">é‚®ä»¶è®¾ç½®</h2>
                        </div>

                        <div class="form-group">
                            <label class="form-label">SMTP æœåŠ¡å™¨</label>
                            <input type="text" v-model="emailConfig.smtp_server" class="form-input"
                                placeholder="smtp.example.com">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px;">
                            <div class="form-group">
                                <label class="form-label">ç«¯å£</label>
                                <input type="number" v-model="emailConfig.smtp_port" class="form-input">
                            </div>
                            <div class="form-group">
                                <label class="form-label">åŠ å¯†</label>
                                <select v-model="emailConfig.use_ssl" class="form-select">
                                    <option :value="true">SSL</option>
                                    <option :value="false">None/TLS</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">å‘é€é‚®ç®±</label>
                            <input type="email" v-model="emailConfig.sender_email" class="form-input"
                                placeholder="your@email.com">
                        </div>

                        <div class="form-group">
                            <label class="form-label">å¯†ç  / æˆæƒç </label>
                            <input type="password" v-model="emailConfig.sender_password" class="form-input"
                                placeholder="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢">
                        </div>

                        <div class="form-group">
                            <label class="form-label">æ”¶ä»¶äººï¼ˆé€—å·åˆ†éš”ï¼‰</label>
                            <input type="text" v-model="emailConfig.recipient_emails" class="form-input"
                                placeholder="user1@email.com, user2@email.com">
                        </div>

                        <div class="form-group">
                            <label style="display: flex; align-items: center; gap: 8px;">
                                <input type="checkbox" v-model="emailConfig.enabled">
                                å¯ç”¨è‡ªåŠ¨é‚®ä»¶æŠ¥å‘Š
                            </label>
                        </div>

                        <div style="display: flex; gap: 12px;">
                            <button class="btn btn-primary" @click="saveEmailConfig">
                                ä¿å­˜è®¾ç½®
                            </button>
                            <button class="btn btn-secondary" @click="testEmail" :disabled="loading">
                                å‘é€æµ‹è¯•é‚®ä»¶
                            </button>
                        </div>
                    </div>

                    <div class="card">
                        <div class="card-header">
                            <h2 class="card-title">å…³äº</h2>
                        </div>
                        <p><strong>AutoGLM Web Server</strong> v0.1.0</p>
                        <p style="margin-top: 8px; color: var(--text-secondary);">
                            AI-powered phone automation tool. Web interface for Open-AutoGLM-GUI.
                        </p>
                        <p style="margin-top: 8px;">
                            <a href="/docs" target="_blank">API Documentation</a>
                        </p>
                    </div>
                </div>
            </main>
        </div>

        <!-- Task Detail Modal -->
        <div v-cloak v-if="showTaskDetail" class="task-detail-modal" @click.self="showTaskDetail = false">
            <div class="task-detail-content">
                <div class="task-detail-header">
                    <h3>ğŸ“‹ ä»»åŠ¡æ‰§è¡Œè¯¦æƒ…</h3>
                    <button class="task-detail-close" @click="showTaskDetail = false">âœ•</button>
                </div>
                <div class="task-detail-body">
                    <!-- Stats -->
                    <div class="task-detail-section">
                        <div class="task-detail-stats">
                            <div class="task-detail-stat">
                                <div class="task-detail-stat-value"
                                    :style="{ color: taskDetailData.status === 'success' ? '#10b981' : '#ef4444' }">
                                    {{ taskDetailData.status === 'success' ? 'âœ“' : 'âœ—' }}
                                </div>
                                <div class="task-detail-stat-label">{{ taskDetailData.status === 'success' ? 'æ‰§è¡ŒæˆåŠŸ' :
                                    'æ‰§è¡Œå¤±è´¥' }}</div>
                            </div>
                            <div class="task-detail-stat">
                                <div class="task-detail-stat-value">{{ taskDetailData.logs ? taskDetailData.logs.length
                                    : 0 }}</div>
                                <div class="task-detail-stat-label">æ—¥å¿—æ¡æ•°</div>
                            </div>
                            <div class="task-detail-stat">
                                <div class="task-detail-stat-value">{{ (taskDetailData.screenshots &&
                                    taskDetailData.screenshots.length > 0) ? 'âœ“' : 'â€”' }}</div>
                                <div class="task-detail-stat-label">æˆªå›¾</div>
                            </div>
                        </div>
                    </div>

                    <!-- Screenshot -->
                    <div class="task-detail-section">
                        <h4>ğŸ“¸ æ‰§è¡Œæˆªå›¾</h4>
                        <div class="task-detail-screenshot">
                            <template v-if="taskDetailData.screenshots && taskDetailData.screenshots.length > 0">
                                <img v-for="s in taskDetailData.screenshots" :key="s.id" :src="s.image_url"
                                    alt="Screenshot"
                                    style="max-width: 200px; margin-bottom: 8px; cursor: pointer; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);"
                                    @click="window.open(s.image_url, '_blank')">
                            </template>
                            <div v-else class="task-detail-screenshot-placeholder">
                                æš‚æ— æˆªå›¾
                            </div>
                        </div>
                    </div>

                    <!-- Full Logs -->
                    <div class="task-detail-section">
                        <h4>ğŸ“ å®Œæ•´æ‰§è¡Œæ—¥å¿—</h4>
                        <div class="task-detail-logs">
                            <div v-if="taskDetailData.logs && taskDetailData.logs.length > 0">
                                <div v-for="(log, i) in taskDetailData.logs" :key="i">{{ log }}</div>
                            </div>
                            <div v-else>æš‚æ— æ—¥å¿—</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Toast Notifications -->
        <div class="toast-container">
            <div v-for="toast in toasts" :key="toast.id" class="toast" :class="toast.type">
                {{ toast.message }}
            </div>
        </div>

        <!-- Floating Phone Preview Window -->
        <div v-if="showPhonePreview" class="phone-preview-window" :style="phonePreviewStyle"
            @mousedown="startDragPreview">
            <div class="phone-preview-header">
                <span class="phone-preview-title">ğŸ“± Live Preview</span>
                <div class="phone-preview-controls">
                    <select v-model="previewDeviceId" @change="refreshPreview" class="phone-preview-select"
                        @mousedown.stop>
                        <option value="">Select Device</option>
                        <option v-for="d in devices" :key="d.id" :value="d.id">
                            {{ d.name || d.id.substring(0, 15) }}
                        </option>
                    </select>
                    <button class="phone-preview-btn" @click.stop="refreshPreview" title="Refresh">ğŸ”„</button>
                    <button class="phone-preview-btn" @click.stop="showPhonePreview = false" title="Close">âœ•</button>
                </div>
            </div>
            <div class="phone-preview-body">
                <div v-if="!previewDeviceId" class="phone-preview-placeholder">
                    Select a device to preview
                </div>
                <img v-else-if="previewImage" :src="'data:image/png;base64,' + previewImage" class="phone-preview-image"
                    @error="previewImage = null">
                <div v-else class="phone-preview-placeholder">
                    Loading...
                </div>
            </div>
        </div>

        <!-- App Mapping Modal -->
        <div v-if="showAddAppModal" class="task-detail-modal" @click.self="showAddAppModal = false">
            <div class="task-detail-content" style="max-width: 500px;">
                <div class="task-detail-header">
                    <h3>{{ editingApp ? 'ç¼–è¾‘åº”ç”¨æ˜ å°„' : 'æ·»åŠ åº”ç”¨æ˜ å°„' }}</h3>
                    <button class="task-detail-close" @click="showAddAppModal = false">âœ•</button>
                </div>
                <div class="task-detail-body" style="padding: 20px;">
                    <div class="form-group">
                        <label class="form-label">åº”ç”¨åç§°</label>
                        <input type="text" v-model="appForm.app_name" class="form-input" placeholder="å¦‚ï¼šå¾®ä¿¡"
                            :disabled="editingApp && !editingApp.is_custom">
                    </div>
                    <div class="form-group">
                        <label class="form-label">åŒ…å</label>
                        <input type="text" v-model="appForm.package_name" class="form-input"
                            placeholder="å¦‚ï¼šcom.tencent.mm">
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
                        <button class="btn btn-secondary" @click="showAddAppModal = false">å–æ¶ˆ</button>
                        <button class="btn btn-primary" @click="saveAppMapping">ä¿å­˜</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Rule Item Modal -->
        <div v-if="showRuleModal" class="task-detail-modal" @click.self="showRuleModal = false">
            <div class="task-detail-content" style="max-width: 500px;">
                <div class="task-detail-header">
                    <h3>{{ editingRule ? 'ç¼–è¾‘è§„åˆ™' : 'æ·»åŠ è§„åˆ™' }} - {{ editingRuleAction }}</h3>
                    <button class="task-detail-close" @click="showRuleModal = false">âœ•</button>
                </div>
                <div class="task-detail-body" style="padding: 20px;">
                    <div class="form-group">
                        <label class="form-label">æ¡ä»¶</label>
                        <input type="text" v-model="ruleForm.condition" class="form-input" placeholder="å¦‚ï¼šåº”ç”¨æœªå®‰è£…">
                    </div>
                    <div class="form-group">
                        <label class="form-label">åŠ¨ä½œ</label>
                        <input type="text" v-model="ruleForm.action" class="form-input" placeholder="å¦‚ï¼šè¿”å›é”™è¯¯æç¤º">
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div class="form-group">
                            <label class="form-label">ä¼˜å…ˆçº§</label>
                            <input type="number" v-model.number="ruleForm.priority" class="form-input" min="0">
                        </div>
                        <div class="form-group">
                            <label class="form-label">çŠ¶æ€</label>
                            <select v-model="ruleForm.enabled" class="form-select">
                                <option :value="true">å¯ç”¨</option>
                                <option :value="false">ç¦ç”¨</option>
                            </select>
                        </div>
                    </div>
                    <div style="display: flex; gap: 12px; justify-content: flex-end; margin-top: 20px;">
                        <button class="btn btn-secondary" @click="showRuleModal = false">å–æ¶ˆ</button>
                        <button class="btn btn-primary" @click="saveRuleItem">ä¿å­˜</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Phone Preview Toggle Button -->
        <button v-if="!showPhonePreview && devices.length > 0" class="phone-preview-toggle" @click="openPhonePreview"
            title="Show Phone Preview">
            ğŸ“±
        </button>
    </div>

    <!-- Vue.js 3 CDN with fallback -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <script>
        // Wait for Vue to load, with fallback
        function initApp() {
            if (typeof Vue === 'undefined') {
                document.getElementById('app').innerHTML = '<div style="padding: 40px; text-align: center;"><h2>Loading failed</h2><p>Unable to load Vue.js. Please check your internet connection.</p><button onclick="location.reload()">Retry</button></div>';
                return;
            }

            const { createApp, ref, onMounted, onUnmounted, watch } = Vue;

            const app = createApp({
                setup() {
                    // State
                    const currentPage = ref('chat');  // Default to chat page
                    const devices = ref([]);
                    const selectedDevices = ref([]);
                    const taskContent = ref('');
                    const taskRunning = ref(false);
                    const taskProgress = ref(0);
                    const taskLogs = ref([]);
                    const scheduledTasks = ref([]);
                    const modelServices = ref([]);
                    const activeModel = ref(null);
                    const modelPresets = ref([]);
                    const showModelForm = ref(false);
                    const modelFormMode = ref('create');
                    const modelForm = ref(getDefaultModelForm());

                    function getDefaultModelForm() {
                        return {
                            id: '',
                            name: '',
                            base_url: '',
                            api_key: '',
                            model_name: '',
                            max_tokens: 3000,
                            temperature: 0.0,
                            top_p: 0.85,
                            frequency_penalty: 0.2,
                            description: '',
                            is_active: false,
                            protocol: 'openai',
                            category: '',
                        };
                    }
                    const emailConfig = ref({});
                    // Rules configuration state
                    const appMappings = ref([]);
                    const timingConfig = ref(null);
                    const systemPrompts = ref(null);
                    const showAddAppModal = ref(false);
                    const editingApp = ref(null);
                    const appForm = ref({ app_name: '', package_name: '' });
                    // Action rules state
                    const actionRules = ref([]);
                    const expandedActions = ref({});
                    const showRuleModal = ref(false);
                    const editingRuleAction = ref('');
                    const editingRule = ref(null);
                    const ruleForm = ref({ condition: '', action: '', priority: 0, enabled: true });
                    const wsConnected = ref(false);
                    const loading = ref(false);
                    const toasts = ref([]);
                    const devicePins = ref({});
                    const pinInputValues = ref({});  // Store input values for PIN fields
                    const showPinFor = ref('');  // Device ID for which PIN is visible
                    // Wireless pairing state
                    const pairAddress = ref('');
                    const pairCode = ref('');
                    const connectAddress = ref('');
                    const pairingLoading = ref(false);
                    const connectingLoading = ref(false);
                    const deviceLogs = ref([]);
                    // APK install state
                    const apkTargetDevice = ref('');
                    const apkFile = ref(null);
                    const apkInstalling = ref(false);
                    const apkLogs = ref([]);
                    const apkFileInput = ref(null);
                    // File manager state
                    const fileDevice = ref('');
                    const filePath = ref('/sdcard');
                    const fileList = ref([]);
                    const fileLoading = ref(false);
                    const uploadSelectedFile = ref(null);
                    const fileUploading = ref(false);
                    const uploadFileInput = ref(null);
                    const logContainer = ref(null);
                    const showSchedulerForm = ref(false);
                    const schedulerFormMode = ref('create');
                    const schedulerForm = ref(getDefaultSchedulerForm());
                    // Scheduler logs state
                    const schedulerLogs = ref([]);
                    const showLogDetailModal = ref(false);
                    const logDetailData = ref({});

                    // Phone preview state
                    const showPhonePreview = ref(false);
                    const previewDeviceId = ref('');
                    const previewImage = ref(null);
                    const previewLoading = ref(false);
                    const previewPosition = ref({ x: 100, y: 100 });
                    let previewInterval = null;
                    let isDragging = false;
                    let dragOffset = { x: 0, y: 0 };

                    // Chat state
                    const chatMessages = ref([]);
                    const chatInput = ref('');
                    const chatDeviceId = ref('');
                    const chatRunning = ref(false);
                    const chatMessagesRef = ref(null);
                    const chatAutoEmail = ref(false);  // Default: no auto email in chat mode
                    const complexTaskMode = ref(false);  // å¤æ‚ä»»åŠ¡æ¨¡å¼ï¼šå…ˆæ‹†è§£æˆtodolistå†é€ä¸ªæ‰§è¡Œ
                    const subtaskTimeoutSeconds = ref(180);  // å­ä»»åŠ¡è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰ï¼Œé»˜è®¤3åˆ†é’Ÿ
                    const subtaskCountdown = ref(0);  // å­ä»»åŠ¡å‰©ä½™ç§’æ•°ï¼ˆç”¨äºå€’è®¡æ—¶æ˜¾ç¤ºï¼‰
                    let subtaskCountdownTimer = null;  // å€’è®¡æ—¶å®šæ—¶å™¨
                    let currentChatTaskId = null;
                    let chatScrollPosition = 0;  // ä¿å­˜ Chat æ»šåŠ¨ä½ç½®

                    // Chat sessions state
                    const chatSessions = ref([]);
                    const currentSessionId = ref('');
                    const SESSIONS_STORAGE_KEY = 'autoglm_chat_sessions';

                    // Task detail modal state
                    const showTaskDetail = ref(false);
                    const taskDetailData = ref({});

                    // Calculate safe position for preview window
                    function updatePreviewPosition() {
                        const windowWidth = 300;
                        const windowHeight = 580; // 540 + header
                        const margin = 20;
                        previewPosition.value = {
                            x: Math.max(margin, window.innerWidth - windowWidth - margin),
                            y: Math.max(margin, window.innerHeight - windowHeight - margin)
                        };
                    }

                    function getDefaultSchedulerForm() {
                        return {
                            id: '',
                            name: '',
                            task_content: '',
                            enabled: true,
                            schedule_type: 'daily',
                            run_at: '',
                            interval_minutes: 60,
                            daily_time: '09:00',
                            weekly_days: [1],
                            weekly_time: '09:00',
                            monthly_day: 1,
                            monthly_time: '09:00',
                            devices: [],
                        };
                    }

                    // WebSocket
                    let ws = null;
                    let reconnectTimer = null;

                    function showToast(message, type = 'success') {
                        const id = Date.now();
                        toasts.value.push({ id, message, type });
                        setTimeout(() => {
                            toasts.value = toasts.value.filter(t => t.id !== id);
                        }, 3000);
                    }

                    // API calls
                    async function apiCall(url, options = {}) {
                        try {
                            const response = await fetch(url, {
                                ...options,
                                headers: {
                                    'Content-Type': 'application/json',
                                    ...options.headers,
                                },
                            });
                            const data = await response.json();
                            if (!response.ok) {
                                throw new Error(data.detail || 'API Error');
                            }
                            return data;
                        } catch (error) {
                            showToast(error.message, 'error');
                            throw error;
                        }
                    }

                    // WebSocket connection
                    function connectWebSocket() {
                        try {
                            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                            const wsUrl = `${protocol}//${window.location.host}/ws`;
                            ws = new WebSocket(wsUrl);

                            ws.onopen = () => {
                                wsConnected.value = true;
                                console.log('WebSocket connected');
                            };

                            ws.onclose = () => {
                                wsConnected.value = false;
                                console.log('WebSocket disconnected');
                                reconnectTimer = setTimeout(connectWebSocket, 3000);
                            };

                            ws.onmessage = (event) => {
                                try {
                                    const data = JSON.parse(event.data);
                                    handleWebSocketMessage(data);
                                } catch (e) {
                                    console.error('WebSocket message error:', e);
                                }
                            };

                            ws.onerror = (error) => {
                                console.error('WebSocket error:', error);
                            };
                        } catch (e) {
                            console.error('WebSocket connection error:', e);
                        }
                    }

                    function handleWebSocketMessage(data) {
                        switch (data.type) {
                            case 'init':
                                if (data.task_status) {
                                    taskRunning.value = data.task_status.running;
                                    if (data.task_status.task) {
                                        taskProgress.value = data.task_status.task.progress || 0;
                                    }
                                }
                                break;
                            case 'task_log':
                                // 1. Run Task Page Logs (taskLogs) - Only for manual tasks
                                if (!data.task_type || data.task_type === 'manual') {
                                    taskLogs.value.push({
                                        time: new Date().toLocaleTimeString(),
                                        message: data.message,
                                    });
                                }

                                // 2. Scheduler Page: Don't add real-time logs here
                                // schedulerLogs is populated from API (summary per execution cycle)
                                // Real-time logs for scheduled tasks are not displayed in scheduler page

                                // 3. Chat Page Logs (chatMessages)
                                if (chatMessages.value.length > 0) {
                                    // æ‰¾åˆ°åŒ¹é…taskIdçš„æ¶ˆæ¯ï¼Œæˆ–è€…æœ€åä¸€æ¡runningçŠ¶æ€çš„assistantæ¶ˆæ¯
                                    // å¯¹äºå¤æ‚ä»»åŠ¡ï¼Œä¹Ÿæ¥å—æœ‰todoListçš„æ¶ˆæ¯
                                    let targetMsg = null;
                                    for (let i = chatMessages.value.length - 1; i >= 0; i--) {
                                        const msg = chatMessages.value[i];
                                        if (msg.role === 'assistant') {
                                            // å¦‚æœæ¶ˆæ¯æ­£åœ¨è¿è¡Œï¼Œæˆ–è€…æ˜¯æœ‰todoListçš„å¤æ‚ä»»åŠ¡ï¼ˆæ­£åœ¨æ‰§è¡Œä¸­ï¼‰
                                            const isRunning = msg.status === 'running';
                                            const isComplexTaskRunning = msg.todoList && msg.todoList.length > 0 &&
                                                msg.todoList.some(t => t.status === 'running' || t.status === 'pending');

                                            if (isRunning || isComplexTaskRunning) {
                                                // å¦‚æœæœ‰taskIdåˆ™å¿…é¡»åŒ¹é…ï¼Œå¦åˆ™ä½¿ç”¨æœ€åä¸€æ¡
                                                if (data.task_id && msg.taskId && msg.taskId !== data.task_id) {
                                                    continue;  // taskIdä¸åŒ¹é…ï¼Œè·³è¿‡
                                                }
                                                targetMsg = msg;
                                                break;
                                            }
                                        }
                                    }

                                    if (targetMsg) {
                                        // ä½¿ç”¨æ•°ç»„æ‰©å±•è¿ç®—ç¬¦å¼ºåˆ¶è§¦å‘ Vue æ›´æ–° (Reactivity)
                                        const newLogs = targetMsg.logs ? [...targetMsg.logs, data.message] : [data.message];
                                        targetMsg.logs = newLogs;

                                        // å¤æ‚ä»»åŠ¡æ¨¡å¼ï¼šå°†æ—¥å¿—ä¹Ÿæ·»åŠ åˆ°å½“å‰æ‰§è¡Œçš„å­ä»»åŠ¡
                                        // ä¸æ£€æŸ¥å­ä»»åŠ¡çŠ¶æ€ï¼Œå› ä¸ºæ—¥å¿—å¯èƒ½åœ¨çŠ¶æ€å˜æ›´åæ‰åˆ°è¾¾
                                        if (targetMsg.todoList && targetMsg.currentTodoIndex !== undefined && targetMsg.currentTodoIndex >= 0) {
                                            const currentTodo = targetMsg.todoList[targetMsg.currentTodoIndex];
                                            if (currentTodo) {
                                                const subNewLogs = currentTodo.logs ? [...currentTodo.logs, data.message] : [data.message];
                                                currentTodo.logs = subNewLogs;
                                            }
                                        }

                                        scrollChatToBottom();
                                    }
                                }
                                break;
                            case 'task_progress':
                                taskProgress.value = data.progress;
                                break;
                            case 'task_finished':
                                taskRunning.value = false;
                                // æ£€æŸ¥æœ€åä¸€æ¡æ¶ˆæ¯æ˜¯å¦æ˜¯å¤æ‚ä»»åŠ¡ï¼ˆæœ‰ todoListï¼‰
                                const lastMsgForToast = chatMessages.value.length > 0 ? chatMessages.value[chatMessages.value.length - 1] : null;
                                const isComplexTask = lastMsgForToast && lastMsgForToast.todoList && lastMsgForToast.todoList.length > 0;

                                if (isComplexTask) {
                                    // å¤æ‚ä»»åŠ¡å­ä»»åŠ¡å®Œæˆï¼Œæ˜¾ç¤ºç®€çŸ­æç¤º
                                    const currentIdx = lastMsgForToast.currentTodoIndex;
                                    if (currentIdx !== undefined && currentIdx >= 0 && currentIdx < lastMsgForToast.todoList.length) {
                                        showToast(`å­ä»»åŠ¡ ${currentIdx + 1}/${lastMsgForToast.todoList.length} ${data.success ? 'å®Œæˆ' : 'å¤±è´¥'}`, data.success ? 'success' : 'error');
                                    }
                                } else {
                                    // æ™®é€šä»»åŠ¡ï¼Œæ˜¾ç¤ºå®Œæ•´æç¤º
                                    showToast(data.message, data.success ? 'success' : 'error');
                                }
                                // Update chat message status and use screenshot from WebSocket
                                // å¤æ‚ä»»åŠ¡æ¨¡å¼ä¸‹ï¼ˆæ¶ˆæ¯æœ‰todoListï¼‰ï¼Œä¸è¦åœ¨è¿™é‡Œä¿®æ”¹çŠ¶æ€ï¼Œè®©å¾ªç¯è‡ªå·±æ§åˆ¶
                                // æ™®é€šä»»åŠ¡ï¼ˆæ¶ˆæ¯æ²¡æœ‰todoListï¼‰æ‰åœ¨è¿™é‡Œæ›´æ–°çŠ¶æ€
                                if (chatRunning.value && chatMessages.value.length > 0 && !isComplexTask) {
                                    const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                                    if (lastMsg.role === 'assistant' && lastMsg.status === 'running') {
                                        lastMsg.status = data.success ? 'success' : 'error';
                                        // æ˜¾ç¤ºå…·ä½“çš„é”™è¯¯ä¿¡æ¯
                                        if (data.success) {
                                            lastMsg.content = 'âœ… ä»»åŠ¡æ‰§è¡Œå®Œæˆï¼';
                                        } else {
                                            // æå–å¹¶æ ¼å¼åŒ–é”™è¯¯ä¿¡æ¯
                                            let errorMsg = data.message || 'ä»»åŠ¡æ‰§è¡Œå¤±è´¥';
                                            if (errorMsg.includes('Token error') || errorMsg.includes('limited')) {
                                                errorMsg = 'âŒ ' + errorMsg + '\n\nğŸ’¡ æç¤ºï¼šæ¨¡å‹æœåŠ¡è¢«é™æµï¼Œè¯·ç¨åå†è¯•ã€‚';
                                            } else if (errorMsg.includes('Task failed:')) {
                                                errorMsg = 'âŒ ' + errorMsg.replace('Task failed:', 'ä»»åŠ¡å¤±è´¥:');
                                            } else {
                                                errorMsg = 'âŒ ä»»åŠ¡æ‰§è¡Œå¤±è´¥: ' + errorMsg;
                                            }
                                            lastMsg.content = errorMsg;
                                        }
                                        // ä½¿ç”¨ screenshot_id ä»æ•°æ®åº“åŠ è½½æˆªå›¾ï¼Œä¸å†ä½¿ç”¨ base64
                                        if (data.screenshot_id && currentSessionId.value && lastMsg.id) {
                                            // ç«‹å³æ›´æ–°æ¶ˆæ¯çš„ screenshots æ•°ç»„ï¼Œä½¿ç”¨ screenshot_id æ„å»º image_url
                                            if (!lastMsg.screenshots) {
                                                lastMsg.screenshots = [];
                                            }
                                            // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨è¿™ä¸ªæˆªå›¾ï¼Œé¿å…é‡å¤æ·»åŠ 
                                            const exists = lastMsg.screenshots.some(s => s.id === data.screenshot_id);
                                            if (!exists) {
                                                lastMsg.screenshots.push({
                                                    id: data.screenshot_id,
                                                    image_url: `/api/chat/screenshots/${data.screenshot_id}`
                                                });
                                            }
                                        }
                                    }
                                    chatRunning.value = false;
                                    // Save session after task completes
                                    saveCurrentSession();
                                }
                                // Refresh scheduler logs when a scheduled task finishes
                                if (data.task_type === 'scheduled') {
                                    loadSchedulerLogs();
                                }
                                break;
                            case 'task_tokens':
                                // Update chat message tokens
                                if (chatMessages.value.length > 0) {
                                    // Find target message
                                    let targetMsg = null;
                                    for (let i = chatMessages.value.length - 1; i >= 0; i--) {
                                        const msg = chatMessages.value[i];
                                        if (msg.role === 'assistant') {
                                            const isRunning = msg.status === 'running';
                                            const isComplexTaskRunning = msg.todoList && msg.todoList.length > 0 &&
                                                msg.todoList.some(t => t.status === 'running' || t.status === 'pending');

                                            if (isRunning || isComplexTaskRunning) {
                                                if (data.task_id && msg.taskId && msg.taskId !== data.task_id) {
                                                    continue;
                                                }
                                                targetMsg = msg;
                                                break;
                                            }
                                        }
                                    }

                                    if (targetMsg) {
                                        if (!targetMsg.tokens) targetMsg.tokens = 0;
                                        // ç´¯åŠ  token (å› ä¸ºæ˜¯ä¸€æ¬¡æ¬¡æ¨è¿‡æ¥çš„)
                                        targetMsg.tokens += data.total_tokens;
                                    }
                                }
                                break;
                            case 'devices':
                                devices.value = data.devices;
                                break;
                            case 'ping':
                                if (ws && ws.readyState === WebSocket.OPEN) {
                                    ws.send(JSON.stringify({ type: 'pong' }));
                                }
                                break;
                        }
                    }

                    // Device functions

                    // Chat Session Management Functions
                    function loadSessions() {
                        try {
                            const stored = localStorage.getItem(SESSIONS_STORAGE_KEY);
                            if (stored) {
                                chatSessions.value = JSON.parse(stored);
                                // Sort by updatedAt descending
                                chatSessions.value.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                            }
                        } catch (e) {
                            console.error('Failed to load sessions:', e);
                            chatSessions.value = [];
                        }
                    }

                    function saveSessions() {
                        try {
                            // Deep copy sessions to avoid modifying reactive state
                            const sessionsToSave = JSON.parse(JSON.stringify(chatSessions.value));

                            // Remove heavy data (screenshots metadata and large logs) from saved sessions
                            sessionsToSave.forEach(session => {
                                if (session.messages) {
                                    session.messages.forEach(msg => {
                                        // Remove screenshot base64 (if any legacy data exists)
                                        if (msg.screenshot) {
                                            msg.screenshot = null;
                                        }
                                        // Screenshots are stored in database, only keep minimal metadata
                                        // Limit logs size
                                        if (msg.logs && msg.logs.length > 50) {
                                            msg.logs = msg.logs.slice(-50); // Keep only last 50 logs
                                        }
                                        // Clean subtask logs too
                                        if (msg.todoList) {
                                            msg.todoList.forEach(todo => {
                                                if (todo.logs && todo.logs.length > 20) {
                                                    todo.logs = todo.logs.slice(-20);
                                                }
                                            });
                                        }
                                    });
                                }
                            });

                            localStorage.setItem(SESSIONS_STORAGE_KEY, JSON.stringify(sessionsToSave));
                        } catch (e) {
                            console.error('Failed to save sessions:', e);
                            // Fallback: try to save only the current session if full save fails
                            if (e.name === 'QuotaExceededError') {
                                try {
                                    // Try to clean up old sessions
                                    const currentSession = sessionsToSave.find(s => s.id === currentSessionId.value);
                                    if (currentSession) {
                                        localStorage.setItem(SESSIONS_STORAGE_KEY, JSON.stringify([currentSession]));
                                        showToast('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œå·²æ¸…ç†æ—§ä¼šè¯', 'warning');
                                    }
                                } catch (retryError) {
                                    showToast('å­˜å‚¨ç©ºé—´å·²æ»¡ï¼Œæ— æ³•ä¿å­˜ä¼šè¯', 'error');
                                }
                            }
                        }
                    }

                    function saveCurrentSession() {
                        if (!currentSessionId.value) return;

                        const session = chatSessions.value.find(s => s.id === currentSessionId.value);
                        if (session) {
                            session.messages = chatMessages.value;
                            // ä¼šè¯æ—¶é—´ä»¥æœ€æ–°æ¶ˆæ¯æ—¶é—´ä¸ºå‡†
                            if (chatMessages.value.length > 0) {
                                const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                                if (lastMsg.timestamp) {
                                    session.updatedAt = lastMsg.timestamp;
                                }
                            }
                            // Update title from first user message if not set
                            if (!session.title || session.title === 'æ–°ä¼šè¯') {
                                const firstUserMsg = chatMessages.value.find(m => m.role === 'user');
                                if (firstUserMsg) {
                                    session.title = firstUserMsg.content.substring(0, 30) + (firstUserMsg.content.length > 30 ? '...' : '');
                                }
                            }
                            saveSessions();

                            // åŒæ­¥ assistant æ¶ˆæ¯çš„ status å’Œ todoList åˆ°æœåŠ¡å™¨æ•°æ®åº“
                            saveMessageStatusToServer();
                        }
                    }

                    // ä¿å­˜æ¶ˆæ¯çŠ¶æ€åˆ°æœåŠ¡å™¨ï¼ˆéé˜»å¡ï¼Œä¸å½±å“æœ¬åœ°æ“ä½œï¼‰
                    async function saveMessageStatusToServer() {
                        if (!currentSessionId.value) return;

                        // æ‰¾å‡ºéœ€è¦ä¿å­˜çŠ¶æ€çš„ assistant æ¶ˆæ¯
                        for (const msg of chatMessages.value) {
                            if (msg.role === 'assistant' && msg.id && (msg.status || msg.todoList)) {
                                try {
                                    await apiCall(`/api/chat/sessions/${currentSessionId.value}/messages/${msg.id}`, {
                                        method: 'PATCH',
                                        body: JSON.stringify({
                                            status: msg.status || null,
                                            content: msg.content || null,
                                            todo_list: msg.todoList || null
                                        })
                                    });
                                } catch (error) {
                                    // é™é»˜å¤±è´¥ï¼Œä¸å½±å“ç”¨æˆ·ä½“éªŒ
                                    console.debug('Failed to save message status to server:', error);
                                }
                            }
                        }
                    }

                    async function createNewSession() {
                        // Save current session first
                        saveCurrentSession();

                        // å°è¯•ä»æœåŠ¡å™¨åˆ›å»ºä¼šè¯ï¼Œç¡®ä¿ ID åŒæ­¥
                        try {
                            const deviceId = chatDeviceId.value || 'default';
                            const serverSession = await apiCall('/api/chat/sessions', {
                                method: 'POST',
                                body: JSON.stringify({
                                    device_id: deviceId,
                                    title: 'æ–°ä¼šè¯'
                                })
                            });

                            const newSession = {
                                id: serverSession.id,
                                title: serverSession.title || 'æ–°ä¼šè¯',
                                deviceId: serverSession.device_id,
                                messages: [],
                                createdAt: serverSession.created_at,
                                updatedAt: serverSession.updated_at
                            };
                            chatSessions.value.unshift(newSession);
                            currentSessionId.value = newSession.id;
                            chatMessages.value = [];
                            saveSessions();
                        } catch (error) {
                            console.error('Failed to create session on server:', error);
                            // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨æœ¬åœ° ID
                            const newSession = {
                                id: Date.now().toString(),
                                title: 'æ–°ä¼šè¯',
                                messages: [],
                                createdAt: new Date().toISOString(),
                                updatedAt: new Date().toISOString()
                            };
                            chatSessions.value.unshift(newSession);
                            currentSessionId.value = newSession.id;
                            chatMessages.value = [];
                            saveSessions();
                        }
                    }

                    async function switchSession(sessionId) {
                        if (sessionId === currentSessionId.value) return;

                        // Save current session first
                        saveCurrentSession();

                        const session = chatSessions.value.find(s => s.id === sessionId);
                        if (session) {
                            currentSessionId.value = session.id;
                            chatMessages.value = session.messages || [];

                            // å°è¯•ä»æœåŠ¡å™¨åŠ è½½å®Œæ•´çš„æ¶ˆæ¯æ•°æ®ï¼ˆåŒ…æ‹¬ screenshotsï¼‰
                            // è¿™æ ·å¯ä»¥ç¡®ä¿æœåŠ¡é‡å¯åä¹Ÿèƒ½çœ‹åˆ°æˆªå›¾
                            try {
                                const detailData = await apiCall(`/api/chat/sessions/${sessionId}/detail`);
                                if (detailData && detailData.messages) {
                                    // æ›´æ–°æ¶ˆæ¯æ•°æ®ï¼Œç‰¹åˆ«æ˜¯ screenshots
                                    detailData.messages.forEach(serverMsg => {
                                        const localMsg = chatMessages.value.find(m => m.id === serverMsg.id);
                                        if (localMsg && serverMsg.screenshots && serverMsg.screenshots.length > 0) {
                                            localMsg.screenshots = serverMsg.screenshots;
                                        }
                                    });
                                }
                            } catch (error) {
                                // å¦‚æœä¼šè¯ä¸å­˜åœ¨ï¼ˆ404ï¼‰ï¼Œä»åˆ—è¡¨ä¸­ç§»é™¤
                                if (error.message && error.message.includes('Session not found')) {
                                    console.warn(`Session ${sessionId} not found, removing from list`);
                                    const index = chatSessions.value.findIndex(s => s.id === sessionId);
                                    if (index !== -1) {
                                        chatSessions.value.splice(index, 1);
                                        saveSessions();

                                        // å¦‚æœæœ‰å…¶ä»–ä¼šè¯ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªï¼Œå¦åˆ™åˆ›å»ºæ–°ä¼šè¯
                                        if (chatSessions.value.length > 0) {
                                            await switchSession(chatSessions.value[0].id);
                                            return;
                                        } else {
                                            createNewSession();
                                            return;
                                        }
                                    }
                                } else {
                                    console.error('Failed to load session detail from server:', error);
                                    // å…¶ä»–é”™è¯¯ç»§ç»­ä½¿ç”¨æœ¬åœ°æ•°æ®
                                }
                            }

                            // ä½¿ç”¨ nextTick ç¡®ä¿ DOM æ›´æ–°åå†æ»šåŠ¨
                            Vue.nextTick(() => {
                                scrollChatToBottom();
                            });
                        }
                    }

                    async function deleteSession(sessionId) {
                        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä¼šè¯å—ï¼Ÿ')) return;

                        // ä»æœåŠ¡å™¨åˆ é™¤ä¼šè¯
                        try {
                            await apiCall(`/api/chat/sessions/${sessionId}`, { method: 'DELETE' });
                        } catch (error) {
                            console.error('Failed to delete session from server:', error);
                            // ç»§ç»­åˆ é™¤æœ¬åœ°ä¼šè¯ï¼Œå³ä½¿æœåŠ¡å™¨åˆ é™¤å¤±è´¥
                        }

                        // ä»æœ¬åœ°åˆ é™¤ä¼šè¯
                        const index = chatSessions.value.findIndex(s => s.id === sessionId);
                        if (index !== -1) {
                            chatSessions.value.splice(index, 1);
                            saveSessions();

                            // If deleted current session, switch to another or create new
                            if (sessionId === currentSessionId.value) {
                                if (chatSessions.value.length > 0) {
                                    await switchSession(chatSessions.value[0].id);
                                } else {
                                    await createNewSession();
                                }
                            }
                        }
                    }

                    function formatSessionTime(isoString) {
                        if (!isoString) return '';
                        const date = new Date(isoString);
                        const now = new Date();
                        const diffMs = now - date;
                        const diffMins = Math.floor(diffMs / 60000);
                        const diffHours = Math.floor(diffMs / 3600000);
                        const diffDays = Math.floor(diffMs / 86400000);

                        if (diffMins < 1) return 'åˆšåˆš';
                        if (diffMins < 60) return `${diffMins}åˆ†é’Ÿå‰`;
                        if (diffHours < 24) return `${diffHours}å°æ—¶å‰`;
                        if (diffDays < 7) return `${diffDays}å¤©å‰`;
                        return date.toLocaleDateString();
                    }

                    function formatMsgTime(timestamp) {
                        if (!timestamp) return '';
                        const date = new Date(timestamp);
                        return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                    }

                    async function initChatSessions() {
                        // å…ˆä»æœåŠ¡å™¨åŠ è½½ä¼šè¯åˆ—è¡¨ï¼Œç¡®ä¿æ•°æ®åŒæ­¥
                        try {
                            const serverSessions = await apiCall('/api/chat/sessions?limit=50');
                            if (serverSessions && serverSessions.length > 0) {
                                // å°†æœåŠ¡å™¨ä¼šè¯è½¬æ¢ä¸ºå‰ç«¯æ ¼å¼
                                const serverSessionsFormatted = serverSessions.map(s => ({
                                    id: s.id,
                                    title: s.title || 'æ–°ä¼šè¯',
                                    deviceId: s.device_id,
                                    status: s.status,
                                    updatedAt: s.updated_at,
                                    totalTokens: s.total_tokens || 0,
                                    messages: []  // æ¶ˆæ¯ç¨ååŠ è½½
                                }));

                                // åˆå¹¶æœåŠ¡å™¨ä¼šè¯å’Œæœ¬åœ°ä¼šè¯ï¼ˆä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨æ•°æ®ï¼‰
                                const localSessions = [];
                                try {
                                    const stored = localStorage.getItem(SESSIONS_STORAGE_KEY);
                                    if (stored) {
                                        localSessions.push(...JSON.parse(stored));
                                    }
                                } catch (e) {
                                    console.warn('Failed to load local sessions:', e);
                                }

                                // åˆå¹¶ï¼šæœåŠ¡å™¨ä¼šè¯ä¼˜å…ˆï¼Œä½†ä¿ç•™æœ¬åœ°ä¼šè¯çš„æ¶ˆæ¯æ•°æ®ï¼ˆå¦‚æœæœåŠ¡å™¨ä¼šè¯å­˜åœ¨ï¼‰
                                const mergedSessions = [];
                                const serverSessionIds = new Set(serverSessionsFormatted.map(s => s.id));

                                // å…ˆæ·»åŠ æœåŠ¡å™¨ä¼šè¯
                                for (const serverSession of serverSessionsFormatted) {
                                    const localSession = localSessions.find(s => s.id === serverSession.id);
                                    if (localSession && localSession.messages) {
                                        // ä¿ç•™æœ¬åœ°æ¶ˆæ¯æ•°æ®
                                        serverSession.messages = localSession.messages;
                                    }
                                    mergedSessions.push(serverSession);
                                }

                                // æ·»åŠ æœ¬åœ°å­˜åœ¨ä½†æœåŠ¡å™¨ä¸å­˜åœ¨çš„ä¼šè¯ï¼ˆå¯èƒ½æ˜¯æœªåŒæ­¥çš„ï¼‰
                                for (const localSession of localSessions) {
                                    if (!serverSessionIds.has(localSession.id)) {
                                        mergedSessions.push(localSession);
                                    }
                                }

                                // æŒ‰æ›´æ–°æ—¶é—´æ’åº
                                mergedSessions.sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
                                chatSessions.value = mergedSessions;
                                saveSessions();
                            } else {
                                // æœåŠ¡å™¨æ²¡æœ‰ä¼šè¯ï¼Œä½¿ç”¨æœ¬åœ°ä¼šè¯
                                loadSessions();
                            }
                        } catch (error) {
                            console.error('Failed to load sessions from server:', error);
                            // æœåŠ¡å™¨åŠ è½½å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°ä¼šè¯
                            loadSessions();
                        }

                        // Auto-enter most recent session or create new one
                        if (chatSessions.value.length > 0) {
                            const mostRecent = chatSessions.value[0];
                            currentSessionId.value = mostRecent.id;

                            // å¦‚æœæœ¬åœ°æœ‰æ¶ˆæ¯æ•°æ®ï¼Œå…ˆä½¿ç”¨æœ¬åœ°æ•°æ®
                            if (mostRecent.messages && mostRecent.messages.length > 0) {
                                chatMessages.value = mostRecent.messages;
                            } else {
                                chatMessages.value = [];
                            }

                            // å°è¯•ä»æœåŠ¡å™¨åŠ è½½å®Œæ•´çš„æ¶ˆæ¯æ•°æ®ï¼ˆåŒ…æ‹¬ screenshotsï¼‰
                            // è¿™æ ·å¯ä»¥ç¡®ä¿æœåŠ¡é‡å¯åä¹Ÿèƒ½çœ‹åˆ°æˆªå›¾
                            try {
                                // åœ¨åŠ è½½æœåŠ¡å™¨æ•°æ®å‰ï¼Œå…ˆä¿å­˜æœ¬åœ°æ¶ˆæ¯çš„çŠ¶æ€å’Œ todoListï¼ˆæœåŠ¡å™¨ä¸ä¿å­˜è¿™äº›å­—æ®µï¼‰
                                const localDataMap = {};
                                if (chatMessages.value && chatMessages.value.length > 0) {
                                    chatMessages.value.forEach(msg => {
                                        if (msg.id) {
                                            localDataMap[msg.id] = {
                                                status: msg.status,
                                                todoList: msg.todoList,
                                                currentTodoIndex: msg.currentTodoIndex,
                                                logs: msg.logs || []  // ä¹Ÿä¿å­˜æœ¬åœ°æ—¥å¿—ä½œä¸ºåå¤‡
                                            };
                                        }
                                    });
                                }

                                const detailData = await apiCall(`/api/chat/sessions/${mostRecent.id}/detail`);
                                if (detailData && detailData.messages) {
                                    // ä½¿ç”¨æœåŠ¡å™¨çš„æ¶ˆæ¯æ•°æ®ï¼ˆæ›´å®Œæ•´ï¼ŒåŒ…å« screenshotsï¼‰
                                    chatMessages.value = detailData.messages.map(msg => {
                                        const localData = localDataMap[msg.id] || {};
                                        // ä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨çŠ¶æ€ï¼Œå…¶æ¬¡ä½¿ç”¨æœ¬åœ°ä¿å­˜çš„çŠ¶æ€ï¼Œæœ€åé»˜è®¤ success
                                        let status = null;
                                        let todoList = null;
                                        if (msg.role === 'assistant') {
                                            // æœåŠ¡å™¨ç°åœ¨å¯èƒ½è¿”å› status å’Œ todo_list
                                            status = msg.status || localData.status || 'success';
                                            // todo_list ä»æœåŠ¡å™¨è¿”å›ï¼ˆå¦‚æœæœ‰ï¼‰ï¼Œå¦åˆ™ä½¿ç”¨æœ¬åœ°
                                            todoList = msg.todo_list || localData.todoList || null;
                                        }

                                        // æ—¥å¿—ï¼šä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨æ—¥å¿—ï¼ˆæ›´å®Œæ•´ï¼‰ï¼Œå¦‚æœæœåŠ¡å™¨æ²¡æœ‰åˆ™ç”¨æœ¬åœ°
                                        let logs = [];
                                        if (msg.logs && msg.logs.length > 0) {
                                            logs = msg.logs.map(l => l.content || l);
                                        } else if (localData.logs && localData.logs.length > 0) {
                                            logs = localData.logs;
                                        }

                                        return {
                                            id: msg.id,
                                            role: msg.role,
                                            content: msg.content,
                                            timestamp: msg.created_at,
                                            logs: logs,
                                            screenshots: msg.screenshots || [],
                                            status: status,
                                            // ä¼˜å…ˆä½¿ç”¨æœåŠ¡å™¨çš„ todoListï¼Œå…¶æ¬¡æ˜¯æœ¬åœ°æ•°æ®
                                            todoList: todoList,
                                            currentTodoIndex: localData.currentTodoIndex
                                        };
                                    });

                                    // æ›´æ–°ä¼šè¯ä¸­çš„æ¶ˆæ¯æ•°æ®
                                    mostRecent.messages = chatMessages.value;
                                    saveSessions();
                                }
                            } catch (error) {
                                // å¦‚æœä¼šè¯ä¸å­˜åœ¨ï¼ˆ404ï¼‰ï¼Œä»åˆ—è¡¨ä¸­ç§»é™¤
                                if (error.message && error.message.includes('Session not found')) {
                                    console.warn(`Session ${mostRecent.id} not found, removing from list`);
                                    const index = chatSessions.value.findIndex(s => s.id === mostRecent.id);
                                    if (index !== -1) {
                                        chatSessions.value.splice(index, 1);
                                        saveSessions();

                                        // å¦‚æœæœ‰å…¶ä»–ä¼šè¯ï¼Œåˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ª
                                        if (chatSessions.value.length > 0) {
                                            await switchSession(chatSessions.value[0].id);
                                            return;
                                        } else {
                                            createNewSession();
                                            return;
                                        }
                                    }
                                } else {
                                    console.error('Failed to load session detail from server:', error);
                                    // ç»§ç»­ä½¿ç”¨æœ¬åœ°æ•°æ®
                                }
                            }

                            // ä¿®å¤åˆ·æ–°å running çŠ¶æ€çš„æ¶ˆæ¯ï¼šå…ˆæ£€æŸ¥æœåŠ¡å™¨ä»»åŠ¡çŠ¶æ€
                            // å¦‚æœä»»åŠ¡ç¡®å®è¿˜åœ¨è¿è¡Œï¼Œä¿æŒ running çŠ¶æ€ï¼›å¦åˆ™æ”¹ä¸ºå·²å®ŒæˆçŠ¶æ€
                            try {
                                const taskStatus = await apiCall('/api/tasks/status');
                                const isServerTaskRunning = taskStatus && taskStatus.running;

                                chatMessages.value.forEach(msg => {
                                    if (msg.role === 'assistant' && msg.status === 'running') {
                                        if (isServerTaskRunning) {
                                            // æœåŠ¡å™¨ä»»åŠ¡è¿˜åœ¨è¿è¡Œï¼Œä¿æŒ running çŠ¶æ€
                                            // æ¢å¤ chatRunning çŠ¶æ€ä»¥ä¾¿ç»§ç»­æ¥æ”¶æ—¥å¿—æ›´æ–°
                                            chatRunning.value = true;
                                            console.log('[åˆ·æ–°æ¢å¤] æ£€æµ‹åˆ°ä»»åŠ¡ä»åœ¨è¿è¡Œï¼Œä¿æŒ running çŠ¶æ€');
                                        } else {
                                            // æœåŠ¡å™¨ä»»åŠ¡å·²ç»“æŸï¼Œå°†çŠ¶æ€æ”¹ä¸ºå·²å®Œæˆ
                                            msg.status = 'success';
                                            msg.content = msg.content || 'ä»»åŠ¡æ‰§è¡Œå®Œæˆï¼';
                                        }
                                    }

                                    // ä¿®å¤ todoList å­ä»»åŠ¡çš„è¿‡æœŸ running/pending çŠ¶æ€
                                    if (msg.todoList && msg.todoList.length > 0 && !isServerTaskRunning) {
                                        msg.todoList.forEach(todo => {
                                            if (todo.status === 'running' || todo.status === 'pending') {
                                                todo.status = 'failed';
                                                console.log('[åˆ·æ–°æ¢å¤] å°†è¿‡æœŸçš„å­ä»»åŠ¡çŠ¶æ€æ”¹ä¸º failed:', todo.content);
                                            }
                                        });
                                    }
                                });
                            } catch (statusError) {
                                console.error('Failed to check task status:', statusError);
                                // æ£€æŸ¥å¤±è´¥æ—¶ï¼Œä¿å®ˆå¤„ç†ï¼šå‡è®¾ä»»åŠ¡å·²å®Œæˆ
                                chatMessages.value.forEach(msg => {
                                    if (msg.role === 'assistant' && msg.status === 'running') {
                                        msg.status = 'success';
                                        msg.content = msg.content || 'ä»»åŠ¡æ‰§è¡Œå®Œæˆï¼';
                                    }
                                    // åŒæ ·ä¿®å¤ todoList å­ä»»åŠ¡çŠ¶æ€
                                    if (msg.todoList && msg.todoList.length > 0) {
                                        msg.todoList.forEach(todo => {
                                            if (todo.status === 'running' || todo.status === 'pending') {
                                                todo.status = 'failed';
                                            }
                                        });
                                    }
                                });
                            }
                            // ä¿å­˜ä¿®å¤åçš„çŠ¶æ€
                            saveCurrentSession();
                            // é¡µé¢åŠ è½½åè‡ªåŠ¨æ»šåŠ¨åˆ°æœ€æ–°æ¶ˆæ¯
                            Vue.nextTick(() => {
                                scrollChatToBottom();
                            });
                        } else {
                            createNewSession();
                        }
                    }

                    // Chat functions
                    function scrollChatToBottom() {
                        setTimeout(() => {
                            if (chatMessagesRef.value) {
                                chatMessagesRef.value.scrollTop = chatMessagesRef.value.scrollHeight;
                            }
                        }, 50);
                    }

                    function onChatDeviceChange() {
                        // Auto-select device for preview too
                        if (chatDeviceId.value && !previewDeviceId.value) {
                            previewDeviceId.value = chatDeviceId.value;
                        }
                    }

                    function adjustChatInputHeight(e) {
                        const el = e.target;
                        el.style.height = 'auto';
                        el.style.height = Math.min(el.scrollHeight, 100) + 'px';
                    }

                    // ç›‘å¬è¾“å…¥å†…å®¹å˜åŒ–ï¼Œè‡ªåŠ¨è°ƒæ•´é«˜åº¦
                    watch(chatInput, () => {
                        nextTick(() => {
                            const el = document.querySelector('.chat-input');
                            if (el) {
                                el.style.height = 'auto';
                                // å¦‚æœå†…å®¹ä¸ºç©ºï¼Œé‡ç½®ä¸ºåˆå§‹é«˜åº¦ï¼ˆé€šè¿‡ rows å±æ€§æ§åˆ¶ï¼‰
                                if (!chatInput.value) {
                                    el.style.height = '';
                                } else {
                                    el.style.height = Math.min(el.scrollHeight, 100) + 'px';
                                }
                            }
                        });
                    });

                    // Retry a previous message
                    function retryMessage(content) {
                        if (chatRunning.value) return;
                        chatInput.value = content;
                        sendChatMessage();
                    }

                    const isSkipping = ref(false);

                    async function skipSubtask(msg) {
                        if (!chatRunning.value) return;
                        if (confirm('ç¡®å®šè¦è·³è¿‡å½“å‰å­ä»»åŠ¡å—ï¼Ÿ(å°†åœæ­¢å½“å‰æ“ä½œå¹¶è¿›å…¥ä¸‹ä¸€æ­¥)')) {
                            isSkipping.value = true;
                            // å¼ºåˆ¶åœæ­¢å½“å‰ä»»åŠ¡
                            await apiCall('/api/tasks/stop', { method: 'POST' });
                        }
                    }

                    async function sendChatMessage() {
                        const content = chatInput.value.trim();
                        if (!content || !chatDeviceId.value || chatRunning.value) return;

                        // ç¡®ä¿æœ‰ä¼šè¯å­˜åœ¨ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»º
                        if (!currentSessionId.value) {
                            await createNewSession();
                        }

                        // åŒæ­¥ä¼šè¯åˆ°æœåŠ¡å™¨ï¼ˆå¦‚æœä¼šè¯IDæ˜¯æœ¬åœ°ç”Ÿæˆçš„ï¼Œéœ€è¦åœ¨æœåŠ¡å™¨åˆ›å»ºï¼‰
                        let serverSessionId = currentSessionId.value;
                        let serverMessageId = null;

                        // å°è¯•å°†æ¶ˆæ¯ä¿å­˜åˆ°æœåŠ¡å™¨
                        try {
                            // æ£€æŸ¥ä¼šè¯æ˜¯å¦å­˜åœ¨äºæœåŠ¡å™¨
                            const sessionCheck = await apiCall(`/api/chat/sessions/${currentSessionId.value}`).catch(() => null);

                            if (!sessionCheck) {
                                // ä¼šè¯ä¸å­˜åœ¨ï¼Œåœ¨æœåŠ¡å™¨åˆ›å»º
                                const newSession = await apiCall('/api/chat/sessions', {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        device_id: chatDeviceId.value,
                                        title: content.substring(0, 30) + (content.length > 30 ? '...' : '')
                                    })
                                });
                                serverSessionId = newSession.id;

                                // æ›´æ–°æœ¬åœ°ä¼šè¯ID
                                const oldSessionId = currentSessionId.value;
                                currentSessionId.value = serverSessionId;
                                const localSession = chatSessions.value.find(s => s.id === oldSessionId);
                                if (localSession) {
                                    localSession.id = serverSessionId;
                                }
                                saveSessions();
                            }

                            // åœ¨æœåŠ¡å™¨æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
                            const userMsgResult = await apiCall(`/api/chat/sessions/${serverSessionId}/messages`, {
                                method: 'POST',
                                body: JSON.stringify({
                                    role: 'user',
                                    content: content
                                })
                            });

                            // åœ¨æœåŠ¡å™¨æ·»åŠ åŠ©æ‰‹æ¶ˆæ¯å ä½ç¬¦
                            const assistantMsgResult = await apiCall(`/api/chat/sessions/${serverSessionId}/messages`, {
                                method: 'POST',
                                body: JSON.stringify({
                                    role: 'assistant',
                                    content: 'æ‰§è¡Œä¸­...'
                                })
                            });
                            serverMessageId = assistantMsgResult.id;
                        } catch (error) {
                            console.error('Failed to sync messages to server:', error);
                            // ç»§ç»­æ‰§è¡Œï¼Œä½†æ— æ³•ä¿å­˜æˆªå›¾åˆ°æ•°æ®åº“
                        }

                        // Add user message to local state
                        chatMessages.value.push({
                            role: 'user',
                            content: content,
                            timestamp: new Date().toISOString()
                        });

                        // Clear input
                        chatInput.value = '';

                        // Add assistant message (running state)
                        const assistantMsg = {
                            id: serverMessageId,  // æœåŠ¡å™¨æ¶ˆæ¯IDï¼Œç”¨äºç»‘å®šæˆªå›¾
                            role: 'assistant',
                            content: '',
                            status: 'running',
                            logs: [],
                            screenshots: [],  // ä½¿ç”¨ screenshots æ•°ç»„è€Œä¸æ˜¯ screenshot
                            timestamp: new Date().toISOString(),
                            todoList: null,  // å¤æ‚ä»»åŠ¡æ¨¡å¼ä¸‹çš„todoList
                            tokens: 0,
                            taskId: null  // å…³è”çš„ä»»åŠ¡IDï¼Œç”¨äºåŒ¹é…WebSocketäº‹ä»¶
                        };
                        chatMessages.value.push(assistantMsg);

                        scrollChatToBottom();
                        chatRunning.value = true;

                        try {
                            // å¤æ‚ä»»åŠ¡æ¨¡å¼ï¼šå…ˆæ‹†è§£ä»»åŠ¡
                            if (complexTaskMode.value) {
                                assistantMsg.content = 'ğŸ§© æ­£åœ¨åˆ†æä»»åŠ¡...';
                                saveCurrentSession();

                                // è°ƒç”¨ä»»åŠ¡æ‹†è§£API
                                const decomposeResult = await apiCall('/api/tasks/decompose', {
                                    method: 'POST',
                                    body: JSON.stringify({ task_content: content }),
                                });

                                if (decomposeResult.success && decomposeResult.todoList) {
                                    // åˆå§‹åŒ–todoListï¼Œæ‰€æœ‰ä»»åŠ¡çŠ¶æ€ä¸ºpendingï¼Œæ¯ä¸ªå­ä»»åŠ¡æœ‰ç‹¬ç«‹çš„logsæ•°ç»„
                                    assistantMsg.todoList = decomposeResult.todoList.map(item => ({
                                        content: item.content,
                                        status: 'pending',
                                        logs: []  // æ¯ä¸ªå­ä»»åŠ¡ç‹¬ç«‹çš„æ—¥å¿—æ•°ç»„
                                    }));
                                    assistantMsg.tokens = decomposeResult.tokens || 0;
                                    assistantMsg.content = 'ğŸ“‹ ä»»åŠ¡å·²æ‹†è§£ï¼Œå‡†å¤‡æ‰§è¡Œ...';
                                    assistantMsg.currentTodoIndex = -1;  // ç”¨äºè·Ÿè¸ªå½“å‰æ‰§è¡Œçš„å­ä»»åŠ¡ç´¢å¼•
                                    saveCurrentSession();
                                    scrollChatToBottom();

                                    // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–ä»»åŠ¡åœ¨è¿è¡Œ
                                    const status = await apiCall('/api/tasks/status');
                                    if (status.running && status.task) {
                                        // æœ‰ä»»åŠ¡åœ¨è¿è¡Œï¼ŒChatä»»åŠ¡ä¼˜å…ˆçº§æœ€é«˜ï¼Œç›´æ¥æ‰“æ–­
                                        const currentTaskType = status.task.task_type || 'manual';
                                        const currentTaskContent = status.task.task_content || 'æœªçŸ¥ä»»åŠ¡';
                                        const typeNames = { 'manual': 'æ‰‹åŠ¨ä»»åŠ¡', 'scheduled': 'å®šæ—¶ä»»åŠ¡', 'chat': 'Chatä»»åŠ¡' };
                                        const typeName = typeNames[currentTaskType] || 'æœªçŸ¥ä»»åŠ¡';

                                        // Chatä»»åŠ¡å¯ä»¥æ‰“æ–­å…¶ä»–ç±»å‹çš„ä»»åŠ¡
                                        if (currentTaskType !== 'chat') {
                                            assistantMsg.content = `âš ï¸ æ­£åœ¨æ‰“æ–­${typeName}: ${currentTaskContent.substring(0, 30)}...`;
                                            saveCurrentSession();
                                            // å¼ºåˆ¶åœæ­¢å½“å‰ä»»åŠ¡
                                            await apiCall('/api/tasks/stop', { method: 'POST' });
                                            // ç­‰å¾…ä»»åŠ¡åœæ­¢
                                            await new Promise(resolve => setTimeout(resolve, 1500));
                                        } else {
                                            // å¦ä¸€ä¸ªChatä»»åŠ¡æ­£åœ¨è¿è¡Œï¼Œéœ€è¦ç­‰å¾…
                                            let waitAttempts = 0;
                                            const maxWaitAttempts = 60;
                                            while (waitAttempts < maxWaitAttempts) {
                                                const checkStatus = await apiCall('/api/tasks/status');
                                                if (!checkStatus.running) break;
                                                assistantMsg.content = `â³ ç­‰å¾…å…¶ä»–Chatä»»åŠ¡å®Œæˆ... (${waitAttempts + 1}s)`;
                                                saveCurrentSession();
                                                await new Promise(resolve => setTimeout(resolve, 1000));
                                                waitAttempts++;
                                                if (!chatRunning.value) throw new Error('ç”¨æˆ·å–æ¶ˆäº†ä»»åŠ¡');
                                            }
                                            if (waitAttempts >= maxWaitAttempts) {
                                                throw new Error('ç­‰å¾…è¶…æ—¶ï¼Œå…¶ä»–ä»»åŠ¡ä»åœ¨è¿è¡Œ');
                                            }
                                        }
                                    }

                                    assistantMsg.content = 'ğŸ“‹ å¼€å§‹é€ä¸ªæ‰§è¡Œå­ä»»åŠ¡...';
                                    saveCurrentSession();

                                    // é€ä¸ªæ‰§è¡Œå­ä»»åŠ¡
                                    let allSuccess = true;
                                    const totalTasks = assistantMsg.todoList.length;

                                    for (let i = 0; i < totalTasks; i++) {
                                        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœæ­¢äº†ä»»åŠ¡
                                        if (!chatRunning.value) {
                                            console.log(`[å­ä»»åŠ¡ ${i + 1}/${totalTasks}] ç”¨æˆ·åœæ­¢äº†ä»»åŠ¡`);
                                            // å°†å½“å‰å’Œå‰©ä½™ä»»åŠ¡æ ‡è®°ä¸ºå¤±è´¥
                                            for (let j = i; j < totalTasks; j++) {
                                                if (assistantMsg.todoList[j].status === 'pending' || assistantMsg.todoList[j].status === 'running') {
                                                    assistantMsg.todoList[j].status = 'failed';
                                                }
                                            }
                                            allSuccess = false;
                                            break;
                                        }

                                        const todoItem = assistantMsg.todoList[i];
                                        const maxRetries = 2;  // æœ€å¤šé‡è¯•2æ¬¡
                                        let retryCount = 0;
                                        let subtaskSuccess = false;
                                        let skipRetry = false;  // è¶…æ—¶åä¸é‡è¯•

                                        // é‡è¯•å¾ªç¯ï¼ˆè¶…æ—¶åä¸é‡è¯•ï¼‰
                                        while (retryCount <= maxRetries && !subtaskSuccess && !skipRetry) {
                                            if (retryCount > 0) {
                                                console.log(`[å­ä»»åŠ¡ ${i + 1}/${totalTasks}] é‡è¯•ç¬¬ ${retryCount} æ¬¡...`);
                                                assistantMsg.content = `ğŸ”„ é‡è¯•å­ä»»åŠ¡ (${retryCount}/${maxRetries}): ${todoItem.content} (${i + 1}/${totalTasks})`;
                                                saveCurrentSession();
                                                // é‡è¯•å‰ç­‰å¾…ä¸€ä¸‹
                                                await new Promise(resolve => setTimeout(resolve, 2000));
                                            }

                                            todoItem.status = 'running';
                                            assistantMsg.currentTodoIndex = i;  // è®¾ç½®å½“å‰æ‰§è¡Œçš„å­ä»»åŠ¡ç´¢å¼•
                                            if (retryCount === 0) {
                                                assistantMsg.content = `ğŸ”„ æ­£åœ¨æ‰§è¡Œ: ${todoItem.content} (${i + 1}/${totalTasks})`;
                                            }
                                            saveCurrentSession();
                                            scrollChatToBottom();

                                            // å¯åŠ¨å€’è®¡æ—¶å®šæ—¶å™¨
                                            const countdownStartTime = Date.now();
                                            subtaskCountdown.value = subtaskTimeoutSeconds.value;
                                            if (subtaskCountdownTimer) clearInterval(subtaskCountdownTimer);
                                            subtaskCountdownTimer = setInterval(() => {
                                                const elapsed = Math.floor((Date.now() - countdownStartTime) / 1000);
                                                subtaskCountdown.value = Math.max(0, subtaskTimeoutSeconds.value - elapsed);
                                            }, 1000);

                                            try {
                                                // æ‰§è¡Œå•ä¸ªå­ä»»åŠ¡
                                                console.log(`[å­ä»»åŠ¡ ${i + 1}/${totalTasks}] å¼€å§‹æ‰§è¡Œ (å°è¯• ${retryCount + 1}):`, todoItem.content);

                                                // å…ˆç­‰å¾…ä¸€ä¸‹ç¡®ä¿å‰ä¸€ä¸ªä»»åŠ¡å®Œå…¨æ¸…ç†
                                                if (i > 0 || retryCount > 0) {
                                                    console.log(`[å­ä»»åŠ¡ ${i + 1}] ç­‰å¾…ä»»åŠ¡æ¸…ç†...`);
                                                    await new Promise(resolve => setTimeout(resolve, 1500));
                                                }

                                                console.log(`[å­ä»»åŠ¡ ${i + 1}] è°ƒç”¨ /api/tasks/run...`);
                                                const runResult = await apiCall('/api/tasks/run', {
                                                    method: 'POST',
                                                    body: JSON.stringify({
                                                        task_content: todoItem.content,
                                                        device_ids: [chatDeviceId.value],
                                                        send_email: false,  // å­ä»»åŠ¡ä¸å‘é‚®ä»¶
                                                        no_auto_lock: true,  // æ‰€æœ‰å­ä»»åŠ¡éƒ½ä¸è‡ªåŠ¨é”å±ï¼Œæœ€åç»Ÿä¸€å¤„ç†
                                                        task_type: "chat",  // æ ‡è®°ä¸º chat ä»»åŠ¡ï¼Œé¿å…æ—¥å¿—å‡ºç°åœ¨ Run Task é¡µé¢
                                                        session_id: serverSessionId,  // ä¼ é€’ä¼šè¯ID
                                                        message_id: serverMessageId,  // ä¼ é€’æ¶ˆæ¯ID
                                                    }),
                                                });
                                                console.log(`[å­ä»»åŠ¡ ${i + 1}] run è°ƒç”¨æˆåŠŸ:`, runResult);

                                                // ç­‰å¾…ä»»åŠ¡å®Œæˆï¼ˆé€šè¿‡è½®è¯¢çŠ¶æ€ï¼‰
                                                let taskCompleted = false;
                                                let attempts = 0;
                                                const maxAttempts = 600;  // æœ€å¤šç­‰10åˆ†é’Ÿ (600 * 1000ms)ï¼Œå®é™…ç”±è¶…æ—¶è®¾ç½®æ§åˆ¶
                                                const subtaskStartTime = Date.now();  // è®°å½•å­ä»»åŠ¡å¼€å§‹æ—¶é—´

                                                while (!taskCompleted && attempts < maxAttempts) {
                                                    // æ¯æ¬¡è½®è¯¢å‰æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœæ­¢äº†ä»»åŠ¡
                                                    if (!chatRunning.value) {
                                                        console.log(`[å­ä»»åŠ¡ ${i + 1}] è½®è¯¢ä¸­æ£€æµ‹åˆ°ç”¨æˆ·åœæ­¢`);
                                                        todoItem.status = 'failed';
                                                        break;
                                                    }

                                                    // æ£€æŸ¥æ˜¯å¦è¶…æ—¶
                                                    const elapsedSeconds = (Date.now() - subtaskStartTime) / 1000;
                                                    if (elapsedSeconds > subtaskTimeoutSeconds.value) {
                                                        console.log(`[å­ä»»åŠ¡ ${i + 1}] è¶…æ—¶ (${elapsedSeconds.toFixed(0)}s > ${subtaskTimeoutSeconds.value}s)`);
                                                        todoItem.status = 'failed';
                                                        todoItem.logs.push(`â° è¶…æ—¶ (${subtaskTimeoutSeconds.value}ç§’)`);
                                                        // å¼ºåˆ¶åœæ­¢å½“å‰è¿è¡Œçš„ä»»åŠ¡
                                                        await apiCall('/api/tasks/stop', { method: 'POST' });
                                                        taskCompleted = true;
                                                        allSuccess = false;
                                                        skipRetry = true;  // è¶…æ—¶åä¸é‡è¯•
                                                        break;
                                                    }

                                                    await new Promise(resolve => setTimeout(resolve, 1000));
                                                    const status = await apiCall('/api/tasks/status');
                                                    console.log(`[å­ä»»åŠ¡ ${i + 1}] è½®è¯¢çŠ¶æ€ #${attempts + 1}:`, status);
                                                    if (!status.running) {
                                                        taskCompleted = true;
                                                        // æ£€æŸ¥ä»»åŠ¡æ˜¯å¦æˆåŠŸ
                                                        if (status.task) {
                                                            if (status.task.status === 'completed') {
                                                                todoItem.status = 'completed';
                                                                subtaskSuccess = true;
                                                                console.log(`[å­ä»»åŠ¡ ${i + 1}] å®Œæˆ (status=completed)`);
                                                                todoItem.status = 'completed';
                                                                subtaskSuccess = true;
                                                                console.log(`[å­ä»»åŠ¡ ${i + 1}] å®Œæˆ (status=completed)`);
                                                            } else if (status.task.status === 'stopped') {
                                                                // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·æ‰‹åŠ¨è·³è¿‡
                                                                if (isSkipping.value) {
                                                                    todoItem.status = 'skipped';
                                                                    subtaskSuccess = true; // è§†ä¸ºæˆåŠŸï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
                                                                    console.log(`[å­ä»»åŠ¡ ${i + 1}] å·²è·³è¿‡`);
                                                                    isSkipping.value = false; // é‡ç½®æ ‡å¿—
                                                                    // ç»™ä¸€ç‚¹æ—¶é—´è®©ç•Œé¢æ›´æ–°
                                                                    await new Promise(resolve => setTimeout(resolve, 500));
                                                                } else {
                                                                    todoItem.status = 'failed';
                                                                    console.log(`[å­ä»»åŠ¡ ${i + 1}] å·²åœæ­¢`);
                                                                }
                                                            } else {
                                                                todoItem.status = 'failed';
                                                                console.log(`[å­ä»»åŠ¡ ${i + 1}] å¤±è´¥ (status=${status.task.status})`);
                                                            }
                                                        } else {
                                                            // task ä¸º null ä¸” running ä¸º falseï¼Œè¯´æ˜ä»»åŠ¡å·²æ­£å¸¸å®Œæˆå¹¶è¢«æ¸…ç†
                                                            todoItem.status = 'completed';
                                                            subtaskSuccess = true;
                                                            console.log(`[å­ä»»åŠ¡ ${i + 1}] å®Œæˆ (task cleared)`);
                                                        }
                                                    }
                                                    attempts++;
                                                }

                                                // æ£€æŸ¥æ˜¯å¦è¢«åœæ­¢æˆ–è¶…æ—¶
                                                if (!chatRunning.value && todoItem.status === 'running') {
                                                    todoItem.status = 'failed';
                                                    console.log(`[å­ä»»åŠ¡ ${i + 1}] æ‰§è¡ŒæœŸé—´è¢«åœæ­¢`);
                                                }

                                                if (!taskCompleted && todoItem.status === 'running') {
                                                    todoItem.status = 'failed';
                                                    console.log(`[å­ä»»åŠ¡ ${i + 1}] è¶…æ—¶å¤±è´¥`);
                                                }
                                            } catch (error) {
                                                todoItem.status = 'failed';
                                                console.error(`[å­ä»»åŠ¡ ${i + 1}] å¼‚å¸¸å¤±è´¥ (å°è¯• ${retryCount + 1}):`, error);
                                                console.error(`[å­ä»»åŠ¡ ${i + 1}] é”™è¯¯è¯¦æƒ…:`, error.message);
                                            }

                                            // å¦‚æœå­ä»»åŠ¡å¤±è´¥ä¸”ä¸æ˜¯è¶…æ—¶ï¼Œå¢åŠ é‡è¯•è®¡æ•°
                                            if (!subtaskSuccess && todoItem.status === 'failed' && !skipRetry) {
                                                retryCount++;
                                                if (retryCount <= maxRetries) {
                                                    todoItem.logs = todoItem.logs || [];
                                                    todoItem.logs.push(`âš ï¸ å­ä»»åŠ¡å¤±è´¥ï¼Œæ­£åœ¨é‡è¯• (${retryCount}/${maxRetries})...`);
                                                }
                                            }
                                        }

                                        // åœæ­¢å€’è®¡æ—¶å®šæ—¶å™¨
                                        if (subtaskCountdownTimer) {
                                            clearInterval(subtaskCountdownTimer);
                                            subtaskCountdownTimer = null;
                                        }
                                        subtaskCountdown.value = 0;

                                        // é‡è¯•åä»ç„¶å¤±è´¥ï¼ˆéè¶…æ—¶æƒ…å†µï¼‰ï¼Œä¸­æ­¢æ•´ä¸ªä»»åŠ¡
                                        // è¶…æ—¶æƒ…å†µä¸‹ç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªå­ä»»åŠ¡
                                        if (!subtaskSuccess && !skipRetry) {
                                            allSuccess = false;
                                            todoItem.logs = todoItem.logs || [];
                                            todoItem.logs.push(`âŒ å­ä»»åŠ¡åœ¨é‡è¯• ${maxRetries} æ¬¡åä»ç„¶å¤±è´¥ï¼Œä¸­æ­¢ä»»åŠ¡æ‰§è¡Œ`);
                                            console.log(`[å­ä»»åŠ¡ ${i + 1}] é‡è¯• ${maxRetries} æ¬¡åä»ç„¶å¤±è´¥ï¼Œä¸­æ­¢æ•´ä¸ªä»»åŠ¡`);

                                            // å°†å‰©ä½™ä»»åŠ¡æ ‡è®°ä¸ºæœªæ‰§è¡Œï¼ˆpendingï¼‰
                                            for (let j = i + 1; j < totalTasks; j++) {
                                                if (assistantMsg.todoList[j].status === 'pending') {
                                                    // ä¿æŒ pending çŠ¶æ€ï¼Œè¡¨ç¤ºæœªæ‰§è¡Œ
                                                }
                                            }
                                            break;  // ä¸­æ­¢æ•´ä¸ªä»»åŠ¡å¾ªç¯
                                        } else if (skipRetry) {
                                            // è¶…æ—¶æƒ…å†µä¸‹ï¼Œç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªå­ä»»åŠ¡
                                            console.log(`[å­ä»»åŠ¡ ${i + 1}] è¶…æ—¶å¤±è´¥ï¼Œç»§ç»­æ‰§è¡Œä¸‹ä¸€ä¸ªå­ä»»åŠ¡`);
                                        }

                                        saveCurrentSession();
                                        scrollChatToBottom();
                                    }

                                    // æ¸…é™¤å½“å‰æ‰§è¡Œç´¢å¼•
                                    assistantMsg.currentTodoIndex = undefined;

                                    // åœ¨é”å±å‰æˆªå–æœ€ç»ˆæˆªå›¾å¹¶ä¿å­˜åˆ°æ•°æ®åº“
                                    try {
                                        console.log('[å¤æ‚ä»»åŠ¡] æˆªå–æœ€ç»ˆæˆªå›¾...');
                                        const screenshotResponse = await fetch(`/api/devices/${chatDeviceId.value}/screenshot/base64`);
                                        if (screenshotResponse.ok) {
                                            const screenshotData = await screenshotResponse.json();
                                            // API è¿”å›çš„æ˜¯ {"image": "base64..."} æ ¼å¼
                                            if (screenshotData.image && currentSessionId.value && assistantMsg.id) {
                                                // ä¿å­˜æˆªå›¾åˆ°æ•°æ®åº“ï¼Œä¸å†ä¿å­˜ base64 åˆ°æ¶ˆæ¯å¯¹è±¡
                                                try {
                                                    const saveResult = await apiCall(
                                                        `/api/chat/sessions/${currentSessionId.value}/messages/${assistantMsg.id}/screenshots`,
                                                        {
                                                            method: 'POST',
                                                            body: JSON.stringify({
                                                                image: screenshotData.image,
                                                                description: 'å¤æ‚ä»»åŠ¡å®Œæˆæˆªå›¾'
                                                            })
                                                        }
                                                    );
                                                    if (saveResult && saveResult.id) {
                                                        // æ›´æ–°æ¶ˆæ¯çš„ screenshots æ•°ç»„
                                                        if (!assistantMsg.screenshots) {
                                                            assistantMsg.screenshots = [];
                                                        }
                                                        assistantMsg.screenshots.push({
                                                            id: saveResult.id,
                                                            image_url: `/api/chat/screenshots/${saveResult.id}`
                                                        });
                                                        console.log('[å¤æ‚ä»»åŠ¡] æˆªå›¾å·²ä¿å­˜åˆ°æ•°æ®åº“:', saveResult.id);
                                                    }
                                                } catch (saveError) {
                                                    console.error('[å¤æ‚ä»»åŠ¡] ä¿å­˜æˆªå›¾åˆ°æ•°æ®åº“å¤±è´¥:', saveError);
                                                }
                                            }
                                        }
                                    } catch (screenshotError) {
                                        console.error('[å¤æ‚ä»»åŠ¡] æˆªå›¾å¤±è´¥:', screenshotError);
                                    }

                                    // æˆªå›¾å®Œæˆåé”å±
                                    try {
                                        console.log('[å¤æ‚ä»»åŠ¡] é”å®šè®¾å¤‡...');
                                        await apiCall(`/api/devices/${chatDeviceId.value}/lock`, { method: 'POST' });
                                        console.log('[å¤æ‚ä»»åŠ¡] è®¾å¤‡å·²é”å®š');
                                    } catch (lockError) {
                                        console.error('[å¤æ‚ä»»åŠ¡] é”å±å¤±è´¥:', lockError);
                                    }

                                    // æ‰€æœ‰å­ä»»åŠ¡æ‰§è¡Œå®Œæˆ
                                    assistantMsg.status = allSuccess ? 'success' : 'error';
                                    assistantMsg.content = allSuccess
                                        ? `âœ… å¤æ‚ä»»åŠ¡æ‰§è¡Œå®Œæˆï¼å…± ${totalTasks} ä¸ªå­ä»»åŠ¡å…¨éƒ¨æˆåŠŸã€‚`
                                        : `âš ï¸ å¤æ‚ä»»åŠ¡æ‰§è¡Œå®Œæˆï¼Œéƒ¨åˆ†å­ä»»åŠ¡å¤±è´¥ã€‚`;
                                    assistantMsg.timestamp = new Date().toISOString();

                                    // å‘é€æ±‡æ€»é‚®ä»¶ï¼ˆå¦‚æœå¼€å¯ï¼‰
                                    if (chatAutoEmail.value) {
                                        try {
                                            console.log('[å¤æ‚ä»»åŠ¡] å‘é€æ±‡æ€»é‚®ä»¶...');
                                            // è·å–æœ€æ–°çš„æˆªå›¾ IDï¼ˆå¦‚æœæœ‰ï¼‰
                                            const latestScreenshotId = assistantMsg.screenshots && assistantMsg.screenshots.length > 0
                                                ? assistantMsg.screenshots[assistantMsg.screenshots.length - 1].id
                                                : null;
                                            const emailResult = await apiCall('/api/tasks/send-complex-email', {
                                                method: 'POST',
                                                body: JSON.stringify({
                                                    task_name: content,
                                                    subtasks: assistantMsg.todoList.map(t => ({
                                                        content: t.content,
                                                        status: t.status,
                                                        logs: t.logs || []
                                                    })),
                                                    total_tokens: assistantMsg.tokens || 0,
                                                    screenshot_id: latestScreenshotId  // ä½¿ç”¨ screenshot_id è€Œä¸æ˜¯ base64
                                                }),
                                            });
                                            if (emailResult.success) {
                                                console.log('[å¤æ‚ä»»åŠ¡] é‚®ä»¶å‘é€æˆåŠŸ');
                                            } else {
                                                console.log('[å¤æ‚ä»»åŠ¡] é‚®ä»¶å‘é€å¤±è´¥:', emailResult.message);
                                            }
                                        } catch (emailError) {
                                            console.error('[å¤æ‚ä»»åŠ¡] é‚®ä»¶å‘é€å¤±è´¥:', emailError);
                                        }
                                    }
                                } else {
                                    throw new Error('ä»»åŠ¡æ‹†è§£å¤±è´¥');
                                }
                            } else {
                                // æ™®é€šæ¨¡å¼ï¼šç›´æ¥æ‰§è¡Œä»»åŠ¡
                                const runResult = await apiCall('/api/tasks/run', {
                                    method: 'POST',
                                    body: JSON.stringify({
                                        task_content: content,
                                        device_ids: [chatDeviceId.value],
                                        send_email: chatAutoEmail.value,
                                        task_type: "chat",  // æ ‡è®°ä¸º chat ä»»åŠ¡ï¼Œé¿å…æ—¥å¿—å‡ºç°åœ¨ Run Task é¡µé¢
                                        session_id: serverSessionId,  // ä¼ é€’ä¼šè¯ID
                                        message_id: serverMessageId,  // ä¼ é€’æ¶ˆæ¯ID
                                    }),
                                });
                                // ä¿å­˜ä»»åŠ¡IDç”¨äºåŒ¹é…WebSocketäº‹ä»¶
                                if (runResult && runResult.task_id) {
                                    assistantMsg.taskId = runResult.task_id;
                                }
                                // Task started, WebSocket will handle updates
                            }
                        } catch (error) {
                            // Update last message to error
                            const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                            if (lastMsg.role === 'assistant') {
                                lastMsg.status = 'error';
                                let errorMsg = error.message || 'æœªçŸ¥é”™è¯¯';

                                // æä¾›æ›´å‹å¥½çš„é”™è¯¯æç¤º
                                if (errorMsg.includes('Token error') || errorMsg.includes('limited')) {
                                    errorMsg = 'âŒ ' + errorMsg + '\n\nğŸ’¡ æç¤ºï¼šæ¨¡å‹æœåŠ¡è¢«é™æµï¼Œè¯·ç¨åå†è¯•ï¼Œæˆ–æ£€æŸ¥æ¨¡å‹é…ç½®ä¸­çš„APIé¢åº¦ã€‚';
                                } else if (errorMsg.includes('Failed to parse todoList')) {
                                    errorMsg = 'âŒ ä»»åŠ¡æ‹†è§£å¤±è´¥ï¼šæ¨¡å‹è¿”å›çš„æ ¼å¼ä¸æ­£ç¡®ã€‚\n\nğŸ’¡ æç¤ºï¼šè¯·å°è¯•å°†ä»»åŠ¡æè¿°å¾—æ›´æ¸…æ™°ï¼Œæˆ–åˆ‡æ¢åˆ°æ™®é€šä»»åŠ¡æ¨¡å¼æ‰§è¡Œã€‚';
                                }

                                lastMsg.content = 'å¯åŠ¨ä»»åŠ¡å¤±è´¥: ' + errorMsg;
                            }
                            chatRunning.value = false;
                        }

                        // å¤æ‚ä»»åŠ¡æ¨¡å¼ä¸‹ï¼Œæ‰§è¡Œå®Œæˆåé‡ç½®çŠ¶æ€
                        if (complexTaskMode.value) {
                            chatRunning.value = false;
                        }

                        // Save session after sending message
                        saveCurrentSession();
                    }

                    // Stop chat task
                    async function stopChatTask() {
                        try {
                            await apiCall('/api/tasks/stop', { method: 'POST' });
                            showToast('æ­£åœ¨åœæ­¢ä»»åŠ¡...');

                            // Update chat message status
                            if (chatMessages.value.length > 0) {
                                const lastMsg = chatMessages.value[chatMessages.value.length - 1];
                                if (lastMsg.role === 'assistant' && lastMsg.status === 'running') {
                                    lastMsg.status = 'error';
                                    lastMsg.content = 'ä»»åŠ¡å·²åœæ­¢';
                                }
                            }
                            chatRunning.value = false;
                            saveCurrentSession();
                        } catch (error) {
                            showToast('åœæ­¢ä»»åŠ¡å¤±è´¥', 'error');
                        }
                    }

                    // Open task detail modal
                    async function openTaskDetail(msg) {
                        // å§‹ç»ˆä»æœåŠ¡å™¨è·å–å®Œæ•´çš„æˆªå›¾åˆ—è¡¨ï¼ˆWebSocket å¯èƒ½åªæ¨é€äº†éƒ¨åˆ†æˆªå›¾ï¼‰
                        let screenshots = [];

                        // å¦‚æœå­˜åœ¨ session_id å’Œ message_idï¼Œåˆ™ä»æœåŠ¡å™¨è·å–å®Œæ•´æˆªå›¾åˆ—è¡¨
                        if (currentSessionId.value && msg.id) {
                            try {
                                const screenshotData = await apiCall(
                                    `/api/chat/sessions/${currentSessionId.value}/screenshots?message_id=${msg.id}`
                                );
                                if (screenshotData && screenshotData.length > 0) {
                                    screenshots = screenshotData;
                                    // æ›´æ–°æ¶ˆæ¯å¯¹è±¡ä¸­çš„ screenshots
                                    msg.screenshots = screenshots;
                                }
                            } catch (error) {
                                console.error('Failed to load screenshots:', error);
                                // è·å–å¤±è´¥æ—¶ä½¿ç”¨æœ¬åœ°ç¼“å­˜çš„æ•°æ®
                                screenshots = msg.screenshots || [];
                            }
                        } else {
                            // æ²¡æœ‰ session/message idï¼Œä½¿ç”¨æœ¬åœ°æ•°æ®
                            screenshots = msg.screenshots || [];
                        }

                        taskDetailData.value = {
                            status: msg.status,
                            logs: msg.logs || [],
                            screenshots: screenshots  // åªä½¿ç”¨ screenshotsï¼Œä¸å†ä½¿ç”¨ base64 screenshot
                        };
                        showTaskDetail.value = true;
                    }

                    // Device functions (original)
                    async function refreshDevices() {
                        loading.value = true;
                        try {
                            const data = await apiCall('/api/devices/refresh', { method: 'POST' });
                            devices.value = data;
                            showToast(`Found ${data.length} device(s)`);
                        } catch (e) {
                            console.error('Failed to refresh devices:', e);
                        } finally {
                            loading.value = false;
                        }
                    }

                    function toggleDeviceSelection(deviceId) {
                        const index = selectedDevices.value.indexOf(deviceId);
                        if (index === -1) {
                            selectedDevices.value.push(deviceId);
                        } else {
                            selectedDevices.value.splice(index, 1);
                        }
                    }

                    function selectAllDevices() {
                        if (selectedDevices.value.length === devices.value.length) {
                            selectedDevices.value = [];
                        } else {
                            selectedDevices.value = devices.value.map(d => d.id);
                        }
                    }

                    function getDeviceName(id) {
                        const device = devices.value.find(d => d.id === id);
                        return device ? (device.name || device.id.substring(0, 20)) : id.substring(0, 20);
                    }

                    async function unlockDevice(deviceId) {
                        try {
                            const pin = pinInputValues.value[deviceId] || '';
                            await apiCall(`/api/devices/${deviceId}/unlock`, {
                                method: 'POST',
                                body: JSON.stringify({ pin: pin }),
                            });
                            showToast('è®¾å¤‡å·²è§£é”');
                        } catch (error) {
                            showToast('è§£é”å¤±è´¥', 'error');
                        }
                    }

                    // Wireless pairing functions
                    async function wirelessPair() {
                        if (!pairAddress.value) {
                            showToast('è¯·è¾“å…¥é…å¯¹åœ°å€', 'error');
                            return;
                        }
                        if (!pairCode.value || pairCode.value.length !== 6) {
                            showToast('è¯·è¾“å…¥6ä½é…å¯¹ç ', 'error');
                            return;
                        }
                        pairingLoading.value = true;
                        deviceLogs.value = [];
                        try {
                            const data = await apiCall('/api/devices/pair', {
                                method: 'POST',
                                body: JSON.stringify({
                                    pair_address: pairAddress.value,
                                    pair_code: pairCode.value,
                                }),
                            });
                            deviceLogs.value = data.logs || [];
                            if (data.success) {
                                showToast(data.message, 'success');
                                pairCode.value = '';
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('é…å¯¹å¤±è´¥: ' + error.message, 'error');
                        } finally {
                            pairingLoading.value = false;
                        }
                    }

                    async function tcpConnect() {
                        if (!connectAddress.value) {
                            showToast('è¯·è¾“å…¥è¿æ¥åœ°å€', 'error');
                            return;
                        }
                        connectingLoading.value = true;
                        deviceLogs.value = [];
                        try {
                            const data = await apiCall('/api/devices/connect', {
                                method: 'POST',
                                body: JSON.stringify({
                                    connect_address: connectAddress.value,
                                }),
                            });
                            deviceLogs.value = data.logs || [];
                            if (data.success) {
                                showToast(data.message, 'success');
                                await refreshDevices();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('è¿æ¥å¤±è´¥: ' + error.message, 'error');
                        } finally {
                            connectingLoading.value = false;
                        }
                    }

                    async function disconnectDevice(deviceId) {
                        try {
                            const data = await apiCall(`/api/devices/disconnect/${deviceId}`, {
                                method: 'POST',
                            });
                            if (data.success) {
                                showToast('è®¾å¤‡å·²æ–­å¼€');
                                await refreshDevices();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('æ–­å¼€å¤±è´¥', 'error');
                        }
                    }

                    // APK install functions
                    function onApkFileSelect(event) {
                        const file = event.target.files[0];
                        if (file && file.name.toLowerCase().endsWith('.apk')) {
                            apkFile.value = file;
                            apkLogs.value = [];
                        } else {
                            apkFile.value = null;
                            showToast('è¯·é€‰æ‹© APK æ–‡ä»¶', 'error');
                        }
                    }

                    async function installApk() {
                        if (!apkTargetDevice.value) {
                            showToast('è¯·é€‰æ‹©ç›®æ ‡è®¾å¤‡', 'error');
                            return;
                        }
                        if (!apkFile.value) {
                            showToast('è¯·é€‰æ‹© APK æ–‡ä»¶', 'error');
                            return;
                        }

                        apkInstalling.value = true;
                        apkLogs.value = ['å‡†å¤‡ä¸Šä¼  APK æ–‡ä»¶...'];

                        try {
                            const formData = new FormData();
                            formData.append('file', apkFile.value);

                            apkLogs.value.push(`ä¸Šä¼ ä¸­: ${apkFile.value.name}`);

                            const response = await fetch(`/api/devices/${apkTargetDevice.value}/install-apk`, {
                                method: 'POST',
                                body: formData,
                            });

                            const data = await response.json();
                            apkLogs.value = data.logs || [];

                            if (data.success) {
                                showToast(data.message, 'success');
                                // Clear file input
                                apkFile.value = null;
                                if (apkFileInput.value) {
                                    apkFileInput.value.value = '';
                                }
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            apkLogs.value.push(`âŒ å®‰è£…å¤±è´¥: ${error.message}`);
                            showToast('APK å®‰è£…å¤±è´¥', 'error');
                        } finally {
                            apkInstalling.value = false;
                        }
                    }

                    // File manager functions
                    async function loadFiles() {
                        if (!fileDevice.value) return;
                        fileLoading.value = true;
                        try {
                            const data = await apiCall(`/api/devices/${fileDevice.value}/files?path=${encodeURIComponent(filePath.value)}`);
                            fileList.value = data.files || [];
                        } catch (error) {
                            showToast('åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥: ' + error.message, 'error');
                            fileList.value = [];
                        } finally {
                            fileLoading.value = false;
                        }
                    }

                    function navigateTo(path) {
                        // Normalize path
                        path = path.replace(/\/+/g, '/');
                        if (path !== '/' && path.endsWith('/')) {
                            path = path.slice(0, -1);
                        }
                        filePath.value = path;
                        loadFiles();
                    }

                    function goUp() {
                        const parts = filePath.value.split('/').filter(p => p);
                        if (parts.length > 0) {
                            parts.pop();
                            filePath.value = '/' + parts.join('/');
                            loadFiles();
                        }
                    }

                    function formatFileSize(size) {
                        const num = parseInt(size);
                        if (isNaN(num)) return size;
                        if (num < 1024) return num + ' B';
                        if (num < 1024 * 1024) return (num / 1024).toFixed(1) + ' KB';
                        if (num < 1024 * 1024 * 1024) return (num / 1024 / 1024).toFixed(1) + ' MB';
                        return (num / 1024 / 1024 / 1024).toFixed(1) + ' GB';
                    }

                    function isImageFile(name) {
                        return /\.(jpg|jpeg|png|gif|bmp|webp)$/i.test(name);
                    }

                    function isVideoFile(name) {
                        return /\.(mp4|mkv|avi|mov|wmv|flv|webm)$/i.test(name);
                    }

                    function isAudioFile(name) {
                        return /\.(mp3|wav|flac|aac|ogg|m4a)$/i.test(name);
                    }

                    async function downloadFile(filename) {
                        const fullPath = filePath.value + '/' + filename;
                        try {
                            const response = await fetch(`/api/devices/${fileDevice.value}/files/download?path=${encodeURIComponent(fullPath)}`);
                            if (!response.ok) throw new Error('ä¸‹è½½å¤±è´¥');
                            const blob = await response.blob();
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = filename;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            showToast('ä¸‹è½½æˆåŠŸ');
                        } catch (error) {
                            showToast('ä¸‹è½½å¤±è´¥: ' + error.message, 'error');
                        }
                    }

                    function onUploadFileSelect(event) {
                        uploadSelectedFile.value = event.target.files[0] || null;
                    }

                    async function uploadFile() {
                        if (!uploadSelectedFile.value || !fileDevice.value) return;
                        fileUploading.value = true;
                        try {
                            const formData = new FormData();
                            formData.append('file', uploadSelectedFile.value);
                            formData.append('path', filePath.value);

                            const response = await fetch(`/api/devices/${fileDevice.value}/files/upload`, {
                                method: 'POST',
                                body: formData,
                            });
                            const data = await response.json();

                            if (data.success) {
                                showToast('ä¸Šä¼ æˆåŠŸ');
                                uploadSelectedFile.value = null;
                                if (uploadFileInput.value) uploadFileInput.value.value = '';
                                await loadFiles();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('ä¸Šä¼ å¤±è´¥: ' + error.message, 'error');
                        } finally {
                            fileUploading.value = false;
                        }
                    }

                    async function deleteFileConfirm(filename, isDir) {
                        const type = isDir ? 'æ–‡ä»¶å¤¹' : 'æ–‡ä»¶';
                        if (!confirm(`ç¡®å®šè¦åˆ é™¤${type} "${filename}" å—ï¼Ÿ`)) return;

                        const fullPath = filePath.value + '/' + filename;
                        try {
                            const data = await apiCall(`/api/devices/${fileDevice.value}/files?path=${encodeURIComponent(fullPath)}`, {
                                method: 'DELETE',
                            });
                            if (data.success) {
                                showToast('åˆ é™¤æˆåŠŸ');
                                await loadFiles();
                            } else {
                                showToast(data.message, 'error');
                            }
                        } catch (error) {
                            showToast('åˆ é™¤å¤±è´¥: ' + error.message, 'error');
                        }
                    }

                    // PIN management functions
                    async function loadDevicePins() {
                        try {
                            const data = await apiCall('/api/devices/pins');
                            devicePins.value = data.pins || {};
                            // Load actual PIN values for display
                            for (const deviceId of Object.keys(devicePins.value)) {
                                try {
                                    const pinData = await apiCall(`/api/devices/${deviceId}/pin`);
                                    if (pinData.pin) {
                                        pinInputValues.value[deviceId] = pinData.pin;
                                    }
                                } catch (e) {
                                    // Ignore errors for individual PIN fetch
                                }
                            }
                        } catch (error) {
                            console.error('Failed to load device PINs:', error);
                        }
                    }

                    function updateDevicePin(deviceId, pin) {
                        pinInputValues.value[deviceId] = pin;
                        devicePins.value[deviceId] = pin ? true : false;
                    }

                    function toggleShowPin(deviceId) {
                        if (showPinFor.value === deviceId) {
                            showPinFor.value = '';
                        } else {
                            showPinFor.value = deviceId;
                        }
                    }

                    async function saveDevicePin(deviceId, pin) {
                        if (!pin) return;
                        try {
                            await apiCall(`/api/devices/${deviceId}/pin`, {
                                method: 'PUT',
                                body: JSON.stringify({ pin: pin }),
                            });
                            showToast('PIN saved');
                        } catch (error) {
                            showToast('Failed to save PIN', 'error');
                        }
                    }

                    // Auto-scroll log container
                    function scrollLogsToBottom() {
                        if (logContainer.value) {
                            logContainer.value.scrollTop = logContainer.value.scrollHeight;
                        }
                    }

                    // Task functions
                    async function runTask() {
                        if (!taskContent.value.trim()) {
                            showToast('Please enter a task', 'warning');
                            return;
                        }
                        if (selectedDevices.value.length === 0) {
                            showToast('Please select at least one device', 'warning');
                            return;
                        }

                        taskLogs.value = [];
                        taskProgress.value = 0;

                        try {
                            await apiCall('/api/tasks/run', {
                                method: 'POST',
                                body: JSON.stringify({
                                    task_content: taskContent.value,
                                    device_ids: selectedDevices.value,
                                }),
                            });
                            taskRunning.value = true;
                            showToast('Task started');
                        } catch (error) {
                            showToast('Failed to start task', 'error');
                        }
                    }

                    async function stopTask() {
                        try {
                            await apiCall('/api/tasks/stop', { method: 'POST' });
                            showToast('Stop signal sent');
                        } catch (error) {
                            showToast('Failed to stop task', 'error');
                        }
                    }

                    // Scheduler functions
                    async function loadScheduledTasks() {
                        try {
                            const data = await apiCall('/api/scheduler/tasks');
                            scheduledTasks.value = data.tasks;
                        } catch (error) {
                            console.error('Failed to load scheduled tasks:', error);
                        }
                    }

                    async function toggleScheduledTask(taskId, enabled) {
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}/toggle`, {
                                method: 'PATCH',
                                body: JSON.stringify({ enabled }),
                            });
                            await loadScheduledTasks();
                        } catch (error) {
                            showToast('Failed to toggle task', 'error');
                        }
                    }

                    async function runScheduledTaskNow(taskId) {
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}/run`, { method: 'POST' });
                            showToast('Task triggered');
                        } catch (error) {
                            showToast('Failed to run task', 'error');
                        }
                    }

                    async function deleteScheduledTask(taskId) {
                        if (!confirm('Are you sure you want to delete this task?')) return;
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}`, { method: 'DELETE' });
                            await loadScheduledTasks();
                            showToast('Task deleted');
                        } catch (error) {
                            showToast('Failed to delete task', 'error');
                        }
                    }

                    // Scheduler form functions
                    function showCreateScheduledTask() {
                        schedulerForm.value = getDefaultSchedulerForm();
                        schedulerFormMode.value = 'create';
                        showSchedulerForm.value = true;
                    }

                    function editScheduledTask(task) {
                        schedulerForm.value = {
                            id: task.id,
                            name: task.name,
                            task_content: task.task_content,
                            enabled: task.enabled,
                            schedule_type: task.schedule_type,
                            run_at: task.run_at || '',
                            interval_minutes: task.interval_minutes || 60,
                            daily_time: task.daily_time || '09:00',
                            weekly_days: task.weekly_days || [1],
                            weekly_time: task.weekly_time || '09:00',
                            monthly_day: task.monthly_day || 1,
                            monthly_time: task.monthly_time || '09:00',
                            devices: task.devices || [],
                        };
                        schedulerFormMode.value = 'edit';
                        showSchedulerForm.value = true;
                    }

                    function cancelSchedulerForm() {
                        showSchedulerForm.value = false;
                        schedulerForm.value = getDefaultSchedulerForm();
                    }

                    async function saveScheduledTask() {
                        if (!schedulerForm.value.name.trim()) {
                            showToast('Please enter a task name', 'warning');
                            return;
                        }
                        if (!schedulerForm.value.task_content.trim()) {
                            showToast('Please enter task content', 'warning');
                            return;
                        }

                        loading.value = true;
                        try {
                            if (schedulerFormMode.value === 'create') {
                                await apiCall('/api/scheduler/tasks', {
                                    method: 'POST',
                                    body: JSON.stringify(schedulerForm.value),
                                });
                                showToast('Task created');
                            } else {
                                await apiCall(`/api/scheduler/tasks/${schedulerForm.value.id}`, {
                                    method: 'PUT',
                                    body: JSON.stringify(schedulerForm.value),
                                });
                                showToast('Task updated');
                            }
                            await loadScheduledTasks();
                            cancelSchedulerForm();
                        } catch (error) {
                            showToast('Failed to save task', 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    function formatScheduleType(task) {
                        switch (task.schedule_type) {
                            case 'once': return `Once: ${task.run_at}`;
                            case 'interval': return `Every ${task.interval_minutes} min`;
                            case 'daily': return `Daily @ ${task.daily_time}`;
                            case 'weekly': return `Weekly @ ${task.weekly_time}`;
                            case 'monthly': return `Monthly day ${task.monthly_day} @ ${task.monthly_time}`;
                            default: return task.schedule_type;
                        }
                    }

                    // Scheduler logs functions
                    async function loadSchedulerLogs() {
                        try {
                            const data = await apiCall('/api/scheduler/logs?limit=50');
                            schedulerLogs.value = data.logs || [];
                        } catch (error) {
                            console.error('Failed to load scheduler logs:', error);
                        }
                    }

                    async function clearAllSchedulerLogs() {
                        if (!confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰å®šæ—¶ä»»åŠ¡çš„æ‰§è¡Œæ—¥å¿—å—ï¼Ÿ')) return;
                        try {
                            await apiCall('/api/scheduler/logs', { method: 'DELETE' });
                            showToast('æ‰€æœ‰æ—¥å¿—å·²æ¸…ç©º');
                            schedulerLogs.value = [];
                        } catch (error) {
                            showToast('æ¸…ç©ºæ—¥å¿—å¤±è´¥: ' + error.message, 'error');
                        }
                    }

                    function formatLogTime(timestamp) {
                        if (!timestamp) return '-';
                        const date = new Date(timestamp);
                        const now = new Date();
                        const isToday = date.toDateString() === now.toDateString();
                        if (isToday) {
                            return date.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
                        }
                        return date.toLocaleString('zh-CN', { month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
                    }

                    function showLogDetails(log) {
                        logDetailData.value = log;
                        showLogDetailModal.value = true;
                    }

                    async function clearTaskLogs(taskId) {
                        if (!confirm('ç¡®å®šè¦æ¸…é™¤è¯¥ä»»åŠ¡çš„æ‰€æœ‰æ—¥å¿—å—ï¼Ÿ')) return;
                        try {
                            await apiCall(`/api/scheduler/tasks/${taskId}/logs`, { method: 'DELETE' });
                            showToast('æ—¥å¿—å·²æ¸…é™¤');
                            await loadSchedulerLogs();
                        } catch (error) {
                            showToast('æ¸…é™¤æ—¥å¿—å¤±è´¥', 'error');
                        }
                    }

                    // Model functions
                    async function loadModels() {
                        try {
                            const data = await apiCall('/api/models');
                            modelServices.value = data.services;
                            const active = modelServices.value.find(s => s.is_active);
                            activeModel.value = active || null;
                        } catch (error) {
                            console.error('Failed to load models:', error);
                        }
                    }

                    async function activateModel(serviceId) {
                        try {
                            await apiCall(`/api/models/${serviceId}/activate`, { method: 'POST' });
                            await loadModels();
                            showToast('Model activated');
                        } catch (error) {
                            showToast('Failed to activate model', 'error');
                        }
                    }

                    async function testModel(serviceId) {
                        loading.value = true;
                        try {
                            const data = await apiCall(`/api/models/${serviceId}/test`, { method: 'POST' });
                            showToast(data.message, data.success ? 'success' : 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    // Model CRUD functions
                    async function loadModelPresets() {
                        try {
                            const data = await apiCall('/api/models/presets');
                            modelPresets.value = data.presets || [];
                        } catch (error) {
                            console.error('Failed to load model presets:', error);
                        }
                    }

                    function openModelForm(mode, service = null) {
                        modelFormMode.value = mode;
                        if (mode === 'edit' && service) {
                            modelForm.value = { ...service };
                        } else {
                            modelForm.value = getDefaultModelForm();
                        }
                        showModelForm.value = true;
                    }

                    async function saveModel() {
                        if (!modelForm.value.name || !modelForm.value.base_url || !modelForm.value.model_name) {
                            showToast('è¯·å¡«å†™å¿…å¡«å­—æ®µï¼ˆåç§°ã€Base URLã€æ¨¡å‹åç§°ï¼‰', 'error');
                            return;
                        }
                        loading.value = true;
                        try {
                            if (modelFormMode.value === 'create') {
                                await apiCall('/api/models', {
                                    method: 'POST',
                                    body: JSON.stringify(modelForm.value),
                                });
                                showToast('æ¨¡å‹æœåŠ¡åˆ›å»ºæˆåŠŸ');
                            } else {
                                await apiCall(`/api/models/${modelForm.value.id}`, {
                                    method: 'PUT',
                                    body: JSON.stringify(modelForm.value),
                                });
                                showToast('æ¨¡å‹æœåŠ¡æ›´æ–°æˆåŠŸ');
                            }
                            showModelForm.value = false;
                            await loadModels();
                        } catch (error) {
                            showToast('ä¿å­˜å¤±è´¥: ' + error.message, 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    async function deleteModel(serviceId, serviceName) {
                        if (!confirm(`ç¡®å®šè¦åˆ é™¤æ¨¡å‹æœåŠ¡ "${serviceName}" å—ï¼Ÿ`)) {
                            return;
                        }
                        try {
                            await apiCall(`/api/models/${serviceId}`, { method: 'DELETE' });
                            showToast('æ¨¡å‹æœåŠ¡å·²åˆ é™¤');
                            await loadModels();
                        } catch (error) {
                            showToast('åˆ é™¤å¤±è´¥: ' + error.message, 'error');
                        }
                    }

                    async function testModelConfig() {
                        if (!modelForm.value.base_url || !modelForm.value.model_name) {
                            showToast('è¯·å¡«å†™ Base URL å’Œæ¨¡å‹åç§°', 'error');
                            return;
                        }
                        loading.value = true;
                        try {
                            const data = await apiCall('/api/models/test', {
                                method: 'POST',
                                body: JSON.stringify({
                                    base_url: modelForm.value.base_url,
                                    api_key: modelForm.value.api_key,
                                    model_name: modelForm.value.model_name,
                                }),
                            });
                            showToast(data.message, data.success ? 'success' : 'error');
                        } catch (error) {
                            showToast('æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    function addFromPreset(preset) {
                        modelForm.value = {
                            ...getDefaultModelForm(),
                            name: preset.name,
                            base_url: preset.base_url,
                            model_name: preset.model_name,
                            description: preset.description || '',
                            max_tokens: preset.max_tokens || 3000,
                            temperature: preset.temperature || 0.0,
                            protocol: preset.protocol || 'openai',
                            category: preset.category || '',
                        };
                        modelFormMode.value = 'create';
                        showModelForm.value = true;
                    }

                    // æŒ‰åˆ†ç±»è·å–é¢„è®¾æ¨¡æ¿
                    function getPresetsByCategory(category) {
                        return modelPresets.value.filter(p => p.category === category);
                    }

                    // Settings functions
                    async function loadEmailConfig() {
                        try {
                            emailConfig.value = await apiCall('/api/settings/email');
                        } catch (error) {
                            console.error('Failed to load email config:', error);
                        }
                    }

                    async function saveEmailConfig() {
                        try {
                            await apiCall('/api/settings/email', {
                                method: 'PUT',
                                body: JSON.stringify(emailConfig.value),
                            });
                            showToast('Email settings saved');
                        } catch (error) {
                            showToast('Failed to save email settings', 'error');
                        }
                    }

                    async function testEmail() {
                        loading.value = true;
                        try {
                            const data = await apiCall('/api/settings/email/test', { method: 'POST' });
                            showToast(data.message, data.success ? 'success' : 'error');
                        } finally {
                            loading.value = false;
                        }
                    }

                    // Rules configuration functions
                    async function loadAppMappings() {
                        try {
                            const data = await apiCall('/api/rules/apps');
                            appMappings.value = data.apps || [];
                        } catch (error) {
                            console.error('Failed to load app mappings:', error);
                        }
                    }

                    async function loadTimingConfig() {
                        try {
                            timingConfig.value = await apiCall('/api/rules/timing');
                        } catch (error) {
                            console.error('Failed to load timing config:', error);
                        }
                    }

                    async function loadSystemPrompts() {
                        try {
                            const data = await apiCall('/api/rules/prompts');
                            systemPrompts.value = data.prompts || {};
                        } catch (error) {
                            console.error('Failed to load prompts:', error);
                        }
                    }

                    function formatTimingKey(key) {
                        return key.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    }

                    async function updateTiming(category, key, value) {
                        try {
                            await apiCall('/api/rules/timing', {
                                method: 'PUT',
                                body: JSON.stringify({ category, key, value: parseFloat(value) }),
                            });
                            showToast('æ—¶é—´é…ç½®å·²æ›´æ–°');
                        } catch (error) {
                            showToast('æ›´æ–°å¤±è´¥', 'error');
                            loadTimingConfig(); // Reload on error
                        }
                    }

                    function editAppMapping(app) {
                        editingApp.value = app;
                        appForm.value = { app_name: app.app_name, package_name: app.package_name };
                        showAddAppModal.value = true;
                    }

                    async function saveAppMapping() {
                        if (!appForm.value.app_name || !appForm.value.package_name) {
                            showToast('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯', 'error');
                            return;
                        }
                        try {
                            if (editingApp.value) {
                                await apiCall(`/api/rules/apps/${encodeURIComponent(editingApp.value.app_name)}`, {
                                    method: 'PUT',
                                    body: JSON.stringify({
                                        new_name: appForm.value.app_name,
                                        package_name: appForm.value.package_name,
                                    }),
                                });
                                showToast('åº”ç”¨æ˜ å°„å·²æ›´æ–°');
                            } else {
                                await apiCall('/api/rules/apps', {
                                    method: 'POST',
                                    body: JSON.stringify(appForm.value),
                                });
                                showToast('åº”ç”¨æ˜ å°„å·²æ·»åŠ ');
                            }
                            showAddAppModal.value = false;
                            editingApp.value = null;
                            appForm.value = { app_name: '', package_name: '' };
                            await loadAppMappings();
                        } catch (error) {
                            showToast(error.message || 'æ“ä½œå¤±è´¥', 'error');
                        }
                    }

                    async function deleteAppMapping(appName) {
                        if (!confirm(`ç¡®å®šåˆ é™¤åº”ç”¨æ˜ å°„ã€Œ${appName}ã€å—ï¼Ÿ`)) return;
                        try {
                            await apiCall(`/api/rules/apps/${encodeURIComponent(appName)}`, { method: 'DELETE' });
                            showToast('åº”ç”¨æ˜ å°„å·²åˆ é™¤');
                            await loadAppMappings();
                        } catch (error) {
                            showToast('åˆ é™¤å¤±è´¥', 'error');
                        }
                    }

                    async function savePrompt(key, content) {
                        try {
                            await apiCall(`/api/rules/prompts/${key}`, {
                                method: 'PUT',
                                body: JSON.stringify({ content }),
                            });
                            showToast('æç¤ºè¯å·²ä¿å­˜');
                        } catch (error) {
                            showToast('ä¿å­˜å¤±è´¥', 'error');
                        }
                    }

                    async function resetPrompt(key) {
                        if (!confirm('ç¡®å®šé‡ç½®ä¸ºé»˜è®¤æç¤ºè¯å—ï¼Ÿ')) return;
                        try {
                            await apiCall(`/api/rules/prompts/${key}/reset`, { method: 'POST' });
                            showToast('æç¤ºè¯å·²é‡ç½®');
                            await loadSystemPrompts();
                        } catch (error) {
                            showToast('é‡ç½®å¤±è´¥', 'error');
                        }
                    }

                    // Action rules functions
                    async function loadActionRules() {
                        try {
                            const data = await apiCall('/api/rules/actions');
                            actionRules.value = data.actions || [];
                        } catch (error) {
                            console.error('Failed to load action rules:', error);
                        }
                    }

                    function toggleActionExpand(actionName) {
                        expandedActions.value[actionName] = !expandedActions.value[actionName];
                    }

                    async function toggleRuleEnabled(actionName, ruleId) {
                        try {
                            await apiCall(`/api/rules/actions/${encodeURIComponent(actionName)}/rules/${ruleId}/toggle`, { method: 'PUT' });
                            await loadActionRules();
                        } catch (error) {
                            showToast('æ“ä½œå¤±è´¥', 'error');
                        }
                    }

                    function showAddRuleModal(actionName) {
                        editingRuleAction.value = actionName;
                        editingRule.value = null;
                        ruleForm.value = { condition: '', action: '', priority: 0, enabled: true };
                        showRuleModal.value = true;
                    }

                    function editRuleItem(actionName, rule) {
                        editingRuleAction.value = actionName;
                        editingRule.value = rule;
                        ruleForm.value = {
                            condition: rule.condition,
                            action: rule.action,
                            priority: rule.priority || 0,
                            enabled: rule.enabled
                        };
                        showRuleModal.value = true;
                    }

                    async function saveRuleItem() {
                        if (!ruleForm.value.condition || !ruleForm.value.action) {
                            showToast('è¯·å¡«å†™å®Œæ•´ä¿¡æ¯', 'error');
                            return;
                        }
                        try {
                            if (editingRule.value) {
                                // Update existing rule
                                await apiCall(`/api/rules/actions/${encodeURIComponent(editingRuleAction.value)}/rules/${editingRule.value.id}`, {
                                    method: 'PUT',
                                    body: JSON.stringify(ruleForm.value),
                                });
                                showToast('è§„åˆ™å·²æ›´æ–°');
                            } else {
                                // Add new rule
                                await apiCall(`/api/rules/actions/${encodeURIComponent(editingRuleAction.value)}/rules`, {
                                    method: 'POST',
                                    body: JSON.stringify(ruleForm.value),
                                });
                                showToast('è§„åˆ™å·²æ·»åŠ ');
                            }
                            showRuleModal.value = false;
                            await loadActionRules();
                        } catch (error) {
                            showToast(error.message || 'æ“ä½œå¤±è´¥', 'error');
                        }
                    }

                    async function deleteRuleItem(actionName, ruleId) {
                        if (!confirm('ç¡®å®šåˆ é™¤æ­¤è§„åˆ™å—ï¼Ÿ')) return;
                        try {
                            await apiCall(`/api/rules/actions/${encodeURIComponent(actionName)}/rules/${ruleId}`, { method: 'DELETE' });
                            showToast('è§„åˆ™å·²åˆ é™¤');
                            await loadActionRules();
                        } catch (error) {
                            showToast('åˆ é™¤å¤±è´¥', 'error');
                        }
                    }

                    async function resetActionRules() {
                        if (!confirm('ç¡®å®šé‡ç½®æ‰€æœ‰åŠ¨ä½œè§„åˆ™ä¸ºé»˜è®¤å€¼å—ï¼Ÿ')) return;
                        try {
                            await apiCall('/api/rules/actions/reset', { method: 'POST' });
                            showToast('åŠ¨ä½œè§„åˆ™å·²é‡ç½®');
                            await loadActionRules();
                        } catch (error) {
                            showToast('é‡ç½®å¤±è´¥', 'error');
                        }
                    }

                    // Phone Preview Functions
                    const phonePreviewStyle = Vue.computed(() => ({
                        left: previewPosition.value.x + 'px',
                        top: previewPosition.value.y + 'px',
                    }));

                    async function refreshPreview() {
                        if (!previewDeviceId.value) return;
                        // Don't set loading state - keep showing old image for smooth transition
                        try {
                            const response = await fetch(`/api/devices/${previewDeviceId.value}/screenshot/base64`);
                            if (response.ok) {
                                const data = await response.json();
                                if (data.image) {
                                    previewImage.value = data.image;
                                }
                            }
                        } catch (e) {
                            // Silently fail, keep old image
                        }
                    }

                    function openPhonePreview() {
                        updatePreviewPosition();
                        showPhonePreview.value = true;
                        if (!previewDeviceId.value && devices.value.length) {
                            previewDeviceId.value = devices.value[0].id;
                        }
                        refreshPreview();
                    }

                    function startDragPreview(e) {
                        if (e.target.closest('.phone-preview-controls') || e.target.closest('.phone-preview-body')) return;
                        isDragging = true;
                        dragOffset.x = e.clientX - previewPosition.value.x;
                        dragOffset.y = e.clientY - previewPosition.value.y;
                        document.addEventListener('mousemove', onDragPreview);
                        document.addEventListener('mouseup', stopDragPreview);
                    }

                    function onDragPreview(e) {
                        if (!isDragging) return;
                        const maxX = window.innerWidth - 320;
                        const maxY = window.innerHeight - 600;
                        previewPosition.value.x = Math.max(0, Math.min(maxX, e.clientX - dragOffset.x));
                        previewPosition.value.y = Math.max(0, Math.min(maxY, e.clientY - dragOffset.y));
                    }

                    function stopDragPreview() {
                        isDragging = false;
                        document.removeEventListener('mousemove', onDragPreview);
                        document.removeEventListener('mouseup', stopDragPreview);
                    }

                    function startPreviewAutoRefresh() {
                        stopPreviewAutoRefresh();
                        previewInterval = setInterval(() => {
                            if (showPhonePreview.value && previewDeviceId.value) {
                                refreshPreview();
                            }
                        }, 2000); // Refresh every 2 seconds
                    }

                    function stopPreviewAutoRefresh() {
                        if (previewInterval) {
                            clearInterval(previewInterval);
                            previewInterval = null;
                        }
                    }

                    // Watch showPhonePreview to start/stop auto refresh
                    watch(showPhonePreview, (show) => {
                        if (show) {
                            startPreviewAutoRefresh();
                        } else {
                            stopPreviewAutoRefresh();
                        }
                    });

                    // Lifecycle
                    onMounted(() => {
                        console.log('App mounted, initializing...');
                        connectWebSocket();
                        refreshDevices();
                        loadModels();
                        loadDevicePins();
                        initChatSessions();  // Initialize chat sessions from localStorage
                    });

                    onUnmounted(() => {
                        if (ws) ws.close();
                        if (reconnectTimer) clearTimeout(reconnectTimer);
                    });

                    // Watch page changes to load data
                    watch(currentPage, (page, oldPage) => {
                        // ç¦»å¼€ Chat é¡µé¢æ—¶ä¿å­˜æ»šåŠ¨ä½ç½®
                        if (oldPage === 'chat' && chatMessagesRef.value) {
                            chatScrollPosition = chatMessagesRef.value.scrollTop;
                        }

                        // è¿›å…¥ Chat é¡µé¢æ—¶æ¢å¤æ»šåŠ¨ä½ç½®
                        if (page === 'chat') {
                            Vue.nextTick(() => {
                                if (chatMessagesRef.value && chatScrollPosition > 0) {
                                    chatMessagesRef.value.scrollTop = chatScrollPosition;
                                }
                            });
                        }

                        if (page === 'scheduler') {
                            loadScheduledTasks();
                            loadSchedulerLogs();
                        }
                        if (page === 'models') {
                            loadModels();
                            loadModelPresets();
                        }
                        if (page === 'settings') {
                            loadEmailConfig();
                        }
                        if (page === 'rules') {
                            loadAppMappings();
                            loadTimingConfig();
                            loadActionRules();
                            loadSystemPrompts();
                        }
                    });

                    // Watch taskLogs for auto-scroll
                    watch(taskLogs, () => {
                        // Use nextTick equivalent with setTimeout
                        setTimeout(scrollLogsToBottom, 50);
                    }, { deep: true });

                    return {
                        currentPage,
                        devices,
                        selectedDevices,
                        taskContent,
                        taskRunning,
                        taskProgress,
                        taskLogs,
                        scheduledTasks,
                        modelServices,
                        activeModel,
                        modelPresets,
                        showModelForm,
                        modelFormMode,
                        modelForm,
                        openModelForm,
                        saveModel,
                        deleteModel,
                        testModelConfig,
                        addFromPreset,
                        loadModelPresets,
                        getPresetsByCategory,
                        emailConfig,
                        // Rules configuration
                        appMappings,
                        timingConfig,
                        systemPrompts,
                        showAddAppModal,
                        editingApp,
                        appForm,
                        formatTimingKey,
                        updateTiming,
                        editAppMapping,
                        saveAppMapping,
                        deleteAppMapping,
                        savePrompt,
                        resetPrompt,
                        // Action rules
                        actionRules,
                        expandedActions,
                        showRuleModal,
                        editingRuleAction,
                        editingRule,
                        ruleForm,
                        toggleActionExpand,
                        toggleRuleEnabled,
                        showAddRuleModal,
                        editRuleItem,
                        saveRuleItem,
                        deleteRuleItem,
                        resetActionRules,
                        wsConnected,
                        loading,
                        toasts,
                        devicePins,
                        logContainer,
                        showSchedulerForm,
                        schedulerFormMode,
                        schedulerForm,
                        // Scheduler logs
                        schedulerLogs,
                        showLogDetailModal,
                        logDetailData,
                        loadSchedulerLogs,
                        clearAllSchedulerLogs,
                        formatLogTime,
                        showLogDetails,
                        clearTaskLogs,
                        // Chat
                        chatMessages,
                        chatInput,
                        chatDeviceId,
                        chatRunning,
                        chatMessagesRef,
                        chatAutoEmail,
                        complexTaskMode,
                        subtaskTimeoutSeconds,
                        subtaskCountdown,
                        sendChatMessage,
                        retryMessage,
                        skipSubtask,
                        stopChatTask,
                        onChatDeviceChange,
                        adjustChatInputHeight,
                        openTaskDetail,
                        showTaskDetail,
                        taskDetailData,
                        // Chat sessions
                        chatSessions,
                        currentSessionId,
                        createNewSession,
                        switchSession,
                        deleteSession,
                        formatSessionTime,
                        formatMsgTime,
                        // Phone preview
                        showPhonePreview,
                        previewDeviceId,
                        previewImage,
                        previewLoading,
                        phonePreviewStyle,
                        refreshPreview,
                        openPhonePreview,
                        startDragPreview,
                        // Functions
                        showToast,
                        refreshDevices,
                        toggleDeviceSelection,
                        selectAllDevices,
                        getDeviceName,
                        unlockDevice,
                        updateDevicePin,
                        saveDevicePin,
                        loadDevicePins,
                        pinInputValues,
                        showPinFor,
                        toggleShowPin,
                        // Wireless pairing
                        pairAddress,
                        pairCode,
                        connectAddress,
                        pairingLoading,
                        connectingLoading,
                        deviceLogs,
                        wirelessPair,
                        tcpConnect,
                        disconnectDevice,
                        // APK install
                        apkTargetDevice,
                        apkFile,
                        apkInstalling,
                        apkLogs,
                        apkFileInput,
                        onApkFileSelect,
                        installApk,
                        // File manager
                        fileDevice,
                        filePath,
                        fileList,
                        fileLoading,
                        uploadSelectedFile,
                        fileUploading,
                        uploadFileInput,
                        loadFiles,
                        navigateTo,
                        goUp,
                        formatFileSize,
                        isImageFile,
                        isVideoFile,
                        isAudioFile,
                        downloadFile,
                        onUploadFileSelect,
                        uploadFile,
                        deleteFileConfirm,
                        runTask,
                        stopTask,
                        loadScheduledTasks,
                        toggleScheduledTask,
                        runScheduledTaskNow,
                        deleteScheduledTask,
                        showCreateScheduledTask,
                        editScheduledTask,
                        cancelSchedulerForm,
                        saveScheduledTask,
                        formatScheduleType,
                        loadModels,
                        activateModel,
                        testModel,
                        loadEmailConfig,
                        saveEmailConfig,
                        testEmail,
                    };
                },
            });

            app.mount('#app');
            console.log('Vue app mounted successfully');
        }

        // Initialize after page load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(initApp, 100);
            });
        } else {
            setTimeout(initApp, 100);
        }
    </script>
</body>

</html>